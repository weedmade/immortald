import { HealthStatus, Networks, ActionStatus, TransactionStatus, TransactionType, ActionTypes, GasMode, BalanceTypes, ValidatorStatusTypes, YieldProviders, RewardClaiming, RewardSchedule, YieldType, RewardTypes, FeeConfigurationStatus } from '../chunk-IRWPDFN7.js';
import { faker } from '@faker-js/faker';
import { http, delay, HttpResponse } from 'msw';

var getHealthControllerHealthV2ResponseMock = (overrideResponse = {}) => ({
  db: faker.helpers.arrayElement(Object.values(HealthStatus)),
  status: faker.helpers.arrayElement(Object.values(HealthStatus)),
  ...overrideResponse
});
var getActionControllerGetActionResponseMock = (overrideResponse = {}) => ({
  accountAddresses: faker.helpers.arrayElement([
    Array.from(
      { length: faker.number.int({ min: 1, max: 10 }) },
      (_, i) => i + 1
    ).map(() => faker.word.sample()),
    void 0
  ]),
  addresses: {
    additionalAddresses: faker.helpers.arrayElement([
      faker.helpers.arrayElement([
        { cosmosPubKey: faker.word.sample(), ...overrideResponse },
        { binanceBeaconAddress: faker.word.sample(), ...overrideResponse },
        {
          lidoStakeAccounts: Array.from(
            { length: faker.number.int({ min: 1, max: 10 }) },
            (_, i) => i + 1
          ).map(() => faker.word.sample()),
          stakeAccounts: Array.from(
            { length: faker.number.int({ min: 1, max: 10 }) },
            (_, i) => i + 1
          ).map(() => faker.word.sample()),
          ...overrideResponse
        },
        { tezosPubKey: faker.word.sample(), ...overrideResponse },
        {
          cAddressBech: faker.word.sample(),
          pAddressBech: faker.word.sample(),
          ...overrideResponse
        }
      ]),
      void 0
    ]),
    address: faker.word.sample(),
    explorerUrl: faker.helpers.arrayElement([faker.word.sample(), void 0]),
    ...overrideResponse
  },
  amount: faker.helpers.arrayElement([faker.word.sample(), null]),
  completedAt: faker.helpers.arrayElement([
    `${faker.date.past().toISOString().split(".")[0]}Z`,
    null
  ]),
  createdAt: `${faker.date.past().toISOString().split(".")[0]}Z`,
  currentStepIndex: faker.number.int({ min: void 0, max: void 0 }),
  id: faker.word.sample(),
  inputToken: faker.helpers.arrayElement([
    {
      address: faker.helpers.arrayElement([faker.word.sample(), void 0]),
      coinGeckoId: faker.helpers.arrayElement([faker.word.sample(), void 0]),
      decimals: faker.number.int({ min: void 0, max: void 0 }),
      isPoints: faker.helpers.arrayElement([
        faker.datatype.boolean(),
        void 0
      ]),
      logoURI: faker.helpers.arrayElement([faker.word.sample(), void 0]),
      name: faker.word.sample(),
      network: faker.helpers.arrayElement(Object.values(Networks)),
      symbol: faker.word.sample(),
      ...overrideResponse
    },
    void 0
  ]),
  integrationId: faker.word.sample(),
  status: faker.helpers.arrayElement(Object.values(ActionStatus)),
  tokenId: faker.helpers.arrayElement([faker.word.sample(), null]),
  transactions: Array.from(
    { length: faker.number.int({ min: 1, max: 10 }) },
    (_, i) => i + 1
  ).map(() => ({
    accountAddresses: faker.helpers.arrayElement([
      Array.from(
        { length: faker.number.int({ min: 1, max: 10 }) },
        (_, i) => i + 1
      ).map(() => faker.word.sample()),
      void 0
    ]),
    broadcastedAt: faker.helpers.arrayElement([
      `${faker.date.past().toISOString().split(".")[0]}Z`,
      null
    ]),
    createdAt: `${faker.date.past().toISOString().split(".")[0]}Z`,
    error: faker.helpers.arrayElement([faker.word.sample(), null]),
    explorerUrl: faker.helpers.arrayElement([faker.word.sample(), null]),
    gasEstimate: {
      amount: faker.helpers.arrayElement([faker.word.sample(), null]),
      gasLimit: faker.helpers.arrayElement([faker.word.sample(), void 0]),
      token: {
        address: faker.helpers.arrayElement([faker.word.sample(), void 0]),
        coinGeckoId: faker.helpers.arrayElement([
          faker.word.sample(),
          void 0
        ]),
        decimals: faker.number.int({ min: void 0, max: void 0 }),
        isPoints: faker.helpers.arrayElement([
          faker.datatype.boolean(),
          void 0
        ]),
        logoURI: faker.helpers.arrayElement([faker.word.sample(), void 0]),
        name: faker.word.sample(),
        network: faker.helpers.arrayElement(Object.values(Networks)),
        symbol: faker.word.sample(),
        ...overrideResponse
      },
      ...overrideResponse
    },
    hash: faker.helpers.arrayElement([faker.word.sample(), null]),
    id: faker.word.sample(),
    isMessage: faker.datatype.boolean(),
    ledgerHwAppId: faker.helpers.arrayElement([faker.word.sample(), null]),
    network: faker.helpers.arrayElement(Object.values(Networks)),
    signedTransaction: faker.helpers.arrayElement([faker.word.sample(), null]),
    stakeId: faker.word.sample(),
    status: faker.helpers.arrayElement(Object.values(TransactionStatus)),
    stepIndex: faker.number.int({ min: void 0, max: void 0 }),
    type: faker.helpers.arrayElement(Object.values(TransactionType)),
    unsignedTransaction: faker.helpers.arrayElement([
      faker.word.sample(),
      null
    ]),
    ...overrideResponse
  })),
  type: faker.helpers.arrayElement(Object.values(ActionTypes)),
  USDAmount: faker.helpers.arrayElement([faker.word.sample(), null]),
  validatorAddress: faker.helpers.arrayElement([faker.word.sample(), null]),
  validatorAddresses: Array.from(
    { length: faker.number.int({ min: 1, max: 10 }) },
    (_, i) => i + 1
  ).map(() => faker.word.sample()),
  ...overrideResponse
});
var getActionControllerGetGasEstimateResponseMock = (overrideResponse = {}) => ({
  amount: faker.helpers.arrayElement([faker.word.sample(), null]),
  gasLimit: faker.helpers.arrayElement([faker.word.sample(), void 0]),
  token: {
    address: faker.helpers.arrayElement([faker.word.sample(), void 0]),
    coinGeckoId: faker.helpers.arrayElement([faker.word.sample(), void 0]),
    decimals: faker.number.int({ min: void 0, max: void 0 }),
    isPoints: faker.helpers.arrayElement([faker.datatype.boolean(), void 0]),
    logoURI: faker.helpers.arrayElement([faker.word.sample(), void 0]),
    name: faker.word.sample(),
    network: faker.helpers.arrayElement(Object.values(Networks)),
    symbol: faker.word.sample(),
    ...overrideResponse
  },
  ...overrideResponse
});
var getActionControllerEnterResponseMock = (overrideResponse = {}) => ({
  accountAddresses: faker.helpers.arrayElement([
    Array.from(
      { length: faker.number.int({ min: 1, max: 10 }) },
      (_, i) => i + 1
    ).map(() => faker.word.sample()),
    void 0
  ]),
  addresses: {
    additionalAddresses: faker.helpers.arrayElement([
      faker.helpers.arrayElement([
        { cosmosPubKey: faker.word.sample(), ...overrideResponse },
        { binanceBeaconAddress: faker.word.sample(), ...overrideResponse },
        {
          lidoStakeAccounts: Array.from(
            { length: faker.number.int({ min: 1, max: 10 }) },
            (_, i) => i + 1
          ).map(() => faker.word.sample()),
          stakeAccounts: Array.from(
            { length: faker.number.int({ min: 1, max: 10 }) },
            (_, i) => i + 1
          ).map(() => faker.word.sample()),
          ...overrideResponse
        },
        { tezosPubKey: faker.word.sample(), ...overrideResponse },
        {
          cAddressBech: faker.word.sample(),
          pAddressBech: faker.word.sample(),
          ...overrideResponse
        }
      ]),
      void 0
    ]),
    address: faker.word.sample(),
    explorerUrl: faker.helpers.arrayElement([faker.word.sample(), void 0]),
    ...overrideResponse
  },
  amount: faker.helpers.arrayElement([faker.word.sample(), null]),
  completedAt: faker.helpers.arrayElement([
    `${faker.date.past().toISOString().split(".")[0]}Z`,
    null
  ]),
  createdAt: `${faker.date.past().toISOString().split(".")[0]}Z`,
  currentStepIndex: faker.number.int({ min: void 0, max: void 0 }),
  id: faker.word.sample(),
  inputToken: faker.helpers.arrayElement([
    {
      address: faker.helpers.arrayElement([faker.word.sample(), void 0]),
      coinGeckoId: faker.helpers.arrayElement([faker.word.sample(), void 0]),
      decimals: faker.number.int({ min: void 0, max: void 0 }),
      isPoints: faker.helpers.arrayElement([
        faker.datatype.boolean(),
        void 0
      ]),
      logoURI: faker.helpers.arrayElement([faker.word.sample(), void 0]),
      name: faker.word.sample(),
      network: faker.helpers.arrayElement(Object.values(Networks)),
      symbol: faker.word.sample(),
      ...overrideResponse
    },
    void 0
  ]),
  integrationId: faker.word.sample(),
  status: faker.helpers.arrayElement(Object.values(ActionStatus)),
  tokenId: faker.helpers.arrayElement([faker.word.sample(), null]),
  transactions: Array.from(
    { length: faker.number.int({ min: 1, max: 10 }) },
    (_, i) => i + 1
  ).map(() => ({
    accountAddresses: faker.helpers.arrayElement([
      Array.from(
        { length: faker.number.int({ min: 1, max: 10 }) },
        (_, i) => i + 1
      ).map(() => faker.word.sample()),
      void 0
    ]),
    broadcastedAt: faker.helpers.arrayElement([
      `${faker.date.past().toISOString().split(".")[0]}Z`,
      null
    ]),
    createdAt: `${faker.date.past().toISOString().split(".")[0]}Z`,
    error: faker.helpers.arrayElement([faker.word.sample(), null]),
    explorerUrl: faker.helpers.arrayElement([faker.word.sample(), null]),
    gasEstimate: {
      amount: faker.helpers.arrayElement([faker.word.sample(), null]),
      gasLimit: faker.helpers.arrayElement([faker.word.sample(), void 0]),
      token: {
        address: faker.helpers.arrayElement([faker.word.sample(), void 0]),
        coinGeckoId: faker.helpers.arrayElement([
          faker.word.sample(),
          void 0
        ]),
        decimals: faker.number.int({ min: void 0, max: void 0 }),
        isPoints: faker.helpers.arrayElement([
          faker.datatype.boolean(),
          void 0
        ]),
        logoURI: faker.helpers.arrayElement([faker.word.sample(), void 0]),
        name: faker.word.sample(),
        network: faker.helpers.arrayElement(Object.values(Networks)),
        symbol: faker.word.sample(),
        ...overrideResponse
      },
      ...overrideResponse
    },
    hash: faker.helpers.arrayElement([faker.word.sample(), null]),
    id: faker.word.sample(),
    isMessage: faker.datatype.boolean(),
    ledgerHwAppId: faker.helpers.arrayElement([faker.word.sample(), null]),
    network: faker.helpers.arrayElement(Object.values(Networks)),
    signedTransaction: faker.helpers.arrayElement([faker.word.sample(), null]),
    stakeId: faker.word.sample(),
    status: faker.helpers.arrayElement(Object.values(TransactionStatus)),
    stepIndex: faker.number.int({ min: void 0, max: void 0 }),
    type: faker.helpers.arrayElement(Object.values(TransactionType)),
    unsignedTransaction: faker.helpers.arrayElement([
      faker.word.sample(),
      null
    ]),
    ...overrideResponse
  })),
  type: faker.helpers.arrayElement(Object.values(ActionTypes)),
  USDAmount: faker.helpers.arrayElement([faker.word.sample(), null]),
  validatorAddress: faker.helpers.arrayElement([faker.word.sample(), null]),
  validatorAddresses: Array.from(
    { length: faker.number.int({ min: 1, max: 10 }) },
    (_, i) => i + 1
  ).map(() => faker.word.sample()),
  ...overrideResponse
});
var getActionControllerExitResponseMock = (overrideResponse = {}) => ({
  accountAddresses: faker.helpers.arrayElement([
    Array.from(
      { length: faker.number.int({ min: 1, max: 10 }) },
      (_, i) => i + 1
    ).map(() => faker.word.sample()),
    void 0
  ]),
  addresses: {
    additionalAddresses: faker.helpers.arrayElement([
      faker.helpers.arrayElement([
        { cosmosPubKey: faker.word.sample(), ...overrideResponse },
        { binanceBeaconAddress: faker.word.sample(), ...overrideResponse },
        {
          lidoStakeAccounts: Array.from(
            { length: faker.number.int({ min: 1, max: 10 }) },
            (_, i) => i + 1
          ).map(() => faker.word.sample()),
          stakeAccounts: Array.from(
            { length: faker.number.int({ min: 1, max: 10 }) },
            (_, i) => i + 1
          ).map(() => faker.word.sample()),
          ...overrideResponse
        },
        { tezosPubKey: faker.word.sample(), ...overrideResponse },
        {
          cAddressBech: faker.word.sample(),
          pAddressBech: faker.word.sample(),
          ...overrideResponse
        }
      ]),
      void 0
    ]),
    address: faker.word.sample(),
    explorerUrl: faker.helpers.arrayElement([faker.word.sample(), void 0]),
    ...overrideResponse
  },
  amount: faker.helpers.arrayElement([faker.word.sample(), null]),
  completedAt: faker.helpers.arrayElement([
    `${faker.date.past().toISOString().split(".")[0]}Z`,
    null
  ]),
  createdAt: `${faker.date.past().toISOString().split(".")[0]}Z`,
  currentStepIndex: faker.number.int({ min: void 0, max: void 0 }),
  id: faker.word.sample(),
  inputToken: faker.helpers.arrayElement([
    {
      address: faker.helpers.arrayElement([faker.word.sample(), void 0]),
      coinGeckoId: faker.helpers.arrayElement([faker.word.sample(), void 0]),
      decimals: faker.number.int({ min: void 0, max: void 0 }),
      isPoints: faker.helpers.arrayElement([
        faker.datatype.boolean(),
        void 0
      ]),
      logoURI: faker.helpers.arrayElement([faker.word.sample(), void 0]),
      name: faker.word.sample(),
      network: faker.helpers.arrayElement(Object.values(Networks)),
      symbol: faker.word.sample(),
      ...overrideResponse
    },
    void 0
  ]),
  integrationId: faker.word.sample(),
  status: faker.helpers.arrayElement(Object.values(ActionStatus)),
  tokenId: faker.helpers.arrayElement([faker.word.sample(), null]),
  transactions: Array.from(
    { length: faker.number.int({ min: 1, max: 10 }) },
    (_, i) => i + 1
  ).map(() => ({
    accountAddresses: faker.helpers.arrayElement([
      Array.from(
        { length: faker.number.int({ min: 1, max: 10 }) },
        (_, i) => i + 1
      ).map(() => faker.word.sample()),
      void 0
    ]),
    broadcastedAt: faker.helpers.arrayElement([
      `${faker.date.past().toISOString().split(".")[0]}Z`,
      null
    ]),
    createdAt: `${faker.date.past().toISOString().split(".")[0]}Z`,
    error: faker.helpers.arrayElement([faker.word.sample(), null]),
    explorerUrl: faker.helpers.arrayElement([faker.word.sample(), null]),
    gasEstimate: {
      amount: faker.helpers.arrayElement([faker.word.sample(), null]),
      gasLimit: faker.helpers.arrayElement([faker.word.sample(), void 0]),
      token: {
        address: faker.helpers.arrayElement([faker.word.sample(), void 0]),
        coinGeckoId: faker.helpers.arrayElement([
          faker.word.sample(),
          void 0
        ]),
        decimals: faker.number.int({ min: void 0, max: void 0 }),
        isPoints: faker.helpers.arrayElement([
          faker.datatype.boolean(),
          void 0
        ]),
        logoURI: faker.helpers.arrayElement([faker.word.sample(), void 0]),
        name: faker.word.sample(),
        network: faker.helpers.arrayElement(Object.values(Networks)),
        symbol: faker.word.sample(),
        ...overrideResponse
      },
      ...overrideResponse
    },
    hash: faker.helpers.arrayElement([faker.word.sample(), null]),
    id: faker.word.sample(),
    isMessage: faker.datatype.boolean(),
    ledgerHwAppId: faker.helpers.arrayElement([faker.word.sample(), null]),
    network: faker.helpers.arrayElement(Object.values(Networks)),
    signedTransaction: faker.helpers.arrayElement([faker.word.sample(), null]),
    stakeId: faker.word.sample(),
    status: faker.helpers.arrayElement(Object.values(TransactionStatus)),
    stepIndex: faker.number.int({ min: void 0, max: void 0 }),
    type: faker.helpers.arrayElement(Object.values(TransactionType)),
    unsignedTransaction: faker.helpers.arrayElement([
      faker.word.sample(),
      null
    ]),
    ...overrideResponse
  })),
  type: faker.helpers.arrayElement(Object.values(ActionTypes)),
  USDAmount: faker.helpers.arrayElement([faker.word.sample(), null]),
  validatorAddress: faker.helpers.arrayElement([faker.word.sample(), null]),
  validatorAddresses: Array.from(
    { length: faker.number.int({ min: 1, max: 10 }) },
    (_, i) => i + 1
  ).map(() => faker.word.sample()),
  ...overrideResponse
});
var getActionControllerPendingResponseMock = (overrideResponse = {}) => ({
  accountAddresses: faker.helpers.arrayElement([
    Array.from(
      { length: faker.number.int({ min: 1, max: 10 }) },
      (_, i) => i + 1
    ).map(() => faker.word.sample()),
    void 0
  ]),
  addresses: {
    additionalAddresses: faker.helpers.arrayElement([
      faker.helpers.arrayElement([
        { cosmosPubKey: faker.word.sample(), ...overrideResponse },
        { binanceBeaconAddress: faker.word.sample(), ...overrideResponse },
        {
          lidoStakeAccounts: Array.from(
            { length: faker.number.int({ min: 1, max: 10 }) },
            (_, i) => i + 1
          ).map(() => faker.word.sample()),
          stakeAccounts: Array.from(
            { length: faker.number.int({ min: 1, max: 10 }) },
            (_, i) => i + 1
          ).map(() => faker.word.sample()),
          ...overrideResponse
        },
        { tezosPubKey: faker.word.sample(), ...overrideResponse },
        {
          cAddressBech: faker.word.sample(),
          pAddressBech: faker.word.sample(),
          ...overrideResponse
        }
      ]),
      void 0
    ]),
    address: faker.word.sample(),
    explorerUrl: faker.helpers.arrayElement([faker.word.sample(), void 0]),
    ...overrideResponse
  },
  amount: faker.helpers.arrayElement([faker.word.sample(), null]),
  completedAt: faker.helpers.arrayElement([
    `${faker.date.past().toISOString().split(".")[0]}Z`,
    null
  ]),
  createdAt: `${faker.date.past().toISOString().split(".")[0]}Z`,
  currentStepIndex: faker.number.int({ min: void 0, max: void 0 }),
  id: faker.word.sample(),
  inputToken: faker.helpers.arrayElement([
    {
      address: faker.helpers.arrayElement([faker.word.sample(), void 0]),
      coinGeckoId: faker.helpers.arrayElement([faker.word.sample(), void 0]),
      decimals: faker.number.int({ min: void 0, max: void 0 }),
      isPoints: faker.helpers.arrayElement([
        faker.datatype.boolean(),
        void 0
      ]),
      logoURI: faker.helpers.arrayElement([faker.word.sample(), void 0]),
      name: faker.word.sample(),
      network: faker.helpers.arrayElement(Object.values(Networks)),
      symbol: faker.word.sample(),
      ...overrideResponse
    },
    void 0
  ]),
  integrationId: faker.word.sample(),
  status: faker.helpers.arrayElement(Object.values(ActionStatus)),
  tokenId: faker.helpers.arrayElement([faker.word.sample(), null]),
  transactions: Array.from(
    { length: faker.number.int({ min: 1, max: 10 }) },
    (_, i) => i + 1
  ).map(() => ({
    accountAddresses: faker.helpers.arrayElement([
      Array.from(
        { length: faker.number.int({ min: 1, max: 10 }) },
        (_, i) => i + 1
      ).map(() => faker.word.sample()),
      void 0
    ]),
    broadcastedAt: faker.helpers.arrayElement([
      `${faker.date.past().toISOString().split(".")[0]}Z`,
      null
    ]),
    createdAt: `${faker.date.past().toISOString().split(".")[0]}Z`,
    error: faker.helpers.arrayElement([faker.word.sample(), null]),
    explorerUrl: faker.helpers.arrayElement([faker.word.sample(), null]),
    gasEstimate: {
      amount: faker.helpers.arrayElement([faker.word.sample(), null]),
      gasLimit: faker.helpers.arrayElement([faker.word.sample(), void 0]),
      token: {
        address: faker.helpers.arrayElement([faker.word.sample(), void 0]),
        coinGeckoId: faker.helpers.arrayElement([
          faker.word.sample(),
          void 0
        ]),
        decimals: faker.number.int({ min: void 0, max: void 0 }),
        isPoints: faker.helpers.arrayElement([
          faker.datatype.boolean(),
          void 0
        ]),
        logoURI: faker.helpers.arrayElement([faker.word.sample(), void 0]),
        name: faker.word.sample(),
        network: faker.helpers.arrayElement(Object.values(Networks)),
        symbol: faker.word.sample(),
        ...overrideResponse
      },
      ...overrideResponse
    },
    hash: faker.helpers.arrayElement([faker.word.sample(), null]),
    id: faker.word.sample(),
    isMessage: faker.datatype.boolean(),
    ledgerHwAppId: faker.helpers.arrayElement([faker.word.sample(), null]),
    network: faker.helpers.arrayElement(Object.values(Networks)),
    signedTransaction: faker.helpers.arrayElement([faker.word.sample(), null]),
    stakeId: faker.word.sample(),
    status: faker.helpers.arrayElement(Object.values(TransactionStatus)),
    stepIndex: faker.number.int({ min: void 0, max: void 0 }),
    type: faker.helpers.arrayElement(Object.values(TransactionType)),
    unsignedTransaction: faker.helpers.arrayElement([
      faker.word.sample(),
      null
    ]),
    ...overrideResponse
  })),
  type: faker.helpers.arrayElement(Object.values(ActionTypes)),
  USDAmount: faker.helpers.arrayElement([faker.word.sample(), null]),
  validatorAddress: faker.helpers.arrayElement([faker.word.sample(), null]),
  validatorAddresses: Array.from(
    { length: faker.number.int({ min: 1, max: 10 }) },
    (_, i) => i + 1
  ).map(() => faker.word.sample()),
  ...overrideResponse
});
var getActionControllerEnterGasEstimationResponseMock = (overrideResponse = {}) => ({
  amount: faker.helpers.arrayElement([faker.word.sample(), null]),
  gasLimit: faker.helpers.arrayElement([faker.word.sample(), void 0]),
  token: {
    address: faker.helpers.arrayElement([faker.word.sample(), void 0]),
    coinGeckoId: faker.helpers.arrayElement([faker.word.sample(), void 0]),
    decimals: faker.number.int({ min: void 0, max: void 0 }),
    isPoints: faker.helpers.arrayElement([faker.datatype.boolean(), void 0]),
    logoURI: faker.helpers.arrayElement([faker.word.sample(), void 0]),
    name: faker.word.sample(),
    network: faker.helpers.arrayElement(Object.values(Networks)),
    symbol: faker.word.sample(),
    ...overrideResponse
  },
  ...overrideResponse
});
var getActionControllerExitGasEstimateResponseMock = (overrideResponse = {}) => ({
  amount: faker.helpers.arrayElement([faker.word.sample(), null]),
  gasLimit: faker.helpers.arrayElement([faker.word.sample(), void 0]),
  token: {
    address: faker.helpers.arrayElement([faker.word.sample(), void 0]),
    coinGeckoId: faker.helpers.arrayElement([faker.word.sample(), void 0]),
    decimals: faker.number.int({ min: void 0, max: void 0 }),
    isPoints: faker.helpers.arrayElement([faker.datatype.boolean(), void 0]),
    logoURI: faker.helpers.arrayElement([faker.word.sample(), void 0]),
    name: faker.word.sample(),
    network: faker.helpers.arrayElement(Object.values(Networks)),
    symbol: faker.word.sample(),
    ...overrideResponse
  },
  ...overrideResponse
});
var getActionControllerListResponseMock = (overrideResponse = {}) => ({
  data: {},
  hasNextPage: faker.datatype.boolean(),
  limit: faker.number.int({ min: void 0, max: void 0 }),
  page: faker.number.int({ min: void 0, max: void 0 }),
  ...overrideResponse,
  ...overrideResponse
});
var getActionControllerPendingGasEstimateResponseMock = (overrideResponse = {}) => ({
  amount: faker.helpers.arrayElement([faker.word.sample(), null]),
  gasLimit: faker.helpers.arrayElement([faker.word.sample(), void 0]),
  token: {
    address: faker.helpers.arrayElement([faker.word.sample(), void 0]),
    coinGeckoId: faker.helpers.arrayElement([faker.word.sample(), void 0]),
    decimals: faker.number.int({ min: void 0, max: void 0 }),
    isPoints: faker.helpers.arrayElement([faker.datatype.boolean(), void 0]),
    logoURI: faker.helpers.arrayElement([faker.word.sample(), void 0]),
    name: faker.word.sample(),
    network: faker.helpers.arrayElement(Object.values(Networks)),
    symbol: faker.word.sample(),
    ...overrideResponse
  },
  ...overrideResponse
});
var getTransactionControllerGetTransactionResponseMock = (overrideResponse = {}) => ({
  accountAddresses: faker.helpers.arrayElement([
    Array.from(
      { length: faker.number.int({ min: 1, max: 10 }) },
      (_, i) => i + 1
    ).map(() => faker.word.sample()),
    void 0
  ]),
  broadcastedAt: faker.helpers.arrayElement([
    `${faker.date.past().toISOString().split(".")[0]}Z`,
    null
  ]),
  createdAt: `${faker.date.past().toISOString().split(".")[0]}Z`,
  error: faker.helpers.arrayElement([faker.word.sample(), null]),
  explorerUrl: faker.helpers.arrayElement([faker.word.sample(), null]),
  gasEstimate: {
    amount: faker.helpers.arrayElement([faker.word.sample(), null]),
    gasLimit: faker.helpers.arrayElement([faker.word.sample(), void 0]),
    token: {
      address: faker.helpers.arrayElement([faker.word.sample(), void 0]),
      coinGeckoId: faker.helpers.arrayElement([faker.word.sample(), void 0]),
      decimals: faker.number.int({ min: void 0, max: void 0 }),
      isPoints: faker.helpers.arrayElement([
        faker.datatype.boolean(),
        void 0
      ]),
      logoURI: faker.helpers.arrayElement([faker.word.sample(), void 0]),
      name: faker.word.sample(),
      network: faker.helpers.arrayElement(Object.values(Networks)),
      symbol: faker.word.sample(),
      ...overrideResponse
    },
    ...overrideResponse
  },
  hash: faker.helpers.arrayElement([faker.word.sample(), null]),
  id: faker.word.sample(),
  isMessage: faker.datatype.boolean(),
  ledgerHwAppId: faker.helpers.arrayElement([faker.word.sample(), null]),
  network: faker.helpers.arrayElement(Object.values(Networks)),
  signedTransaction: faker.helpers.arrayElement([faker.word.sample(), null]),
  stakeId: faker.word.sample(),
  status: faker.helpers.arrayElement(Object.values(TransactionStatus)),
  stepIndex: faker.number.int({ min: void 0, max: void 0 }),
  type: faker.helpers.arrayElement(Object.values(TransactionType)),
  unsignedTransaction: faker.helpers.arrayElement([faker.word.sample(), null]),
  ...overrideResponse
});
var getTransactionControllerConstructResponseMock = (overrideResponse = {}) => ({
  accountAddresses: faker.helpers.arrayElement([
    Array.from(
      { length: faker.number.int({ min: 1, max: 10 }) },
      (_, i) => i + 1
    ).map(() => faker.word.sample()),
    void 0
  ]),
  broadcastedAt: faker.helpers.arrayElement([
    `${faker.date.past().toISOString().split(".")[0]}Z`,
    null
  ]),
  createdAt: `${faker.date.past().toISOString().split(".")[0]}Z`,
  error: faker.helpers.arrayElement([faker.word.sample(), null]),
  explorerUrl: faker.helpers.arrayElement([faker.word.sample(), null]),
  gasEstimate: {
    amount: faker.helpers.arrayElement([faker.word.sample(), null]),
    gasLimit: faker.helpers.arrayElement([faker.word.sample(), void 0]),
    token: {
      address: faker.helpers.arrayElement([faker.word.sample(), void 0]),
      coinGeckoId: faker.helpers.arrayElement([faker.word.sample(), void 0]),
      decimals: faker.number.int({ min: void 0, max: void 0 }),
      isPoints: faker.helpers.arrayElement([
        faker.datatype.boolean(),
        void 0
      ]),
      logoURI: faker.helpers.arrayElement([faker.word.sample(), void 0]),
      name: faker.word.sample(),
      network: faker.helpers.arrayElement(Object.values(Networks)),
      symbol: faker.word.sample(),
      ...overrideResponse
    },
    ...overrideResponse
  },
  hash: faker.helpers.arrayElement([faker.word.sample(), null]),
  id: faker.word.sample(),
  isMessage: faker.datatype.boolean(),
  ledgerHwAppId: faker.helpers.arrayElement([faker.word.sample(), null]),
  network: faker.helpers.arrayElement(Object.values(Networks)),
  signedTransaction: faker.helpers.arrayElement([faker.word.sample(), null]),
  stakeId: faker.word.sample(),
  status: faker.helpers.arrayElement(Object.values(TransactionStatus)),
  stepIndex: faker.number.int({ min: void 0, max: void 0 }),
  type: faker.helpers.arrayElement(Object.values(TransactionType)),
  unsignedTransaction: faker.helpers.arrayElement([faker.word.sample(), null]),
  ...overrideResponse
});
var getTransactionControllerSubmitResponseMock = (overrideResponse = {}) => ({
  link: faker.word.sample(),
  transactionHash: faker.word.sample(),
  ...overrideResponse
});
var getTransactionControllerGetTransactionStatusFromIdResponseMock = (overrideResponse = {}) => ({
  blockNumber: faker.helpers.arrayElement([faker.word.sample(), void 0]),
  hash: faker.word.sample(),
  network: faker.helpers.arrayElement(Object.values(Networks)),
  raw: {},
  status: faker.helpers.arrayElement(Object.values(TransactionStatus)),
  url: faker.word.sample(),
  ...overrideResponse
});
var getTransactionControllerGetGasForNetworkResponseMock = (overrideResponse = {}) => ({
  customisable: faker.datatype.boolean(),
  modes: {
    denom: faker.word.sample(),
    values: Array.from(
      { length: faker.number.int({ min: 1, max: 10 }) },
      (_, i) => i + 1
    ).map(() => ({
      gasArgs: faker.helpers.arrayElement([
        { gasPrice: faker.word.sample(), ...overrideResponse },
        {
          maxFeePerGas: faker.word.sample(),
          maxPriorityFeePerGas: faker.word.sample(),
          type: faker.number.int({ min: void 0, max: void 0 }),
          ...overrideResponse
        },
        { ...overrideResponse }
      ]),
      name: faker.helpers.arrayElement(Object.values(GasMode)),
      value: faker.word.sample(),
      ...overrideResponse
    })),
    ...overrideResponse
  },
  ...overrideResponse
});
var getTransactionControllerGetTransactionStatusByNetworkAndHashResponseMock = (overrideResponse = {}) => ({
  blockNumber: faker.helpers.arrayElement([faker.word.sample(), void 0]),
  hash: faker.word.sample(),
  network: faker.helpers.arrayElement(Object.values(Networks)),
  raw: {},
  status: faker.helpers.arrayElement(Object.values(TransactionStatus)),
  url: faker.word.sample(),
  ...overrideResponse
});
var getTransactionControllerGetTransactionVerificationMessageForNetworkResponseMock = (overrideResponse = {}) => ({
  message: faker.word.sample(),
  ...overrideResponse
});
var getTokenControllerGetTokensResponseMock = (overrideResponse = {}) => Array.from(
  { length: faker.number.int({ min: 1, max: 10 }) },
  (_, i) => i + 1
).map(() => ({
  availableYields: Array.from(
    { length: faker.number.int({ min: 1, max: 10 }) },
    (_, i) => i + 1
  ).map(() => faker.word.sample()),
  token: {
    address: faker.helpers.arrayElement([faker.word.sample(), void 0]),
    coinGeckoId: faker.helpers.arrayElement([faker.word.sample(), void 0]),
    decimals: faker.number.int({ min: void 0, max: void 0 }),
    isPoints: faker.helpers.arrayElement([
      faker.datatype.boolean(),
      void 0
    ]),
    logoURI: faker.helpers.arrayElement([faker.word.sample(), void 0]),
    name: faker.word.sample(),
    network: faker.helpers.arrayElement(Object.values(Networks)),
    symbol: faker.word.sample(),
    ...overrideResponse
  },
  ...overrideResponse
}));
var getTokenControllerGetTokenPricesResponseMock = (overrideResponse = {}) => ({ ...overrideResponse });
var getTokenControllerGetTokenBalancesResponseMock = (overrideResponse = {}) => Array.from(
  { length: faker.number.int({ min: 1, max: 10 }) },
  (_, i) => i + 1
).map(() => ({
  amount: faker.word.sample(),
  token: {
    address: faker.helpers.arrayElement([faker.word.sample(), void 0]),
    coinGeckoId: faker.helpers.arrayElement([faker.word.sample(), void 0]),
    decimals: faker.number.int({ min: void 0, max: void 0 }),
    isPoints: faker.helpers.arrayElement([
      faker.datatype.boolean(),
      void 0
    ]),
    logoURI: faker.helpers.arrayElement([faker.word.sample(), void 0]),
    name: faker.word.sample(),
    network: faker.helpers.arrayElement(Object.values(Networks)),
    symbol: faker.word.sample(),
    ...overrideResponse
  },
  ...overrideResponse
}));
var getTokenControllerTokenBalancesScanResponseMock = (overrideResponse = {}) => Array.from(
  { length: faker.number.int({ min: 1, max: 10 }) },
  (_, i) => i + 1
).map(() => ({
  amount: faker.word.sample(),
  availableYields: Array.from(
    { length: faker.number.int({ min: 1, max: 10 }) },
    (_, i) => i + 1
  ).map(() => faker.word.sample()),
  token: {
    address: faker.helpers.arrayElement([faker.word.sample(), void 0]),
    coinGeckoId: faker.helpers.arrayElement([faker.word.sample(), void 0]),
    decimals: faker.number.int({ min: void 0, max: void 0 }),
    isPoints: faker.helpers.arrayElement([
      faker.datatype.boolean(),
      void 0
    ]),
    logoURI: faker.helpers.arrayElement([faker.word.sample(), void 0]),
    name: faker.word.sample(),
    network: faker.helpers.arrayElement(Object.values(Networks)),
    symbol: faker.word.sample(),
    ...overrideResponse
  },
  ...overrideResponse
}));
var getYieldControllerYieldsResponseMock = (overrideResponse = {}) => ({
  data: {},
  hasNextPage: faker.datatype.boolean(),
  limit: faker.number.int({ min: void 0, max: void 0 }),
  page: faker.number.int({ min: void 0, max: void 0 }),
  ...overrideResponse,
  ...overrideResponse
});
var getYieldControllerGetMultipleYieldBalancesResponseMock = (overrideResponse = {}) => Array.from(
  { length: faker.number.int({ min: 1, max: 10 }) },
  (_, i) => i + 1
).map(() => ({
  balances: Array.from(
    { length: faker.number.int({ min: 1, max: 10 }) },
    (_, i) => i + 1
  ).map(() => ({
    amount: faker.word.sample(),
    date: faker.helpers.arrayElement([
      `${faker.date.past().toISOString().split(".")[0]}Z`,
      void 0
    ]),
    groupId: faker.string.uuid(),
    label: faker.helpers.arrayElement([
      { params: {}, type: faker.word.sample(), ...overrideResponse },
      void 0
    ]),
    pendingActions: Array.from(
      { length: faker.number.int({ min: 1, max: 10 }) },
      (_, i) => i + 1
    ).map(() => ({
      args: faker.helpers.arrayElement([
        {
          addresses: faker.helpers.arrayElement([
            {
              additionalAddresses: faker.helpers.arrayElement([
                Array.from(
                  { length: faker.number.int({ min: 1, max: 10 }) },
                  (_, i) => i + 1
                ).map(() => ({ ...overrideResponse })),
                void 0
              ]),
              address: faker.helpers.arrayElement([
                {
                  network: faker.helpers.arrayElement(
                    Object.values(Networks)
                  ),
                  required: faker.datatype.boolean(),
                  ...overrideResponse
                },
                void 0
              ]),
              ...overrideResponse
            },
            void 0
          ]),
          args: faker.helpers.arrayElement([
            {
              amount: faker.helpers.arrayElement([
                {
                  maximum: faker.helpers.arrayElement([
                    faker.number.int({ min: void 0, max: void 0 }),
                    void 0
                  ]),
                  minimum: faker.helpers.arrayElement([
                    faker.number.int({ min: void 0, max: void 0 }),
                    void 0
                  ]),
                  required: faker.datatype.boolean(),
                  ...overrideResponse
                },
                void 0
              ]),
              duration: faker.helpers.arrayElement([
                {
                  maximum: faker.helpers.arrayElement([
                    faker.number.int({ min: void 0, max: void 0 }),
                    void 0
                  ]),
                  minimum: faker.helpers.arrayElement([
                    faker.number.int({ min: void 0, max: void 0 }),
                    void 0
                  ]),
                  required: faker.datatype.boolean(),
                  ...overrideResponse
                },
                void 0
              ]),
              nfts: faker.helpers.arrayElement([
                Array.from(
                  { length: faker.number.int({ min: 1, max: 10 }) },
                  (_, i) => i + 1
                ).map(() => ({
                  bakcId: faker.helpers.arrayElement([
                    {
                      required: faker.datatype.boolean(),
                      ...overrideResponse
                    },
                    void 0
                  ]),
                  baycId: faker.helpers.arrayElement([
                    {
                      required: faker.datatype.boolean(),
                      ...overrideResponse
                    },
                    void 0
                  ]),
                  maycId: faker.helpers.arrayElement([
                    {
                      required: faker.datatype.boolean(),
                      ...overrideResponse
                    },
                    void 0
                  ]),
                  ...overrideResponse
                })),
                void 0
              ]),
              signatureVerification: faker.helpers.arrayElement([
                { required: faker.datatype.boolean(), ...overrideResponse },
                void 0
              ]),
              tronResource: faker.helpers.arrayElement([
                {
                  options: Array.from(
                    { length: faker.number.int({ min: 1, max: 10 }) },
                    (_, i) => i + 1
                  ).map(() => faker.word.sample()),
                  required: faker.datatype.boolean(),
                  ...overrideResponse
                },
                void 0
              ]),
              validatorAddress: faker.helpers.arrayElement([
                { required: faker.datatype.boolean(), ...overrideResponse },
                void 0
              ]),
              validatorAddresses: faker.helpers.arrayElement([
                { required: faker.datatype.boolean(), ...overrideResponse },
                void 0
              ]),
              ...overrideResponse
            },
            void 0
          ]),
          ...overrideResponse
        },
        void 0
      ]),
      passthrough: faker.word.sample(),
      type: faker.helpers.arrayElement(Object.values(ActionTypes)),
      ...overrideResponse
    })),
    pricePerShare: faker.word.sample(),
    providerId: faker.helpers.arrayElement([faker.word.sample(), void 0]),
    token: {
      address: faker.helpers.arrayElement([faker.word.sample(), void 0]),
      coinGeckoId: faker.helpers.arrayElement([
        faker.word.sample(),
        void 0
      ]),
      decimals: faker.number.int({ min: void 0, max: void 0 }),
      isPoints: faker.helpers.arrayElement([
        faker.datatype.boolean(),
        void 0
      ]),
      logoURI: faker.helpers.arrayElement([faker.word.sample(), void 0]),
      name: faker.word.sample(),
      network: faker.helpers.arrayElement(Object.values(Networks)),
      symbol: faker.word.sample(),
      ...overrideResponse
    },
    type: faker.helpers.arrayElement(Object.values(BalanceTypes)),
    validatorAddress: faker.helpers.arrayElement([
      faker.word.sample(),
      void 0
    ]),
    validatorAddresses: faker.helpers.arrayElement([
      Array.from(
        { length: faker.number.int({ min: 1, max: 10 }) },
        (_, i) => i + 1
      ).map(() => faker.word.sample()),
      void 0
    ]),
    ...overrideResponse
  })),
  integrationId: faker.word.sample(),
  ...overrideResponse
}));
var getYieldControllerYieldBalancesScanResponseMock = (overrideResponse = {}) => Array.from(
  { length: faker.number.int({ min: 1, max: 10 }) },
  (_, i) => i + 1
).map(() => ({
  balances: Array.from(
    { length: faker.number.int({ min: 1, max: 10 }) },
    (_, i) => i + 1
  ).map(() => ({
    amount: faker.word.sample(),
    date: faker.helpers.arrayElement([
      `${faker.date.past().toISOString().split(".")[0]}Z`,
      void 0
    ]),
    groupId: faker.string.uuid(),
    label: faker.helpers.arrayElement([
      { params: {}, type: faker.word.sample(), ...overrideResponse },
      void 0
    ]),
    pendingActions: Array.from(
      { length: faker.number.int({ min: 1, max: 10 }) },
      (_, i) => i + 1
    ).map(() => ({
      args: faker.helpers.arrayElement([
        {
          addresses: faker.helpers.arrayElement([
            {
              additionalAddresses: faker.helpers.arrayElement([
                Array.from(
                  { length: faker.number.int({ min: 1, max: 10 }) },
                  (_, i) => i + 1
                ).map(() => ({ ...overrideResponse })),
                void 0
              ]),
              address: faker.helpers.arrayElement([
                {
                  network: faker.helpers.arrayElement(
                    Object.values(Networks)
                  ),
                  required: faker.datatype.boolean(),
                  ...overrideResponse
                },
                void 0
              ]),
              ...overrideResponse
            },
            void 0
          ]),
          args: faker.helpers.arrayElement([
            {
              amount: faker.helpers.arrayElement([
                {
                  maximum: faker.helpers.arrayElement([
                    faker.number.int({ min: void 0, max: void 0 }),
                    void 0
                  ]),
                  minimum: faker.helpers.arrayElement([
                    faker.number.int({ min: void 0, max: void 0 }),
                    void 0
                  ]),
                  required: faker.datatype.boolean(),
                  ...overrideResponse
                },
                void 0
              ]),
              duration: faker.helpers.arrayElement([
                {
                  maximum: faker.helpers.arrayElement([
                    faker.number.int({ min: void 0, max: void 0 }),
                    void 0
                  ]),
                  minimum: faker.helpers.arrayElement([
                    faker.number.int({ min: void 0, max: void 0 }),
                    void 0
                  ]),
                  required: faker.datatype.boolean(),
                  ...overrideResponse
                },
                void 0
              ]),
              nfts: faker.helpers.arrayElement([
                Array.from(
                  { length: faker.number.int({ min: 1, max: 10 }) },
                  (_, i) => i + 1
                ).map(() => ({
                  bakcId: faker.helpers.arrayElement([
                    {
                      required: faker.datatype.boolean(),
                      ...overrideResponse
                    },
                    void 0
                  ]),
                  baycId: faker.helpers.arrayElement([
                    {
                      required: faker.datatype.boolean(),
                      ...overrideResponse
                    },
                    void 0
                  ]),
                  maycId: faker.helpers.arrayElement([
                    {
                      required: faker.datatype.boolean(),
                      ...overrideResponse
                    },
                    void 0
                  ]),
                  ...overrideResponse
                })),
                void 0
              ]),
              signatureVerification: faker.helpers.arrayElement([
                { required: faker.datatype.boolean(), ...overrideResponse },
                void 0
              ]),
              tronResource: faker.helpers.arrayElement([
                {
                  options: Array.from(
                    { length: faker.number.int({ min: 1, max: 10 }) },
                    (_, i) => i + 1
                  ).map(() => faker.word.sample()),
                  required: faker.datatype.boolean(),
                  ...overrideResponse
                },
                void 0
              ]),
              validatorAddress: faker.helpers.arrayElement([
                { required: faker.datatype.boolean(), ...overrideResponse },
                void 0
              ]),
              validatorAddresses: faker.helpers.arrayElement([
                { required: faker.datatype.boolean(), ...overrideResponse },
                void 0
              ]),
              ...overrideResponse
            },
            void 0
          ]),
          ...overrideResponse
        },
        void 0
      ]),
      passthrough: faker.word.sample(),
      type: faker.helpers.arrayElement(Object.values(ActionTypes)),
      ...overrideResponse
    })),
    pricePerShare: faker.word.sample(),
    providerId: faker.helpers.arrayElement([faker.word.sample(), void 0]),
    token: {
      address: faker.helpers.arrayElement([faker.word.sample(), void 0]),
      coinGeckoId: faker.helpers.arrayElement([
        faker.word.sample(),
        void 0
      ]),
      decimals: faker.number.int({ min: void 0, max: void 0 }),
      isPoints: faker.helpers.arrayElement([
        faker.datatype.boolean(),
        void 0
      ]),
      logoURI: faker.helpers.arrayElement([faker.word.sample(), void 0]),
      name: faker.word.sample(),
      network: faker.helpers.arrayElement(Object.values(Networks)),
      symbol: faker.word.sample(),
      ...overrideResponse
    },
    type: faker.helpers.arrayElement(Object.values(BalanceTypes)),
    validatorAddress: faker.helpers.arrayElement([
      faker.word.sample(),
      void 0
    ]),
    validatorAddresses: faker.helpers.arrayElement([
      Array.from(
        { length: faker.number.int({ min: 1, max: 10 }) },
        (_, i) => i + 1
      ).map(() => faker.word.sample()),
      void 0
    ]),
    ...overrideResponse
  })),
  integrationId: faker.word.sample(),
  ...overrideResponse
}));
var getYieldControllerYieldBalancesScanEvmResponseMock = (overrideResponse = {}) => Array.from(
  { length: faker.number.int({ min: 1, max: 10 }) },
  (_, i) => i + 1
).map(() => ({
  balances: Array.from(
    { length: faker.number.int({ min: 1, max: 10 }) },
    (_, i) => i + 1
  ).map(() => ({
    amount: faker.word.sample(),
    date: faker.helpers.arrayElement([
      `${faker.date.past().toISOString().split(".")[0]}Z`,
      void 0
    ]),
    groupId: faker.string.uuid(),
    label: faker.helpers.arrayElement([
      { params: {}, type: faker.word.sample(), ...overrideResponse },
      void 0
    ]),
    pendingActions: Array.from(
      { length: faker.number.int({ min: 1, max: 10 }) },
      (_, i) => i + 1
    ).map(() => ({
      args: faker.helpers.arrayElement([
        {
          addresses: faker.helpers.arrayElement([
            {
              additionalAddresses: faker.helpers.arrayElement([
                Array.from(
                  { length: faker.number.int({ min: 1, max: 10 }) },
                  (_, i) => i + 1
                ).map(() => ({ ...overrideResponse })),
                void 0
              ]),
              address: faker.helpers.arrayElement([
                {
                  network: faker.helpers.arrayElement(
                    Object.values(Networks)
                  ),
                  required: faker.datatype.boolean(),
                  ...overrideResponse
                },
                void 0
              ]),
              ...overrideResponse
            },
            void 0
          ]),
          args: faker.helpers.arrayElement([
            {
              amount: faker.helpers.arrayElement([
                {
                  maximum: faker.helpers.arrayElement([
                    faker.number.int({ min: void 0, max: void 0 }),
                    void 0
                  ]),
                  minimum: faker.helpers.arrayElement([
                    faker.number.int({ min: void 0, max: void 0 }),
                    void 0
                  ]),
                  required: faker.datatype.boolean(),
                  ...overrideResponse
                },
                void 0
              ]),
              duration: faker.helpers.arrayElement([
                {
                  maximum: faker.helpers.arrayElement([
                    faker.number.int({ min: void 0, max: void 0 }),
                    void 0
                  ]),
                  minimum: faker.helpers.arrayElement([
                    faker.number.int({ min: void 0, max: void 0 }),
                    void 0
                  ]),
                  required: faker.datatype.boolean(),
                  ...overrideResponse
                },
                void 0
              ]),
              nfts: faker.helpers.arrayElement([
                Array.from(
                  { length: faker.number.int({ min: 1, max: 10 }) },
                  (_, i) => i + 1
                ).map(() => ({
                  bakcId: faker.helpers.arrayElement([
                    {
                      required: faker.datatype.boolean(),
                      ...overrideResponse
                    },
                    void 0
                  ]),
                  baycId: faker.helpers.arrayElement([
                    {
                      required: faker.datatype.boolean(),
                      ...overrideResponse
                    },
                    void 0
                  ]),
                  maycId: faker.helpers.arrayElement([
                    {
                      required: faker.datatype.boolean(),
                      ...overrideResponse
                    },
                    void 0
                  ]),
                  ...overrideResponse
                })),
                void 0
              ]),
              signatureVerification: faker.helpers.arrayElement([
                { required: faker.datatype.boolean(), ...overrideResponse },
                void 0
              ]),
              tronResource: faker.helpers.arrayElement([
                {
                  options: Array.from(
                    { length: faker.number.int({ min: 1, max: 10 }) },
                    (_, i) => i + 1
                  ).map(() => faker.word.sample()),
                  required: faker.datatype.boolean(),
                  ...overrideResponse
                },
                void 0
              ]),
              validatorAddress: faker.helpers.arrayElement([
                { required: faker.datatype.boolean(), ...overrideResponse },
                void 0
              ]),
              validatorAddresses: faker.helpers.arrayElement([
                { required: faker.datatype.boolean(), ...overrideResponse },
                void 0
              ]),
              ...overrideResponse
            },
            void 0
          ]),
          ...overrideResponse
        },
        void 0
      ]),
      passthrough: faker.word.sample(),
      type: faker.helpers.arrayElement(Object.values(ActionTypes)),
      ...overrideResponse
    })),
    pricePerShare: faker.word.sample(),
    providerId: faker.helpers.arrayElement([faker.word.sample(), void 0]),
    token: {
      address: faker.helpers.arrayElement([faker.word.sample(), void 0]),
      coinGeckoId: faker.helpers.arrayElement([
        faker.word.sample(),
        void 0
      ]),
      decimals: faker.number.int({ min: void 0, max: void 0 }),
      isPoints: faker.helpers.arrayElement([
        faker.datatype.boolean(),
        void 0
      ]),
      logoURI: faker.helpers.arrayElement([faker.word.sample(), void 0]),
      name: faker.word.sample(),
      network: faker.helpers.arrayElement(Object.values(Networks)),
      symbol: faker.word.sample(),
      ...overrideResponse
    },
    type: faker.helpers.arrayElement(Object.values(BalanceTypes)),
    validatorAddress: faker.helpers.arrayElement([
      faker.word.sample(),
      void 0
    ]),
    validatorAddresses: faker.helpers.arrayElement([
      Array.from(
        { length: faker.number.int({ min: 1, max: 10 }) },
        (_, i) => i + 1
      ).map(() => faker.word.sample()),
      void 0
    ]),
    ...overrideResponse
  })),
  integrationId: faker.word.sample(),
  ...overrideResponse
}));
var getYieldControllerGetMyYieldsResponseMock = (overrideResponse = {}) => ({
  data: {},
  hasNextPage: faker.datatype.boolean(),
  limit: faker.number.int({ min: void 0, max: void 0 }),
  page: faker.number.int({ min: void 0, max: void 0 }),
  ...overrideResponse,
  ...overrideResponse
});
var getYieldControllerFindValidatorsResponseMock = (overrideResponse = {}) => Array.from(
  { length: faker.number.int({ min: 1, max: 10 }) },
  (_, i) => i + 1
).map(() => ({
  integrationId: faker.word.sample(),
  validators: Array.from(
    { length: faker.number.int({ min: 1, max: 10 }) },
    (_, i) => i + 1
  ).map(() => ({
    address: faker.word.sample(),
    apr: faker.helpers.arrayElement([
      faker.number.int({ min: void 0, max: void 0 }),
      void 0
    ]),
    commission: faker.helpers.arrayElement([
      faker.number.int({ min: void 0, max: void 0 }),
      void 0
    ]),
    endDate: faker.helpers.arrayElement([
      `${faker.date.past().toISOString().split(".")[0]}Z`,
      void 0
    ]),
    image: faker.helpers.arrayElement([faker.word.sample(), void 0]),
    minimumStake: faker.helpers.arrayElement([
      faker.word.sample(),
      void 0
    ]),
    name: faker.helpers.arrayElement([faker.word.sample(), void 0]),
    preferred: faker.helpers.arrayElement([
      faker.datatype.boolean(),
      void 0
    ]),
    providerId: faker.helpers.arrayElement([faker.word.sample(), void 0]),
    remainingPossibleStake: faker.helpers.arrayElement([
      faker.word.sample(),
      void 0
    ]),
    remainingSlots: faker.helpers.arrayElement([
      faker.number.int({ min: void 0, max: void 0 }),
      void 0
    ]),
    stakedBalance: faker.helpers.arrayElement([
      faker.word.sample(),
      void 0
    ]),
    status: faker.helpers.arrayElement(Object.values(ValidatorStatusTypes)),
    votingPower: faker.helpers.arrayElement([
      faker.number.int({ min: void 0, max: void 0 }),
      void 0
    ]),
    website: faker.helpers.arrayElement([faker.word.sample(), void 0]),
    ...overrideResponse
  })),
  ...overrideResponse
}));
var getYieldControllerYieldOpportunityResponseMock = (overrideResponse = {}) => ({
  apy: faker.number.int({ min: void 0, max: void 0 }),
  args: {
    enter: {
      addresses: faker.helpers.arrayElement([
        {
          additionalAddresses: faker.helpers.arrayElement([
            Array.from(
              { length: faker.number.int({ min: 1, max: 10 }) },
              (_, i) => i + 1
            ).map(() => ({ ...overrideResponse })),
            void 0
          ]),
          address: faker.helpers.arrayElement([
            {
              network: faker.helpers.arrayElement(Object.values(Networks)),
              required: faker.datatype.boolean(),
              ...overrideResponse
            },
            void 0
          ]),
          ...overrideResponse
        },
        void 0
      ]),
      args: faker.helpers.arrayElement([
        {
          amount: faker.helpers.arrayElement([
            {
              maximum: faker.helpers.arrayElement([
                faker.number.int({ min: void 0, max: void 0 }),
                void 0
              ]),
              minimum: faker.helpers.arrayElement([
                faker.number.int({ min: void 0, max: void 0 }),
                void 0
              ]),
              required: faker.datatype.boolean(),
              ...overrideResponse
            },
            void 0
          ]),
          duration: faker.helpers.arrayElement([
            {
              maximum: faker.helpers.arrayElement([
                faker.number.int({ min: void 0, max: void 0 }),
                void 0
              ]),
              minimum: faker.helpers.arrayElement([
                faker.number.int({ min: void 0, max: void 0 }),
                void 0
              ]),
              required: faker.datatype.boolean(),
              ...overrideResponse
            },
            void 0
          ]),
          nfts: faker.helpers.arrayElement([
            Array.from(
              { length: faker.number.int({ min: 1, max: 10 }) },
              (_, i) => i + 1
            ).map(() => ({
              bakcId: faker.helpers.arrayElement([
                { required: faker.datatype.boolean(), ...overrideResponse },
                void 0
              ]),
              baycId: faker.helpers.arrayElement([
                { required: faker.datatype.boolean(), ...overrideResponse },
                void 0
              ]),
              maycId: faker.helpers.arrayElement([
                { required: faker.datatype.boolean(), ...overrideResponse },
                void 0
              ]),
              ...overrideResponse
            })),
            void 0
          ]),
          signatureVerification: faker.helpers.arrayElement([
            { required: faker.datatype.boolean(), ...overrideResponse },
            void 0
          ]),
          tronResource: faker.helpers.arrayElement([
            {
              options: Array.from(
                { length: faker.number.int({ min: 1, max: 10 }) },
                (_, i) => i + 1
              ).map(() => faker.word.sample()),
              required: faker.datatype.boolean(),
              ...overrideResponse
            },
            void 0
          ]),
          validatorAddress: faker.helpers.arrayElement([
            { required: faker.datatype.boolean(), ...overrideResponse },
            void 0
          ]),
          validatorAddresses: faker.helpers.arrayElement([
            { required: faker.datatype.boolean(), ...overrideResponse },
            void 0
          ]),
          ...overrideResponse
        },
        void 0
      ]),
      ...overrideResponse
    },
    exit: faker.helpers.arrayElement([
      {
        addresses: faker.helpers.arrayElement([
          {
            additionalAddresses: faker.helpers.arrayElement([
              Array.from(
                { length: faker.number.int({ min: 1, max: 10 }) },
                (_, i) => i + 1
              ).map(() => ({ ...overrideResponse })),
              void 0
            ]),
            address: faker.helpers.arrayElement([
              {
                network: faker.helpers.arrayElement(Object.values(Networks)),
                required: faker.datatype.boolean(),
                ...overrideResponse
              },
              void 0
            ]),
            ...overrideResponse
          },
          void 0
        ]),
        args: faker.helpers.arrayElement([
          {
            amount: faker.helpers.arrayElement([
              {
                maximum: faker.helpers.arrayElement([
                  faker.number.int({ min: void 0, max: void 0 }),
                  void 0
                ]),
                minimum: faker.helpers.arrayElement([
                  faker.number.int({ min: void 0, max: void 0 }),
                  void 0
                ]),
                required: faker.datatype.boolean(),
                ...overrideResponse
              },
              void 0
            ]),
            duration: faker.helpers.arrayElement([
              {
                maximum: faker.helpers.arrayElement([
                  faker.number.int({ min: void 0, max: void 0 }),
                  void 0
                ]),
                minimum: faker.helpers.arrayElement([
                  faker.number.int({ min: void 0, max: void 0 }),
                  void 0
                ]),
                required: faker.datatype.boolean(),
                ...overrideResponse
              },
              void 0
            ]),
            nfts: faker.helpers.arrayElement([
              Array.from(
                { length: faker.number.int({ min: 1, max: 10 }) },
                (_, i) => i + 1
              ).map(() => ({
                bakcId: faker.helpers.arrayElement([
                  { required: faker.datatype.boolean(), ...overrideResponse },
                  void 0
                ]),
                baycId: faker.helpers.arrayElement([
                  { required: faker.datatype.boolean(), ...overrideResponse },
                  void 0
                ]),
                maycId: faker.helpers.arrayElement([
                  { required: faker.datatype.boolean(), ...overrideResponse },
                  void 0
                ]),
                ...overrideResponse
              })),
              void 0
            ]),
            signatureVerification: faker.helpers.arrayElement([
              { required: faker.datatype.boolean(), ...overrideResponse },
              void 0
            ]),
            tronResource: faker.helpers.arrayElement([
              {
                options: Array.from(
                  { length: faker.number.int({ min: 1, max: 10 }) },
                  (_, i) => i + 1
                ).map(() => faker.word.sample()),
                required: faker.datatype.boolean(),
                ...overrideResponse
              },
              void 0
            ]),
            validatorAddress: faker.helpers.arrayElement([
              { required: faker.datatype.boolean(), ...overrideResponse },
              void 0
            ]),
            validatorAddresses: faker.helpers.arrayElement([
              { required: faker.datatype.boolean(), ...overrideResponse },
              void 0
            ]),
            ...overrideResponse
          },
          void 0
        ]),
        ...overrideResponse
      },
      void 0
    ]),
    ...overrideResponse
  },
  id: faker.word.sample(),
  isAvailable: faker.datatype.boolean(),
  metadata: {
    cooldownPeriod: faker.helpers.arrayElement([
      {
        days: faker.number.int({ min: void 0, max: void 0 }),
        ...overrideResponse
      },
      void 0
    ]),
    defaultValidator: faker.helpers.arrayElement([
      faker.word.sample(),
      void 0
    ]),
    description: faker.word.sample(),
    documentation: faker.word.sample(),
    fee: {
      depositFee: faker.datatype.boolean(),
      enabled: faker.datatype.boolean(),
      managementFee: faker.datatype.boolean(),
      performanceFee: faker.datatype.boolean(),
      ...overrideResponse
    },
    gasFeeToken: {
      address: faker.helpers.arrayElement([faker.word.sample(), void 0]),
      coinGeckoId: faker.helpers.arrayElement([faker.word.sample(), void 0]),
      decimals: faker.number.int({ min: void 0, max: void 0 }),
      isPoints: faker.helpers.arrayElement([
        faker.datatype.boolean(),
        void 0
      ]),
      logoURI: faker.helpers.arrayElement([faker.word.sample(), void 0]),
      name: faker.word.sample(),
      network: faker.helpers.arrayElement(Object.values(Networks)),
      symbol: faker.word.sample(),
      ...overrideResponse
    },
    isIntegrationAggregator: faker.helpers.arrayElement([
      faker.datatype.boolean(),
      void 0
    ]),
    logoURI: faker.word.sample(),
    minimumStake: faker.helpers.arrayElement([
      faker.number.int({ min: void 0, max: void 0 }),
      void 0
    ]),
    name: faker.word.sample(),
    provider: faker.helpers.arrayElement([
      {
        description: faker.word.sample(),
        externalLink: faker.word.sample(),
        id: faker.helpers.arrayElement(Object.values(YieldProviders)),
        logoURI: faker.word.sample(),
        name: faker.word.sample(),
        ...overrideResponse
      },
      void 0
    ]),
    revshare: { enabled: faker.datatype.boolean(), ...overrideResponse },
    rewardClaiming: faker.helpers.arrayElement(Object.values(RewardClaiming)),
    rewardSchedule: faker.helpers.arrayElement(Object.values(RewardSchedule)),
    rewardTokens: faker.helpers.arrayElement([
      Array.from(
        { length: faker.number.int({ min: 1, max: 10 }) },
        (_, i) => i + 1
      ).map(() => ({
        address: faker.helpers.arrayElement([faker.word.sample(), void 0]),
        coinGeckoId: faker.helpers.arrayElement([
          faker.word.sample(),
          void 0
        ]),
        decimals: faker.number.int({ min: void 0, max: void 0 }),
        isPoints: faker.helpers.arrayElement([
          faker.datatype.boolean(),
          void 0
        ]),
        logoURI: faker.helpers.arrayElement([faker.word.sample(), void 0]),
        name: faker.word.sample(),
        network: faker.helpers.arrayElement(Object.values(Networks)),
        symbol: faker.word.sample(),
        ...overrideResponse
      })),
      void 0
    ]),
    supportsLedgerWalletApi: faker.helpers.arrayElement([
      faker.datatype.boolean(),
      void 0
    ]),
    supportsMultipleValidators: faker.helpers.arrayElement([
      faker.datatype.boolean(),
      void 0
    ]),
    token: {
      address: faker.helpers.arrayElement([faker.word.sample(), void 0]),
      coinGeckoId: faker.helpers.arrayElement([faker.word.sample(), void 0]),
      decimals: faker.number.int({ min: void 0, max: void 0 }),
      isPoints: faker.helpers.arrayElement([
        faker.datatype.boolean(),
        void 0
      ]),
      logoURI: faker.helpers.arrayElement([faker.word.sample(), void 0]),
      name: faker.word.sample(),
      network: faker.helpers.arrayElement(Object.values(Networks)),
      symbol: faker.word.sample(),
      ...overrideResponse
    },
    tokens: faker.helpers.arrayElement([
      Array.from(
        { length: faker.number.int({ min: 1, max: 10 }) },
        (_, i) => i + 1
      ).map(() => ({
        address: faker.helpers.arrayElement([faker.word.sample(), void 0]),
        coinGeckoId: faker.helpers.arrayElement([
          faker.word.sample(),
          void 0
        ]),
        decimals: faker.number.int({ min: void 0, max: void 0 }),
        isPoints: faker.helpers.arrayElement([
          faker.datatype.boolean(),
          void 0
        ]),
        logoURI: faker.helpers.arrayElement([faker.word.sample(), void 0]),
        name: faker.word.sample(),
        network: faker.helpers.arrayElement(Object.values(Networks)),
        symbol: faker.word.sample(),
        ...overrideResponse
      })),
      void 0
    ]),
    type: faker.helpers.arrayElement(Object.values(YieldType)),
    warmupPeriod: {
      days: faker.number.int({ min: void 0, max: void 0 }),
      ...overrideResponse
    },
    withdrawPeriod: faker.helpers.arrayElement([
      {
        days: faker.number.int({ min: void 0, max: void 0 }),
        ...overrideResponse
      },
      void 0
    ]),
    ...overrideResponse
  },
  rewardRate: faker.number.int({ min: void 0, max: void 0 }),
  rewardType: faker.helpers.arrayElement(Object.values(RewardTypes)),
  status: {
    enter: faker.datatype.boolean(),
    exit: faker.datatype.boolean(),
    ...overrideResponse
  },
  token: {
    address: faker.helpers.arrayElement([faker.word.sample(), void 0]),
    coinGeckoId: faker.helpers.arrayElement([faker.word.sample(), void 0]),
    decimals: faker.number.int({ min: void 0, max: void 0 }),
    isPoints: faker.helpers.arrayElement([faker.datatype.boolean(), void 0]),
    logoURI: faker.helpers.arrayElement([faker.word.sample(), void 0]),
    name: faker.word.sample(),
    network: faker.helpers.arrayElement(Object.values(Networks)),
    symbol: faker.word.sample(),
    ...overrideResponse
  },
  tokens: Array.from(
    { length: faker.number.int({ min: 1, max: 10 }) },
    (_, i) => i + 1
  ).map(() => ({
    address: faker.helpers.arrayElement([faker.word.sample(), void 0]),
    coinGeckoId: faker.helpers.arrayElement([faker.word.sample(), void 0]),
    decimals: faker.number.int({ min: void 0, max: void 0 }),
    isPoints: faker.helpers.arrayElement([faker.datatype.boolean(), void 0]),
    logoURI: faker.helpers.arrayElement([faker.word.sample(), void 0]),
    name: faker.word.sample(),
    network: faker.helpers.arrayElement(Object.values(Networks)),
    symbol: faker.word.sample(),
    ...overrideResponse
  })),
  validators: Array.from(
    { length: faker.number.int({ min: 1, max: 10 }) },
    (_, i) => i + 1
  ).map(() => ({
    address: faker.word.sample(),
    apr: faker.helpers.arrayElement([
      faker.number.int({ min: void 0, max: void 0 }),
      void 0
    ]),
    commission: faker.helpers.arrayElement([
      faker.number.int({ min: void 0, max: void 0 }),
      void 0
    ]),
    endDate: faker.helpers.arrayElement([
      `${faker.date.past().toISOString().split(".")[0]}Z`,
      void 0
    ]),
    image: faker.helpers.arrayElement([faker.word.sample(), void 0]),
    minimumStake: faker.helpers.arrayElement([faker.word.sample(), void 0]),
    name: faker.helpers.arrayElement([faker.word.sample(), void 0]),
    preferred: faker.helpers.arrayElement([
      faker.datatype.boolean(),
      void 0
    ]),
    providerId: faker.helpers.arrayElement([faker.word.sample(), void 0]),
    remainingPossibleStake: faker.helpers.arrayElement([
      faker.word.sample(),
      void 0
    ]),
    remainingSlots: faker.helpers.arrayElement([
      faker.number.int({ min: void 0, max: void 0 }),
      void 0
    ]),
    stakedBalance: faker.helpers.arrayElement([faker.word.sample(), void 0]),
    status: faker.helpers.arrayElement(Object.values(ValidatorStatusTypes)),
    votingPower: faker.helpers.arrayElement([
      faker.number.int({ min: void 0, max: void 0 }),
      void 0
    ]),
    website: faker.helpers.arrayElement([faker.word.sample(), void 0]),
    ...overrideResponse
  })),
  ...overrideResponse
});
var getYieldControllerGetValidatorsResponseMock = (overrideResponse = {}) => Array.from(
  { length: faker.number.int({ min: 1, max: 10 }) },
  (_, i) => i + 1
).map(() => ({
  address: faker.word.sample(),
  apr: faker.helpers.arrayElement([
    faker.number.int({ min: void 0, max: void 0 }),
    void 0
  ]),
  commission: faker.helpers.arrayElement([
    faker.number.int({ min: void 0, max: void 0 }),
    void 0
  ]),
  endDate: faker.helpers.arrayElement([
    `${faker.date.past().toISOString().split(".")[0]}Z`,
    void 0
  ]),
  image: faker.helpers.arrayElement([faker.word.sample(), void 0]),
  minimumStake: faker.helpers.arrayElement([faker.word.sample(), void 0]),
  name: faker.helpers.arrayElement([faker.word.sample(), void 0]),
  preferred: faker.helpers.arrayElement([
    faker.datatype.boolean(),
    void 0
  ]),
  providerId: faker.helpers.arrayElement([faker.word.sample(), void 0]),
  remainingPossibleStake: faker.helpers.arrayElement([
    faker.word.sample(),
    void 0
  ]),
  remainingSlots: faker.helpers.arrayElement([
    faker.number.int({ min: void 0, max: void 0 }),
    void 0
  ]),
  stakedBalance: faker.helpers.arrayElement([faker.word.sample(), void 0]),
  status: faker.helpers.arrayElement(Object.values(ValidatorStatusTypes)),
  votingPower: faker.helpers.arrayElement([
    faker.number.int({ min: void 0, max: void 0 }),
    void 0
  ]),
  website: faker.helpers.arrayElement([faker.word.sample(), void 0]),
  ...overrideResponse
}));
var getYieldControllerGetSingleYieldBalancesResponseMock = (overrideResponse = {}) => Array.from(
  { length: faker.number.int({ min: 1, max: 10 }) },
  (_, i) => i + 1
).map(() => ({
  amount: faker.word.sample(),
  date: faker.helpers.arrayElement([
    `${faker.date.past().toISOString().split(".")[0]}Z`,
    void 0
  ]),
  groupId: faker.string.uuid(),
  label: faker.helpers.arrayElement([
    { params: {}, type: faker.word.sample(), ...overrideResponse },
    void 0
  ]),
  pendingActions: Array.from(
    { length: faker.number.int({ min: 1, max: 10 }) },
    (_, i) => i + 1
  ).map(() => ({
    args: faker.helpers.arrayElement([
      {
        addresses: faker.helpers.arrayElement([
          {
            additionalAddresses: faker.helpers.arrayElement([
              Array.from(
                { length: faker.number.int({ min: 1, max: 10 }) },
                (_, i) => i + 1
              ).map(() => ({ ...overrideResponse })),
              void 0
            ]),
            address: faker.helpers.arrayElement([
              {
                network: faker.helpers.arrayElement(Object.values(Networks)),
                required: faker.datatype.boolean(),
                ...overrideResponse
              },
              void 0
            ]),
            ...overrideResponse
          },
          void 0
        ]),
        args: faker.helpers.arrayElement([
          {
            amount: faker.helpers.arrayElement([
              {
                maximum: faker.helpers.arrayElement([
                  faker.number.int({ min: void 0, max: void 0 }),
                  void 0
                ]),
                minimum: faker.helpers.arrayElement([
                  faker.number.int({ min: void 0, max: void 0 }),
                  void 0
                ]),
                required: faker.datatype.boolean(),
                ...overrideResponse
              },
              void 0
            ]),
            duration: faker.helpers.arrayElement([
              {
                maximum: faker.helpers.arrayElement([
                  faker.number.int({ min: void 0, max: void 0 }),
                  void 0
                ]),
                minimum: faker.helpers.arrayElement([
                  faker.number.int({ min: void 0, max: void 0 }),
                  void 0
                ]),
                required: faker.datatype.boolean(),
                ...overrideResponse
              },
              void 0
            ]),
            nfts: faker.helpers.arrayElement([
              Array.from(
                { length: faker.number.int({ min: 1, max: 10 }) },
                (_, i) => i + 1
              ).map(() => ({
                bakcId: faker.helpers.arrayElement([
                  { required: faker.datatype.boolean(), ...overrideResponse },
                  void 0
                ]),
                baycId: faker.helpers.arrayElement([
                  { required: faker.datatype.boolean(), ...overrideResponse },
                  void 0
                ]),
                maycId: faker.helpers.arrayElement([
                  { required: faker.datatype.boolean(), ...overrideResponse },
                  void 0
                ]),
                ...overrideResponse
              })),
              void 0
            ]),
            signatureVerification: faker.helpers.arrayElement([
              { required: faker.datatype.boolean(), ...overrideResponse },
              void 0
            ]),
            tronResource: faker.helpers.arrayElement([
              {
                options: Array.from(
                  { length: faker.number.int({ min: 1, max: 10 }) },
                  (_, i) => i + 1
                ).map(() => faker.word.sample()),
                required: faker.datatype.boolean(),
                ...overrideResponse
              },
              void 0
            ]),
            validatorAddress: faker.helpers.arrayElement([
              { required: faker.datatype.boolean(), ...overrideResponse },
              void 0
            ]),
            validatorAddresses: faker.helpers.arrayElement([
              { required: faker.datatype.boolean(), ...overrideResponse },
              void 0
            ]),
            ...overrideResponse
          },
          void 0
        ]),
        ...overrideResponse
      },
      void 0
    ]),
    passthrough: faker.word.sample(),
    type: faker.helpers.arrayElement(Object.values(ActionTypes)),
    ...overrideResponse
  })),
  pricePerShare: faker.word.sample(),
  providerId: faker.helpers.arrayElement([faker.word.sample(), void 0]),
  token: {
    address: faker.helpers.arrayElement([faker.word.sample(), void 0]),
    coinGeckoId: faker.helpers.arrayElement([faker.word.sample(), void 0]),
    decimals: faker.number.int({ min: void 0, max: void 0 }),
    isPoints: faker.helpers.arrayElement([
      faker.datatype.boolean(),
      void 0
    ]),
    logoURI: faker.helpers.arrayElement([faker.word.sample(), void 0]),
    name: faker.word.sample(),
    network: faker.helpers.arrayElement(Object.values(Networks)),
    symbol: faker.word.sample(),
    ...overrideResponse
  },
  type: faker.helpers.arrayElement(Object.values(BalanceTypes)),
  validatorAddress: faker.helpers.arrayElement([
    faker.word.sample(),
    void 0
  ]),
  validatorAddresses: faker.helpers.arrayElement([
    Array.from(
      { length: faker.number.int({ min: 1, max: 10 }) },
      (_, i) => i + 1
    ).map(() => faker.word.sample()),
    void 0
  ]),
  ...overrideResponse
}));
var getYieldControllerGetSingleYieldRewardsSummaryResponseMock = (overrideResponse = {}) => Array.from(
  { length: faker.number.int({ min: 1, max: 10 }) },
  (_, i) => i + 1
).map(() => ({
  rewards: {
    last24H: faker.word.sample(),
    last30D: faker.word.sample(),
    last7D: faker.word.sample(),
    lastYear: faker.word.sample(),
    total: faker.word.sample(),
    ...overrideResponse
  },
  token: {
    address: faker.helpers.arrayElement([faker.word.sample(), void 0]),
    coinGeckoId: faker.helpers.arrayElement([faker.word.sample(), void 0]),
    decimals: faker.number.int({ min: void 0, max: void 0 }),
    isPoints: faker.helpers.arrayElement([
      faker.datatype.boolean(),
      void 0
    ]),
    logoURI: faker.helpers.arrayElement([faker.word.sample(), void 0]),
    name: faker.word.sample(),
    network: faker.helpers.arrayElement(Object.values(Networks)),
    symbol: faker.word.sample(),
    ...overrideResponse
  },
  ...overrideResponse
}));
var getYieldControllerGetFeeConfigurationResponseMock = (overrideResponse = {}) => ({
  allocatorVaultContractAddress: faker.helpers.arrayElement([
    faker.word.sample(),
    null
  ]),
  depositFeeBps: faker.helpers.arrayElement([
    faker.number.int({ min: 1, max: 1e4 }),
    null
  ]),
  feeWrapperContractAddress: faker.helpers.arrayElement([
    faker.word.sample(),
    null
  ]),
  id: faker.word.sample(),
  integrationId: faker.word.sample(),
  managementFeeBps: faker.helpers.arrayElement([
    faker.number.int({ min: 1, max: 1e4 }),
    null
  ]),
  performanceFeeBps: faker.helpers.arrayElement([
    faker.number.int({ min: 1, max: 1e4 }),
    null
  ]),
  projectId: faker.word.sample(),
  status: faker.helpers.arrayElement(Object.values(FeeConfigurationStatus)),
  ...overrideResponse
});
var getYieldV2ControllerYieldsResponseMock = (overrideResponse = {}) => ({
  data: {},
  hasNextPage: faker.datatype.boolean(),
  limit: faker.number.int({ min: void 0, max: void 0 }),
  page: faker.number.int({ min: void 0, max: void 0 }),
  ...overrideResponse,
  ...overrideResponse
});
var getYieldV2ControllerGetYieldByIdResponseMock = (overrideResponse = {}) => ({
  apy: faker.number.int({ min: void 0, max: void 0 }),
  args: {
    enter: {
      addresses: faker.helpers.arrayElement([
        {
          additionalAddresses: faker.helpers.arrayElement([
            Array.from(
              { length: faker.number.int({ min: 1, max: 10 }) },
              (_, i) => i + 1
            ).map(() => ({ ...overrideResponse })),
            void 0
          ]),
          address: faker.helpers.arrayElement([
            {
              network: faker.helpers.arrayElement(Object.values(Networks)),
              required: faker.datatype.boolean(),
              ...overrideResponse
            },
            void 0
          ]),
          ...overrideResponse
        },
        void 0
      ]),
      args: faker.helpers.arrayElement([
        {
          amount: faker.helpers.arrayElement([
            {
              maximum: faker.helpers.arrayElement([
                faker.number.int({ min: void 0, max: void 0 }),
                void 0
              ]),
              minimum: faker.helpers.arrayElement([
                faker.number.int({ min: void 0, max: void 0 }),
                void 0
              ]),
              required: faker.datatype.boolean(),
              ...overrideResponse
            },
            void 0
          ]),
          duration: faker.helpers.arrayElement([
            {
              maximum: faker.helpers.arrayElement([
                faker.number.int({ min: void 0, max: void 0 }),
                void 0
              ]),
              minimum: faker.helpers.arrayElement([
                faker.number.int({ min: void 0, max: void 0 }),
                void 0
              ]),
              required: faker.datatype.boolean(),
              ...overrideResponse
            },
            void 0
          ]),
          nfts: faker.helpers.arrayElement([
            Array.from(
              { length: faker.number.int({ min: 1, max: 10 }) },
              (_, i) => i + 1
            ).map(() => ({
              bakcId: faker.helpers.arrayElement([
                { required: faker.datatype.boolean(), ...overrideResponse },
                void 0
              ]),
              baycId: faker.helpers.arrayElement([
                { required: faker.datatype.boolean(), ...overrideResponse },
                void 0
              ]),
              maycId: faker.helpers.arrayElement([
                { required: faker.datatype.boolean(), ...overrideResponse },
                void 0
              ]),
              ...overrideResponse
            })),
            void 0
          ]),
          signatureVerification: faker.helpers.arrayElement([
            { required: faker.datatype.boolean(), ...overrideResponse },
            void 0
          ]),
          tronResource: faker.helpers.arrayElement([
            {
              options: Array.from(
                { length: faker.number.int({ min: 1, max: 10 }) },
                (_, i) => i + 1
              ).map(() => faker.word.sample()),
              required: faker.datatype.boolean(),
              ...overrideResponse
            },
            void 0
          ]),
          validatorAddress: faker.helpers.arrayElement([
            { required: faker.datatype.boolean(), ...overrideResponse },
            void 0
          ]),
          validatorAddresses: faker.helpers.arrayElement([
            { required: faker.datatype.boolean(), ...overrideResponse },
            void 0
          ]),
          ...overrideResponse
        },
        void 0
      ]),
      ...overrideResponse
    },
    exit: faker.helpers.arrayElement([
      {
        addresses: faker.helpers.arrayElement([
          {
            additionalAddresses: faker.helpers.arrayElement([
              Array.from(
                { length: faker.number.int({ min: 1, max: 10 }) },
                (_, i) => i + 1
              ).map(() => ({ ...overrideResponse })),
              void 0
            ]),
            address: faker.helpers.arrayElement([
              {
                network: faker.helpers.arrayElement(Object.values(Networks)),
                required: faker.datatype.boolean(),
                ...overrideResponse
              },
              void 0
            ]),
            ...overrideResponse
          },
          void 0
        ]),
        args: faker.helpers.arrayElement([
          {
            amount: faker.helpers.arrayElement([
              {
                maximum: faker.helpers.arrayElement([
                  faker.number.int({ min: void 0, max: void 0 }),
                  void 0
                ]),
                minimum: faker.helpers.arrayElement([
                  faker.number.int({ min: void 0, max: void 0 }),
                  void 0
                ]),
                required: faker.datatype.boolean(),
                ...overrideResponse
              },
              void 0
            ]),
            duration: faker.helpers.arrayElement([
              {
                maximum: faker.helpers.arrayElement([
                  faker.number.int({ min: void 0, max: void 0 }),
                  void 0
                ]),
                minimum: faker.helpers.arrayElement([
                  faker.number.int({ min: void 0, max: void 0 }),
                  void 0
                ]),
                required: faker.datatype.boolean(),
                ...overrideResponse
              },
              void 0
            ]),
            nfts: faker.helpers.arrayElement([
              Array.from(
                { length: faker.number.int({ min: 1, max: 10 }) },
                (_, i) => i + 1
              ).map(() => ({
                bakcId: faker.helpers.arrayElement([
                  { required: faker.datatype.boolean(), ...overrideResponse },
                  void 0
                ]),
                baycId: faker.helpers.arrayElement([
                  { required: faker.datatype.boolean(), ...overrideResponse },
                  void 0
                ]),
                maycId: faker.helpers.arrayElement([
                  { required: faker.datatype.boolean(), ...overrideResponse },
                  void 0
                ]),
                ...overrideResponse
              })),
              void 0
            ]),
            signatureVerification: faker.helpers.arrayElement([
              { required: faker.datatype.boolean(), ...overrideResponse },
              void 0
            ]),
            tronResource: faker.helpers.arrayElement([
              {
                options: Array.from(
                  { length: faker.number.int({ min: 1, max: 10 }) },
                  (_, i) => i + 1
                ).map(() => faker.word.sample()),
                required: faker.datatype.boolean(),
                ...overrideResponse
              },
              void 0
            ]),
            validatorAddress: faker.helpers.arrayElement([
              { required: faker.datatype.boolean(), ...overrideResponse },
              void 0
            ]),
            validatorAddresses: faker.helpers.arrayElement([
              { required: faker.datatype.boolean(), ...overrideResponse },
              void 0
            ]),
            ...overrideResponse
          },
          void 0
        ]),
        ...overrideResponse
      },
      void 0
    ]),
    ...overrideResponse
  },
  id: faker.word.sample(),
  isAvailable: faker.datatype.boolean(),
  metadata: {
    cooldownPeriod: faker.helpers.arrayElement([
      {
        days: faker.number.int({ min: void 0, max: void 0 }),
        ...overrideResponse
      },
      void 0
    ]),
    defaultValidator: faker.helpers.arrayElement([
      faker.word.sample(),
      void 0
    ]),
    description: faker.word.sample(),
    documentation: faker.word.sample(),
    fee: {
      depositFee: faker.datatype.boolean(),
      enabled: faker.datatype.boolean(),
      managementFee: faker.datatype.boolean(),
      performanceFee: faker.datatype.boolean(),
      ...overrideResponse
    },
    gasFeeToken: {
      address: faker.helpers.arrayElement([faker.word.sample(), void 0]),
      coinGeckoId: faker.helpers.arrayElement([faker.word.sample(), void 0]),
      decimals: faker.number.int({ min: void 0, max: void 0 }),
      isPoints: faker.helpers.arrayElement([
        faker.datatype.boolean(),
        void 0
      ]),
      logoURI: faker.helpers.arrayElement([faker.word.sample(), void 0]),
      name: faker.word.sample(),
      network: faker.helpers.arrayElement(Object.values(Networks)),
      symbol: faker.word.sample(),
      ...overrideResponse
    },
    isIntegrationAggregator: faker.helpers.arrayElement([
      faker.datatype.boolean(),
      void 0
    ]),
    logoURI: faker.word.sample(),
    minimumStake: faker.helpers.arrayElement([
      faker.number.int({ min: void 0, max: void 0 }),
      void 0
    ]),
    name: faker.word.sample(),
    provider: faker.helpers.arrayElement([
      {
        description: faker.word.sample(),
        externalLink: faker.word.sample(),
        id: faker.helpers.arrayElement(Object.values(YieldProviders)),
        logoURI: faker.word.sample(),
        name: faker.word.sample(),
        ...overrideResponse
      },
      void 0
    ]),
    revshare: { enabled: faker.datatype.boolean(), ...overrideResponse },
    rewardClaiming: faker.helpers.arrayElement(Object.values(RewardClaiming)),
    rewardSchedule: faker.helpers.arrayElement(Object.values(RewardSchedule)),
    rewardTokens: faker.helpers.arrayElement([
      Array.from(
        { length: faker.number.int({ min: 1, max: 10 }) },
        (_, i) => i + 1
      ).map(() => ({
        address: faker.helpers.arrayElement([faker.word.sample(), void 0]),
        coinGeckoId: faker.helpers.arrayElement([
          faker.word.sample(),
          void 0
        ]),
        decimals: faker.number.int({ min: void 0, max: void 0 }),
        isPoints: faker.helpers.arrayElement([
          faker.datatype.boolean(),
          void 0
        ]),
        logoURI: faker.helpers.arrayElement([faker.word.sample(), void 0]),
        name: faker.word.sample(),
        network: faker.helpers.arrayElement(Object.values(Networks)),
        symbol: faker.word.sample(),
        ...overrideResponse
      })),
      void 0
    ]),
    supportsLedgerWalletApi: faker.helpers.arrayElement([
      faker.datatype.boolean(),
      void 0
    ]),
    supportsMultipleValidators: faker.helpers.arrayElement([
      faker.datatype.boolean(),
      void 0
    ]),
    token: {
      address: faker.helpers.arrayElement([faker.word.sample(), void 0]),
      coinGeckoId: faker.helpers.arrayElement([faker.word.sample(), void 0]),
      decimals: faker.number.int({ min: void 0, max: void 0 }),
      isPoints: faker.helpers.arrayElement([
        faker.datatype.boolean(),
        void 0
      ]),
      logoURI: faker.helpers.arrayElement([faker.word.sample(), void 0]),
      name: faker.word.sample(),
      network: faker.helpers.arrayElement(Object.values(Networks)),
      symbol: faker.word.sample(),
      ...overrideResponse
    },
    tokens: faker.helpers.arrayElement([
      Array.from(
        { length: faker.number.int({ min: 1, max: 10 }) },
        (_, i) => i + 1
      ).map(() => ({
        address: faker.helpers.arrayElement([faker.word.sample(), void 0]),
        coinGeckoId: faker.helpers.arrayElement([
          faker.word.sample(),
          void 0
        ]),
        decimals: faker.number.int({ min: void 0, max: void 0 }),
        isPoints: faker.helpers.arrayElement([
          faker.datatype.boolean(),
          void 0
        ]),
        logoURI: faker.helpers.arrayElement([faker.word.sample(), void 0]),
        name: faker.word.sample(),
        network: faker.helpers.arrayElement(Object.values(Networks)),
        symbol: faker.word.sample(),
        ...overrideResponse
      })),
      void 0
    ]),
    type: faker.helpers.arrayElement(Object.values(YieldType)),
    warmupPeriod: {
      days: faker.number.int({ min: void 0, max: void 0 }),
      ...overrideResponse
    },
    withdrawPeriod: faker.helpers.arrayElement([
      {
        days: faker.number.int({ min: void 0, max: void 0 }),
        ...overrideResponse
      },
      void 0
    ]),
    ...overrideResponse
  },
  rewardRate: faker.number.int({ min: void 0, max: void 0 }),
  rewardType: faker.helpers.arrayElement(Object.values(RewardTypes)),
  status: {
    enter: faker.datatype.boolean(),
    exit: faker.datatype.boolean(),
    ...overrideResponse
  },
  token: {
    address: faker.helpers.arrayElement([faker.word.sample(), void 0]),
    coinGeckoId: faker.helpers.arrayElement([faker.word.sample(), void 0]),
    decimals: faker.number.int({ min: void 0, max: void 0 }),
    isPoints: faker.helpers.arrayElement([faker.datatype.boolean(), void 0]),
    logoURI: faker.helpers.arrayElement([faker.word.sample(), void 0]),
    name: faker.word.sample(),
    network: faker.helpers.arrayElement(Object.values(Networks)),
    symbol: faker.word.sample(),
    ...overrideResponse
  },
  tokens: Array.from(
    { length: faker.number.int({ min: 1, max: 10 }) },
    (_, i) => i + 1
  ).map(() => ({
    address: faker.helpers.arrayElement([faker.word.sample(), void 0]),
    coinGeckoId: faker.helpers.arrayElement([faker.word.sample(), void 0]),
    decimals: faker.number.int({ min: void 0, max: void 0 }),
    isPoints: faker.helpers.arrayElement([faker.datatype.boolean(), void 0]),
    logoURI: faker.helpers.arrayElement([faker.word.sample(), void 0]),
    name: faker.word.sample(),
    network: faker.helpers.arrayElement(Object.values(Networks)),
    symbol: faker.word.sample(),
    ...overrideResponse
  })),
  validators: Array.from(
    { length: faker.number.int({ min: 1, max: 10 }) },
    (_, i) => i + 1
  ).map(() => ({
    address: faker.word.sample(),
    apr: faker.helpers.arrayElement([
      faker.number.int({ min: void 0, max: void 0 }),
      void 0
    ]),
    commission: faker.helpers.arrayElement([
      faker.number.int({ min: void 0, max: void 0 }),
      void 0
    ]),
    endDate: faker.helpers.arrayElement([
      `${faker.date.past().toISOString().split(".")[0]}Z`,
      void 0
    ]),
    image: faker.helpers.arrayElement([faker.word.sample(), void 0]),
    minimumStake: faker.helpers.arrayElement([faker.word.sample(), void 0]),
    name: faker.helpers.arrayElement([faker.word.sample(), void 0]),
    preferred: faker.helpers.arrayElement([
      faker.datatype.boolean(),
      void 0
    ]),
    providerId: faker.helpers.arrayElement([faker.word.sample(), void 0]),
    remainingPossibleStake: faker.helpers.arrayElement([
      faker.word.sample(),
      void 0
    ]),
    remainingSlots: faker.helpers.arrayElement([
      faker.number.int({ min: void 0, max: void 0 }),
      void 0
    ]),
    stakedBalance: faker.helpers.arrayElement([faker.word.sample(), void 0]),
    status: faker.helpers.arrayElement(Object.values(ValidatorStatusTypes)),
    votingPower: faker.helpers.arrayElement([
      faker.number.int({ min: void 0, max: void 0 }),
      void 0
    ]),
    website: faker.helpers.arrayElement([faker.word.sample(), void 0]),
    ...overrideResponse
  })),
  ...overrideResponse
});
var getYieldV2ControllerFindYieldValidatorsResponseMock = (overrideResponse = {}) => Array.from(
  { length: faker.number.int({ min: 1, max: 10 }) },
  (_, i) => i + 1
).map(() => ({
  integrationId: faker.word.sample(),
  validators: Array.from(
    { length: faker.number.int({ min: 1, max: 10 }) },
    (_, i) => i + 1
  ).map(() => ({
    address: faker.word.sample(),
    apr: faker.helpers.arrayElement([
      faker.number.int({ min: void 0, max: void 0 }),
      void 0
    ]),
    commission: faker.helpers.arrayElement([
      faker.number.int({ min: void 0, max: void 0 }),
      void 0
    ]),
    endDate: faker.helpers.arrayElement([
      `${faker.date.past().toISOString().split(".")[0]}Z`,
      void 0
    ]),
    image: faker.helpers.arrayElement([faker.word.sample(), void 0]),
    minimumStake: faker.helpers.arrayElement([
      faker.word.sample(),
      void 0
    ]),
    name: faker.helpers.arrayElement([faker.word.sample(), void 0]),
    preferred: faker.helpers.arrayElement([
      faker.datatype.boolean(),
      void 0
    ]),
    providerId: faker.helpers.arrayElement([faker.word.sample(), void 0]),
    remainingPossibleStake: faker.helpers.arrayElement([
      faker.word.sample(),
      void 0
    ]),
    remainingSlots: faker.helpers.arrayElement([
      faker.number.int({ min: void 0, max: void 0 }),
      void 0
    ]),
    stakedBalance: faker.helpers.arrayElement([
      faker.word.sample(),
      void 0
    ]),
    status: faker.helpers.arrayElement(Object.values(ValidatorStatusTypes)),
    votingPower: faker.helpers.arrayElement([
      faker.number.int({ min: void 0, max: void 0 }),
      void 0
    ]),
    website: faker.helpers.arrayElement([faker.word.sample(), void 0]),
    ...overrideResponse
  })),
  ...overrideResponse
}));
var getYieldV2ControllerFindValidatorsResponseMock = (overrideResponse = {}) => Array.from(
  { length: faker.number.int({ min: 1, max: 10 }) },
  (_, i) => i + 1
).map(() => ({
  integrationId: faker.word.sample(),
  validators: Array.from(
    { length: faker.number.int({ min: 1, max: 10 }) },
    (_, i) => i + 1
  ).map(() => ({
    address: faker.word.sample(),
    apr: faker.helpers.arrayElement([
      faker.number.int({ min: void 0, max: void 0 }),
      void 0
    ]),
    commission: faker.helpers.arrayElement([
      faker.number.int({ min: void 0, max: void 0 }),
      void 0
    ]),
    endDate: faker.helpers.arrayElement([
      `${faker.date.past().toISOString().split(".")[0]}Z`,
      void 0
    ]),
    image: faker.helpers.arrayElement([faker.word.sample(), void 0]),
    minimumStake: faker.helpers.arrayElement([
      faker.word.sample(),
      void 0
    ]),
    name: faker.helpers.arrayElement([faker.word.sample(), void 0]),
    preferred: faker.helpers.arrayElement([
      faker.datatype.boolean(),
      void 0
    ]),
    providerId: faker.helpers.arrayElement([faker.word.sample(), void 0]),
    remainingPossibleStake: faker.helpers.arrayElement([
      faker.word.sample(),
      void 0
    ]),
    remainingSlots: faker.helpers.arrayElement([
      faker.number.int({ min: void 0, max: void 0 }),
      void 0
    ]),
    stakedBalance: faker.helpers.arrayElement([
      faker.word.sample(),
      void 0
    ]),
    status: faker.helpers.arrayElement(Object.values(ValidatorStatusTypes)),
    votingPower: faker.helpers.arrayElement([
      faker.number.int({ min: void 0, max: void 0 }),
      void 0
    ]),
    website: faker.helpers.arrayElement([faker.word.sample(), void 0]),
    ...overrideResponse
  })),
  ...overrideResponse
}));
var getHealthControllerHealthV2MockHandler = (overrideResponse) => {
  return http.get("*/v2/health", async () => {
    await delay(1e3);
    return new HttpResponse(
      JSON.stringify(
        overrideResponse ? overrideResponse : getHealthControllerHealthV2ResponseMock()
      ),
      {
        status: 200,
        headers: {
          "Content-Type": "application/json"
        }
      }
    );
  });
};
var getActionControllerGetActionMockHandler = (overrideResponse) => {
  return http.get("*/v1/actions/:actionId", async () => {
    await delay(1e3);
    return new HttpResponse(
      JSON.stringify(
        overrideResponse ? overrideResponse : getActionControllerGetActionResponseMock()
      ),
      {
        status: 200,
        headers: {
          "Content-Type": "application/json"
        }
      }
    );
  });
};
var getActionControllerGetGasEstimateMockHandler = (overrideResponse) => {
  return http.get("*/v1/actions/:actionId/gas-estimate", async () => {
    await delay(1e3);
    return new HttpResponse(
      JSON.stringify(
        overrideResponse ? overrideResponse : getActionControllerGetGasEstimateResponseMock()
      ),
      {
        status: 200,
        headers: {
          "Content-Type": "application/json"
        }
      }
    );
  });
};
var getActionControllerEnterMockHandler = (overrideResponse) => {
  return http.post("*/v1/actions/enter", async () => {
    await delay(1e3);
    return new HttpResponse(
      JSON.stringify(
        overrideResponse ? overrideResponse : getActionControllerEnterResponseMock()
      ),
      {
        status: 200,
        headers: {
          "Content-Type": "application/json"
        }
      }
    );
  });
};
var getActionControllerExitMockHandler = (overrideResponse) => {
  return http.post("*/v1/actions/exit", async () => {
    await delay(1e3);
    return new HttpResponse(
      JSON.stringify(
        overrideResponse ? overrideResponse : getActionControllerExitResponseMock()
      ),
      {
        status: 200,
        headers: {
          "Content-Type": "application/json"
        }
      }
    );
  });
};
var getActionControllerPendingMockHandler = (overrideResponse) => {
  return http.post("*/v1/actions/pending", async () => {
    await delay(1e3);
    return new HttpResponse(
      JSON.stringify(
        overrideResponse ? overrideResponse : getActionControllerPendingResponseMock()
      ),
      {
        status: 200,
        headers: {
          "Content-Type": "application/json"
        }
      }
    );
  });
};
var getActionControllerEnterGasEstimationMockHandler = (overrideResponse) => {
  return http.post("*/v1/actions/enter/estimate-gas", async () => {
    await delay(1e3);
    return new HttpResponse(
      JSON.stringify(
        overrideResponse ? overrideResponse : getActionControllerEnterGasEstimationResponseMock()
      ),
      {
        status: 200,
        headers: {
          "Content-Type": "application/json"
        }
      }
    );
  });
};
var getActionControllerExitGasEstimateMockHandler = (overrideResponse) => {
  return http.post("*/v1/actions/exit/estimate-gas", async () => {
    await delay(1e3);
    return new HttpResponse(
      JSON.stringify(
        overrideResponse ? overrideResponse : getActionControllerExitGasEstimateResponseMock()
      ),
      {
        status: 200,
        headers: {
          "Content-Type": "application/json"
        }
      }
    );
  });
};
var getActionControllerListMockHandler = (overrideResponse) => {
  return http.get("*/v1/actions", async () => {
    await delay(1e3);
    return new HttpResponse(
      JSON.stringify(
        overrideResponse ? overrideResponse : getActionControllerListResponseMock()
      ),
      {
        status: 200,
        headers: {
          "Content-Type": "application/json"
        }
      }
    );
  });
};
var getActionControllerPendingGasEstimateMockHandler = (overrideResponse) => {
  return http.post("*/v1/actions/pending/estimate-gas", async () => {
    await delay(1e3);
    return new HttpResponse(
      JSON.stringify(
        overrideResponse ? overrideResponse : getActionControllerPendingGasEstimateResponseMock()
      ),
      {
        status: 200,
        headers: {
          "Content-Type": "application/json"
        }
      }
    );
  });
};
var getTransactionControllerGetTransactionMockHandler = (overrideResponse) => {
  return http.get("*/v1/transactions/:transactionId", async () => {
    await delay(1e3);
    return new HttpResponse(
      JSON.stringify(
        overrideResponse ? overrideResponse : getTransactionControllerGetTransactionResponseMock()
      ),
      {
        status: 200,
        headers: {
          "Content-Type": "application/json"
        }
      }
    );
  });
};
var getTransactionControllerConstructMockHandler = (overrideResponse) => {
  return http.patch("*/v1/transactions/:transactionId", async () => {
    await delay(1e3);
    return new HttpResponse(
      JSON.stringify(
        overrideResponse ? overrideResponse : getTransactionControllerConstructResponseMock()
      ),
      {
        status: 200,
        headers: {
          "Content-Type": "application/json"
        }
      }
    );
  });
};
var getTransactionControllerSubmitMockHandler = (overrideResponse) => {
  return http.post("*/v1/transactions/:transactionId/submit", async () => {
    await delay(1e3);
    return new HttpResponse(
      JSON.stringify(
        overrideResponse ? overrideResponse : getTransactionControllerSubmitResponseMock()
      ),
      {
        status: 200,
        headers: {
          "Content-Type": "application/json"
        }
      }
    );
  });
};
var getTransactionControllerSubmitHashMockHandler = () => {
  return http.post("*/v1/transactions/:transactionId/submit_hash", async () => {
    await delay(1e3);
    return new HttpResponse(null, {
      status: 200,
      headers: {
        "Content-Type": "application/json"
      }
    });
  });
};
var getTransactionControllerGetTransactionStatusFromIdMockHandler = (overrideResponse) => {
  return http.get("*/v1/transactions/:transactionId/status", async () => {
    await delay(1e3);
    return new HttpResponse(
      JSON.stringify(
        overrideResponse ? overrideResponse : getTransactionControllerGetTransactionStatusFromIdResponseMock()
      ),
      {
        status: 200,
        headers: {
          "Content-Type": "application/json"
        }
      }
    );
  });
};
var getTransactionControllerGetGasForNetworkMockHandler = (overrideResponse) => {
  return http.get("*/v1/transactions/gas/:network", async () => {
    await delay(1e3);
    return new HttpResponse(
      JSON.stringify(
        overrideResponse ? overrideResponse : getTransactionControllerGetGasForNetworkResponseMock()
      ),
      {
        status: 200,
        headers: {
          "Content-Type": "application/json"
        }
      }
    );
  });
};
var getTransactionControllerGetTransactionStatusByNetworkAndHashMockHandler = (overrideResponse) => {
  return http.get("*/v1/transactions/status/:network/:hash", async () => {
    await delay(1e3);
    return new HttpResponse(
      JSON.stringify(
        overrideResponse ? overrideResponse : getTransactionControllerGetTransactionStatusByNetworkAndHashResponseMock()
      ),
      {
        status: 200,
        headers: {
          "Content-Type": "application/json"
        }
      }
    );
  });
};
var getTransactionControllerGetTransactionVerificationMessageForNetworkMockHandler = (overrideResponse) => {
  return http.post("*/v1/transactions/verification/:network", async () => {
    await delay(1e3);
    return new HttpResponse(
      JSON.stringify(
        overrideResponse ? overrideResponse : getTransactionControllerGetTransactionVerificationMessageForNetworkResponseMock()
      ),
      {
        status: 200,
        headers: {
          "Content-Type": "application/json"
        }
      }
    );
  });
};
var getTokenControllerGetTokensMockHandler = (overrideResponse) => {
  return http.get("*/v1/tokens", async () => {
    await delay(1e3);
    return new HttpResponse(
      JSON.stringify(
        overrideResponse ? overrideResponse : getTokenControllerGetTokensResponseMock()
      ),
      {
        status: 200,
        headers: {
          "Content-Type": "application/json"
        }
      }
    );
  });
};
var getTokenControllerGetTokenPricesMockHandler = (overrideResponse) => {
  return http.post("*/v1/tokens/prices", async () => {
    await delay(1e3);
    return new HttpResponse(
      JSON.stringify(
        overrideResponse ? overrideResponse : getTokenControllerGetTokenPricesResponseMock()
      ),
      {
        status: 200,
        headers: {
          "Content-Type": "application/json"
        }
      }
    );
  });
};
var getTokenControllerGetTokenBalancesMockHandler = (overrideResponse) => {
  return http.post("*/v1/tokens/balances", async () => {
    await delay(1e3);
    return new HttpResponse(
      JSON.stringify(
        overrideResponse ? overrideResponse : getTokenControllerGetTokenBalancesResponseMock()
      ),
      {
        status: 200,
        headers: {
          "Content-Type": "application/json"
        }
      }
    );
  });
};
var getTokenControllerTokenBalancesScanMockHandler = (overrideResponse) => {
  return http.post("*/v1/tokens/balances/scan", async () => {
    await delay(1e3);
    return new HttpResponse(
      JSON.stringify(
        overrideResponse ? overrideResponse : getTokenControllerTokenBalancesScanResponseMock()
      ),
      {
        status: 200,
        headers: {
          "Content-Type": "application/json"
        }
      }
    );
  });
};
var getYieldControllerYieldsMockHandler = (overrideResponse) => {
  return http.get("*/v1/yields", async () => {
    await delay(1e3);
    return new HttpResponse(
      JSON.stringify(
        overrideResponse ? overrideResponse : getYieldControllerYieldsResponseMock()
      ),
      {
        status: 200,
        headers: {
          "Content-Type": "application/json"
        }
      }
    );
  });
};
var getYieldControllerGetMultipleYieldBalancesMockHandler = (overrideResponse) => {
  return http.post("*/v1/yields/balances", async () => {
    await delay(1e3);
    return new HttpResponse(
      JSON.stringify(
        overrideResponse ? overrideResponse : getYieldControllerGetMultipleYieldBalancesResponseMock()
      ),
      {
        status: 200,
        headers: {
          "Content-Type": "application/json"
        }
      }
    );
  });
};
var getYieldControllerYieldBalancesScanMockHandler = (overrideResponse) => {
  return http.post("*/v1/yields/balances/scan", async () => {
    await delay(1e3);
    return new HttpResponse(
      JSON.stringify(
        overrideResponse ? overrideResponse : getYieldControllerYieldBalancesScanResponseMock()
      ),
      {
        status: 200,
        headers: {
          "Content-Type": "application/json"
        }
      }
    );
  });
};
var getYieldControllerYieldBalancesScanEvmMockHandler = (overrideResponse) => {
  return http.post("*/v1/yields/balances/scan/evm", async () => {
    await delay(1e3);
    return new HttpResponse(
      JSON.stringify(
        overrideResponse ? overrideResponse : getYieldControllerYieldBalancesScanEvmResponseMock()
      ),
      {
        status: 200,
        headers: {
          "Content-Type": "application/json"
        }
      }
    );
  });
};
var getYieldControllerGetMyYieldsMockHandler = (overrideResponse) => {
  return http.get("*/v1/yields/enabled", async () => {
    await delay(1e3);
    return new HttpResponse(
      JSON.stringify(
        overrideResponse ? overrideResponse : getYieldControllerGetMyYieldsResponseMock()
      ),
      {
        status: 200,
        headers: {
          "Content-Type": "application/json"
        }
      }
    );
  });
};
var getYieldControllerGetMyNetworksMockHandler = () => {
  return http.get("*/v1/yields/enabled/networks", async () => {
    await delay(1e3);
    return new HttpResponse(null, {
      status: 200,
      headers: {
        "Content-Type": "application/json"
      }
    });
  });
};
var getYieldControllerFindValidatorsMockHandler = (overrideResponse) => {
  return http.get("*/v1/yields/validators", async () => {
    await delay(1e3);
    return new HttpResponse(
      JSON.stringify(
        overrideResponse ? overrideResponse : getYieldControllerFindValidatorsResponseMock()
      ),
      {
        status: 200,
        headers: {
          "Content-Type": "application/json"
        }
      }
    );
  });
};
var getYieldControllerYieldOpportunityMockHandler = (overrideResponse) => {
  return http.get("*/v1/yields/:integrationId", async () => {
    await delay(1e3);
    return new HttpResponse(
      JSON.stringify(
        overrideResponse ? overrideResponse : getYieldControllerYieldOpportunityResponseMock()
      ),
      {
        status: 200,
        headers: {
          "Content-Type": "application/json"
        }
      }
    );
  });
};
var getYieldControllerGetValidatorsMockHandler = (overrideResponse) => {
  return http.get("*/v1/yields/:integrationId/validators", async () => {
    await delay(1e3);
    return new HttpResponse(
      JSON.stringify(
        overrideResponse ? overrideResponse : getYieldControllerGetValidatorsResponseMock()
      ),
      {
        status: 200,
        headers: {
          "Content-Type": "application/json"
        }
      }
    );
  });
};
var getYieldControllerGetSingleYieldBalancesMockHandler = (overrideResponse) => {
  return http.post("*/v1/yields/:integrationId/balances", async () => {
    await delay(1e3);
    return new HttpResponse(
      JSON.stringify(
        overrideResponse ? overrideResponse : getYieldControllerGetSingleYieldBalancesResponseMock()
      ),
      {
        status: 200,
        headers: {
          "Content-Type": "application/json"
        }
      }
    );
  });
};
var getYieldControllerGetSingleYieldRewardsSummaryMockHandler = (overrideResponse) => {
  return http.post("*/v1/yields/:integrationId/rewards-summary", async () => {
    await delay(1e3);
    return new HttpResponse(
      JSON.stringify(
        overrideResponse ? overrideResponse : getYieldControllerGetSingleYieldRewardsSummaryResponseMock()
      ),
      {
        status: 200,
        headers: {
          "Content-Type": "application/json"
        }
      }
    );
  });
};
var getYieldControllerGetFeeConfigurationMockHandler = (overrideResponse) => {
  return http.get("*/v1/yields/:integrationId/fee-configuration", async () => {
    await delay(1e3);
    return new HttpResponse(
      JSON.stringify(
        overrideResponse ? overrideResponse : getYieldControllerGetFeeConfigurationResponseMock()
      ),
      {
        status: 200,
        headers: {
          "Content-Type": "application/json"
        }
      }
    );
  });
};
var getYieldV2ControllerYieldsMockHandler = (overrideResponse) => {
  return http.get("*/v2/yields", async () => {
    await delay(1e3);
    return new HttpResponse(
      JSON.stringify(
        overrideResponse ? overrideResponse : getYieldV2ControllerYieldsResponseMock()
      ),
      {
        status: 200,
        headers: {
          "Content-Type": "application/json"
        }
      }
    );
  });
};
var getYieldV2ControllerGetYieldByIdMockHandler = (overrideResponse) => {
  return http.get("*/v2/yields/:yieldId", async () => {
    await delay(1e3);
    return new HttpResponse(
      JSON.stringify(
        overrideResponse ? overrideResponse : getYieldV2ControllerGetYieldByIdResponseMock()
      ),
      {
        status: 200,
        headers: {
          "Content-Type": "application/json"
        }
      }
    );
  });
};
var getYieldV2ControllerFindYieldValidatorsMockHandler = (overrideResponse) => {
  return http.get("*/v2/yields/:yieldId/validators", async () => {
    await delay(1e3);
    return new HttpResponse(
      JSON.stringify(
        overrideResponse ? overrideResponse : getYieldV2ControllerFindYieldValidatorsResponseMock()
      ),
      {
        status: 200,
        headers: {
          "Content-Type": "application/json"
        }
      }
    );
  });
};
var getYieldV2ControllerFindValidatorsMockHandler = (overrideResponse) => {
  return http.get("*/v2/yields/validators", async () => {
    await delay(1e3);
    return new HttpResponse(
      JSON.stringify(
        overrideResponse ? overrideResponse : getYieldV2ControllerFindValidatorsResponseMock()
      ),
      {
        status: 200,
        headers: {
          "Content-Type": "application/json"
        }
      }
    );
  });
};
var getStakeKitMock = () => [
  getHealthControllerHealthV2MockHandler(),
  getActionControllerGetActionMockHandler(),
  getActionControllerGetGasEstimateMockHandler(),
  getActionControllerEnterMockHandler(),
  getActionControllerExitMockHandler(),
  getActionControllerPendingMockHandler(),
  getActionControllerEnterGasEstimationMockHandler(),
  getActionControllerExitGasEstimateMockHandler(),
  getActionControllerListMockHandler(),
  getActionControllerPendingGasEstimateMockHandler(),
  getTransactionControllerGetTransactionMockHandler(),
  getTransactionControllerConstructMockHandler(),
  getTransactionControllerSubmitMockHandler(),
  getTransactionControllerSubmitHashMockHandler(),
  getTransactionControllerGetTransactionStatusFromIdMockHandler(),
  getTransactionControllerGetGasForNetworkMockHandler(),
  getTransactionControllerGetTransactionStatusByNetworkAndHashMockHandler(),
  getTransactionControllerGetTransactionVerificationMessageForNetworkMockHandler(),
  getTokenControllerGetTokensMockHandler(),
  getTokenControllerGetTokenPricesMockHandler(),
  getTokenControllerGetTokenBalancesMockHandler(),
  getTokenControllerTokenBalancesScanMockHandler(),
  getYieldControllerYieldsMockHandler(),
  getYieldControllerGetMultipleYieldBalancesMockHandler(),
  getYieldControllerYieldBalancesScanMockHandler(),
  getYieldControllerYieldBalancesScanEvmMockHandler(),
  getYieldControllerGetMyYieldsMockHandler(),
  getYieldControllerGetMyNetworksMockHandler(),
  getYieldControllerFindValidatorsMockHandler(),
  getYieldControllerYieldOpportunityMockHandler(),
  getYieldControllerGetValidatorsMockHandler(),
  getYieldControllerGetSingleYieldBalancesMockHandler(),
  getYieldControllerGetSingleYieldRewardsSummaryMockHandler(),
  getYieldControllerGetFeeConfigurationMockHandler(),
  getYieldV2ControllerYieldsMockHandler(),
  getYieldV2ControllerGetYieldByIdMockHandler(),
  getYieldV2ControllerFindYieldValidatorsMockHandler(),
  getYieldV2ControllerFindValidatorsMockHandler()
];

export { getActionControllerEnterGasEstimationMockHandler, getActionControllerEnterGasEstimationResponseMock, getActionControllerEnterMockHandler, getActionControllerEnterResponseMock, getActionControllerExitGasEstimateMockHandler, getActionControllerExitGasEstimateResponseMock, getActionControllerExitMockHandler, getActionControllerExitResponseMock, getActionControllerGetActionMockHandler, getActionControllerGetActionResponseMock, getActionControllerGetGasEstimateMockHandler, getActionControllerGetGasEstimateResponseMock, getActionControllerListMockHandler, getActionControllerListResponseMock, getActionControllerPendingGasEstimateMockHandler, getActionControllerPendingGasEstimateResponseMock, getActionControllerPendingMockHandler, getActionControllerPendingResponseMock, getHealthControllerHealthV2MockHandler, getHealthControllerHealthV2ResponseMock, getStakeKitMock, getTokenControllerGetTokenBalancesMockHandler, getTokenControllerGetTokenBalancesResponseMock, getTokenControllerGetTokenPricesMockHandler, getTokenControllerGetTokenPricesResponseMock, getTokenControllerGetTokensMockHandler, getTokenControllerGetTokensResponseMock, getTokenControllerTokenBalancesScanMockHandler, getTokenControllerTokenBalancesScanResponseMock, getTransactionControllerConstructMockHandler, getTransactionControllerConstructResponseMock, getTransactionControllerGetGasForNetworkMockHandler, getTransactionControllerGetGasForNetworkResponseMock, getTransactionControllerGetTransactionMockHandler, getTransactionControllerGetTransactionResponseMock, getTransactionControllerGetTransactionStatusByNetworkAndHashMockHandler, getTransactionControllerGetTransactionStatusByNetworkAndHashResponseMock, getTransactionControllerGetTransactionStatusFromIdMockHandler, getTransactionControllerGetTransactionStatusFromIdResponseMock, getTransactionControllerGetTransactionVerificationMessageForNetworkMockHandler, getTransactionControllerGetTransactionVerificationMessageForNetworkResponseMock, getTransactionControllerSubmitHashMockHandler, getTransactionControllerSubmitMockHandler, getTransactionControllerSubmitResponseMock, getYieldControllerFindValidatorsMockHandler, getYieldControllerFindValidatorsResponseMock, getYieldControllerGetFeeConfigurationMockHandler, getYieldControllerGetFeeConfigurationResponseMock, getYieldControllerGetMultipleYieldBalancesMockHandler, getYieldControllerGetMultipleYieldBalancesResponseMock, getYieldControllerGetMyNetworksMockHandler, getYieldControllerGetMyYieldsMockHandler, getYieldControllerGetMyYieldsResponseMock, getYieldControllerGetSingleYieldBalancesMockHandler, getYieldControllerGetSingleYieldBalancesResponseMock, getYieldControllerGetSingleYieldRewardsSummaryMockHandler, getYieldControllerGetSingleYieldRewardsSummaryResponseMock, getYieldControllerGetValidatorsMockHandler, getYieldControllerGetValidatorsResponseMock, getYieldControllerYieldBalancesScanEvmMockHandler, getYieldControllerYieldBalancesScanEvmResponseMock, getYieldControllerYieldBalancesScanMockHandler, getYieldControllerYieldBalancesScanResponseMock, getYieldControllerYieldOpportunityMockHandler, getYieldControllerYieldOpportunityResponseMock, getYieldControllerYieldsMockHandler, getYieldControllerYieldsResponseMock, getYieldV2ControllerFindValidatorsMockHandler, getYieldV2ControllerFindValidatorsResponseMock, getYieldV2ControllerFindYieldValidatorsMockHandler, getYieldV2ControllerFindYieldValidatorsResponseMock, getYieldV2ControllerGetYieldByIdMockHandler, getYieldV2ControllerGetYieldByIdResponseMock, getYieldV2ControllerYieldsMockHandler, getYieldV2ControllerYieldsResponseMock };
//# sourceMappingURL=out.js.map
//# sourceMappingURL=index.js.map