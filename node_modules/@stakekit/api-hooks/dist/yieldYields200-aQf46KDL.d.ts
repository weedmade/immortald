interface BinanceAdditionalAddressesStakeArgumentOptionsDto {
    [key: string]: any;
}

type Networks = (typeof Networks)[keyof typeof Networks];
declare const Networks: {
    readonly ethereum: "ethereum";
    readonly 'ethereum-goerli': "ethereum-goerli";
    readonly 'ethereum-holesky': "ethereum-holesky";
    readonly arbitrum: "arbitrum";
    readonly base: "base";
    readonly gnosis: "gnosis";
    readonly optimism: "optimism";
    readonly polygon: "polygon";
    readonly starknet: "starknet";
    readonly zksync: "zksync";
    readonly linea: "linea";
    readonly 'avalanche-c': "avalanche-c";
    readonly 'avalanche-c-atomic': "avalanche-c-atomic";
    readonly 'avalanche-p': "avalanche-p";
    readonly binance: "binance";
    readonly celo: "celo";
    readonly fantom: "fantom";
    readonly harmony: "harmony";
    readonly moonriver: "moonriver";
    readonly okc: "okc";
    readonly viction: "viction";
    readonly core: "core";
    readonly agoric: "agoric";
    readonly akash: "akash";
    readonly axelar: "axelar";
    readonly 'band-protocol': "band-protocol";
    readonly bitsong: "bitsong";
    readonly canto: "canto";
    readonly chihuahua: "chihuahua";
    readonly comdex: "comdex";
    readonly coreum: "coreum";
    readonly cosmos: "cosmos";
    readonly crescent: "crescent";
    readonly cronos: "cronos";
    readonly cudos: "cudos";
    readonly desmos: "desmos";
    readonly dydx: "dydx";
    readonly evmos: "evmos";
    readonly 'fetch-ai': "fetch-ai";
    readonly 'gravity-bridge': "gravity-bridge";
    readonly injective: "injective";
    readonly irisnet: "irisnet";
    readonly juno: "juno";
    readonly kava: "kava";
    readonly 'ki-network': "ki-network";
    readonly 'mars-protocol': "mars-protocol";
    readonly nym: "nym";
    readonly 'okex-chain': "okex-chain";
    readonly onomy: "onomy";
    readonly osmosis: "osmosis";
    readonly persistence: "persistence";
    readonly quicksilver: "quicksilver";
    readonly regen: "regen";
    readonly secret: "secret";
    readonly sentinel: "sentinel";
    readonly sommelier: "sommelier";
    readonly stafi: "stafi";
    readonly stargaze: "stargaze";
    readonly stride: "stride";
    readonly teritori: "teritori";
    readonly tgrade: "tgrade";
    readonly umee: "umee";
    readonly sei: "sei";
    readonly mantra: "mantra";
    readonly polkadot: "polkadot";
    readonly kusama: "kusama";
    readonly westend: "westend";
    readonly binancebeacon: "binancebeacon";
    readonly cardano: "cardano";
    readonly near: "near";
    readonly solana: "solana";
    readonly tezos: "tezos";
    readonly tron: "tron";
    readonly ton: "ton";
    readonly 'ton-testnet': "ton-testnet";
};

interface RequiredArgumentWithNetworkDto {
    network: Networks;
    required: boolean;
}

interface AddressArgumentsDto {
    additionalAddresses?: BinanceAdditionalAddressesStakeArgumentOptionsDto[];
    address?: RequiredArgumentWithNetworkDto;
}

interface AmountArgumentOptionsDto {
    maximum?: number;
    minimum?: number;
    required: boolean;
}

interface DurationArgumentOptionsDto {
    maximum?: number;
    minimum?: number;
    required: boolean;
}

interface RequiredArgumentDto {
    required: boolean;
}

interface ApeNativeArgumentOptionsDto {
    bakcId?: RequiredArgumentDto;
    baycId?: RequiredArgumentDto;
    maycId?: RequiredArgumentDto;
}

interface TronResourceArgumentOptionsDto {
    options: string[];
    required: boolean;
}

interface ArgumentOptionsDto {
    amount?: AmountArgumentOptionsDto;
    duration?: DurationArgumentOptionsDto;
    nfts?: ApeNativeArgumentOptionsDto[];
    signatureVerification?: RequiredArgumentDto;
    tronResource?: TronResourceArgumentOptionsDto;
    validatorAddress?: RequiredArgumentDto;
    validatorAddresses?: RequiredArgumentDto;
}

interface ActionArgumentOptionsDto {
    addresses?: AddressArgumentsDto;
    args?: ArgumentOptionsDto;
}

interface ActionArgumentResponseDto {
    enter: ActionArgumentOptionsDto;
    exit?: ActionArgumentOptionsDto;
}

interface TimePeriodDto {
    days: number;
}

interface YieldFeeDto {
    depositFee: boolean;
    enabled: boolean;
    managementFee: boolean;
    performanceFee: boolean;
}

interface TokenDto {
    address?: string;
    coinGeckoId?: string;
    decimals: number;
    isPoints?: boolean;
    logoURI?: string;
    name: string;
    network: Networks;
    symbol: string;
}

type YieldProviders = (typeof YieldProviders)[keyof typeof YieldProviders];
declare const YieldProviders: {
    readonly aave: "aave";
    readonly anchor: "anchor";
    readonly benqi: "benqi";
    readonly compound: "compound";
    readonly lido: "lido";
    readonly sushi: "sushi";
    readonly yearn: "yearn";
    readonly ape: "ape";
    readonly chainlink: "chainlink";
    readonly pendle: "pendle";
    readonly parax: "parax";
    readonly 'rocket-pool': "rocket-pool";
    readonly stakewise: "stakewise";
    readonly etherfi: "etherfi";
    readonly 'morpho-aave': "morpho-aave";
    readonly 'morpho-blue': "morpho-blue";
    readonly 'morpho-compound': "morpho-compound";
    readonly angle: "angle";
    readonly kelpdao: "kelpdao";
    readonly figment: "figment";
    readonly kiln: "kiln";
    readonly P2P: "P2P";
    readonly everstake: "everstake";
    readonly eigenlayer: "eigenlayer";
    readonly luganodes: "luganodes";
    readonly renzo: "renzo";
    readonly infstones: "infstones";
    readonly ethena: "ethena";
    readonly fluid: "fluid";
    readonly 'idle-finance': "idle-finance";
    readonly gearbox: "gearbox";
    readonly 'chorus-one': "chorus-one";
    readonly stakekit: "stakekit";
};

interface YieldProviderDto {
    description: string;
    externalLink: string;
    id: YieldProviders;
    logoURI: string;
    name: string;
}

interface YieldRevshareDto {
    enabled: boolean;
}

type RewardClaiming = (typeof RewardClaiming)[keyof typeof RewardClaiming];
declare const RewardClaiming: {
    readonly auto: "auto";
    readonly manual: "manual";
};

type RewardSchedule = (typeof RewardSchedule)[keyof typeof RewardSchedule];
declare const RewardSchedule: {
    readonly block: "block";
    readonly hour: "hour";
    readonly day: "day";
    readonly week: "week";
    readonly month: "month";
    readonly era: "era";
    readonly epoch: "epoch";
};

type YieldType = (typeof YieldType)[keyof typeof YieldType];
declare const YieldType: {
    readonly staking: "staking";
    readonly 'liquid-staking': "liquid-staking";
    readonly lending: "lending";
    readonly restaking: "restaking";
    readonly vault: "vault";
};

interface YieldMetadataDto {
    cooldownPeriod?: TimePeriodDto;
    defaultValidator?: string;
    description: string;
    documentation: string;
    fee: YieldFeeDto;
    gasFeeToken: TokenDto;
    isIntegrationAggregator?: boolean;
    logoURI: string;
    minimumStake?: number;
    name: string;
    provider?: YieldProviderDto;
    revshare: YieldRevshareDto;
    rewardClaiming: RewardClaiming;
    rewardSchedule: RewardSchedule;
    rewardTokens?: TokenDto[];
    supportsLedgerWalletApi?: boolean;
    supportsMultipleValidators?: boolean;
    token: TokenDto;
    tokens?: TokenDto[];
    type: YieldType;
    warmupPeriod: TimePeriodDto;
    withdrawPeriod?: TimePeriodDto;
}

type RewardTypes = (typeof RewardTypes)[keyof typeof RewardTypes];
declare const RewardTypes: {
    readonly apr: "apr";
    readonly apy: "apy";
    readonly variable: "variable";
};

interface YieldStatusResponseDto {
    enter: boolean;
    exit: boolean;
}

type ValidatorStatusTypes = (typeof ValidatorStatusTypes)[keyof typeof ValidatorStatusTypes];
declare const ValidatorStatusTypes: {
    readonly active: "active";
    readonly jailed: "jailed";
    readonly deactivating: "deactivating";
    readonly inactive: "inactive";
    readonly full: "full";
};

interface ValidatorDto {
    address: string;
    apr?: number;
    commission?: number;
    endDate?: string;
    image?: string;
    minimumStake?: string;
    name?: string;
    preferred?: boolean;
    providerId?: string;
    remainingPossibleStake?: string;
    remainingSlots?: number;
    stakedBalance?: string;
    status: ValidatorStatusTypes;
    votingPower?: number;
    website?: string;
}

interface YieldDto {
    apy: number;
    args: ActionArgumentResponseDto;
    /** The yield opportunity ID */
    id: string;
    isAvailable: boolean;
    metadata: YieldMetadataDto;
    rewardRate: number;
    rewardType: RewardTypes;
    status: YieldStatusResponseDto;
    token: TokenDto;
    tokens: TokenDto[];
    validators: ValidatorDto[];
}

type YieldV2Yields200AllOf = {
    data?: YieldDto[];
};

type YieldGetMyYields200AllOf = {
    data?: YieldDto[];
};

type YieldYields200AllOf = {
    data?: YieldDto[];
};

interface CosmosAdditionalAddressesDto {
    cosmosPubKey: string;
}

interface BinanceAdditionalAddressesDto {
    binanceBeaconAddress: string;
}

interface SolanaAdditionalAddressesDto {
    lidoStakeAccounts: string[];
    stakeAccounts: string[];
}

interface TezosAdditionalAddressesDto {
    tezosPubKey: string;
}

interface AvalancheCAdditionalAddressesDto {
    cAddressBech: string;
    pAddressBech: string;
}

type AddressesDtoAdditionalAddresses = CosmosAdditionalAddressesDto | BinanceAdditionalAddressesDto | SolanaAdditionalAddressesDto | TezosAdditionalAddressesDto | AvalancheCAdditionalAddressesDto;

interface AddressesDto {
    additionalAddresses?: AddressesDtoAdditionalAddresses;
    address: string;
    explorerUrl?: string;
}

type ActionStatus = (typeof ActionStatus)[keyof typeof ActionStatus];
declare const ActionStatus: {
    readonly CANCELED: "CANCELED";
    readonly CREATED: "CREATED";
    readonly WAITING_FOR_NEXT: "WAITING_FOR_NEXT";
    readonly PROCESSING: "PROCESSING";
    readonly FAILED: "FAILED";
    readonly SUCCESS: "SUCCESS";
    readonly STALE: "STALE";
};

interface GasEstimateDto {
    amount: string | null;
    gasLimit?: string;
    token: TokenDto;
}

type TransactionDtoGasEstimate = GasEstimateDto | null;

type TransactionStatus = (typeof TransactionStatus)[keyof typeof TransactionStatus];
declare const TransactionStatus: {
    readonly NOT_FOUND: "NOT_FOUND";
    readonly CREATED: "CREATED";
    readonly BLOCKED: "BLOCKED";
    readonly WAITING_FOR_SIGNATURE: "WAITING_FOR_SIGNATURE";
    readonly SIGNED: "SIGNED";
    readonly BROADCASTED: "BROADCASTED";
    readonly PENDING: "PENDING";
    readonly CONFIRMED: "CONFIRMED";
    readonly FAILED: "FAILED";
    readonly SKIPPED: "SKIPPED";
};

type TransactionType = (typeof TransactionType)[keyof typeof TransactionType];
declare const TransactionType: {
    readonly SWAP: "SWAP";
    readonly DEPOSIT: "DEPOSIT";
    readonly APPROVAL: "APPROVAL";
    readonly STAKE: "STAKE";
    readonly CLAIM_UNSTAKED: "CLAIM_UNSTAKED";
    readonly CLAIM_REWARDS: "CLAIM_REWARDS";
    readonly RESTAKE_REWARDS: "RESTAKE_REWARDS";
    readonly UNSTAKE: "UNSTAKE";
    readonly SPLIT: "SPLIT";
    readonly MERGE: "MERGE";
    readonly LOCK: "LOCK";
    readonly UNLOCK: "UNLOCK";
    readonly SUPPLY: "SUPPLY";
    readonly BRIDGE: "BRIDGE";
    readonly VOTE: "VOTE";
    readonly REVOKE: "REVOKE";
    readonly RESTAKE: "RESTAKE";
    readonly REBOND: "REBOND";
    readonly WITHDRAW: "WITHDRAW";
    readonly CREATE_ACCOUNT: "CREATE_ACCOUNT";
    readonly REVEAL: "REVEAL";
    readonly MIGRATE: "MIGRATE";
    readonly UTXO_P_TO_C_IMPORT: "UTXO_P_TO_C_IMPORT";
    readonly UTXO_C_TO_P_IMPORT: "UTXO_C_TO_P_IMPORT";
    readonly UNFREEZE_LEGACY: "UNFREEZE_LEGACY";
    readonly UNFREEZE_LEGACY_BANDWIDTH: "UNFREEZE_LEGACY_BANDWIDTH";
    readonly UNFREEZE_LEGACY_ENERGY: "UNFREEZE_LEGACY_ENERGY";
    readonly UNFREEZE_BANDWIDTH: "UNFREEZE_BANDWIDTH";
    readonly UNFREEZE_ENERGY: "UNFREEZE_ENERGY";
    readonly FREEZE_BANDWIDTH: "FREEZE_BANDWIDTH";
    readonly FREEZE_ENERGY: "FREEZE_ENERGY";
    readonly UNDELEGATE_BANDWIDTH: "UNDELEGATE_BANDWIDTH";
    readonly UNDELEGATE_ENERGY: "UNDELEGATE_ENERGY";
    readonly P2P_NODE_REQUEST: "P2P_NODE_REQUEST";
    readonly LUGANODES_PROVISION: "LUGANODES_PROVISION";
    readonly LUGANODES_EXIT_REQUEST: "LUGANODES_EXIT_REQUEST";
    readonly INFSTONES_PROVISION: "INFSTONES_PROVISION";
    readonly INFSTONES_EXIT_REQUEST: "INFSTONES_EXIT_REQUEST";
    readonly INFSTONES_CLAIM_REQUEST: "INFSTONES_CLAIM_REQUEST";
};

interface TransactionDto {
    accountAddresses?: string[];
    broadcastedAt: string | null;
    createdAt: string;
    error: string | null;
    explorerUrl: string | null;
    gasEstimate: TransactionDtoGasEstimate;
    hash: string | null;
    id: string;
    isMessage: boolean;
    ledgerHwAppId: string | null;
    network: Networks;
    signedTransaction: string | null;
    stakeId: string;
    status: TransactionStatus;
    stepIndex: number;
    type: TransactionType;
    unsignedTransaction: string | null;
}

type ActionTypes = (typeof ActionTypes)[keyof typeof ActionTypes];
declare const ActionTypes: {
    readonly STAKE: "STAKE";
    readonly UNSTAKE: "UNSTAKE";
    readonly CLAIM_REWARDS: "CLAIM_REWARDS";
    readonly RESTAKE_REWARDS: "RESTAKE_REWARDS";
    readonly WITHDRAW: "WITHDRAW";
    readonly RESTAKE: "RESTAKE";
    readonly CLAIM_UNSTAKED: "CLAIM_UNSTAKED";
    readonly UNLOCK_LOCKED: "UNLOCK_LOCKED";
    readonly STAKE_LOCKED: "STAKE_LOCKED";
    readonly VOTE: "VOTE";
    readonly REVOKE: "REVOKE";
    readonly VOTE_LOCKED: "VOTE_LOCKED";
    readonly REVOTE: "REVOTE";
    readonly REBOND: "REBOND";
    readonly MIGRATE: "MIGRATE";
};

interface ActionDto {
    accountAddresses?: string[];
    addresses: AddressesDto;
    amount: string | null;
    completedAt: string | null;
    createdAt: string;
    currentStepIndex: number;
    id: string;
    inputToken?: TokenDto;
    integrationId: string;
    status: ActionStatus;
    tokenId: string | null;
    transactions: TransactionDto[];
    type: ActionTypes;
    USDAmount: string | null;
    validatorAddress: string | null;
    validatorAddresses: string[] | null;
}

type ActionList200AllOf = {
    data?: ActionDto[];
};

type InfinityPaginatedDtoData = {
    [key: string]: any;
};

interface InfinityPaginatedDto {
    data: InfinityPaginatedDtoData;
    hasNextPage: boolean;
    limit: number;
    page: number;
}

interface CosmosGasArgsDto {
    gasPrice: string;
}

type EvmEIP1559GasArgsDtoType = (typeof EvmEIP1559GasArgsDtoType)[keyof typeof EvmEIP1559GasArgsDtoType];
declare const EvmEIP1559GasArgsDtoType: {
    readonly NUMBER_2: 2;
};

interface EvmEIP1559GasArgsDto {
    maxFeePerGas: string;
    maxPriorityFeePerGas: string;
    type: EvmEIP1559GasArgsDtoType;
}

type EvmLegacyGasArgsDtoType = (typeof EvmLegacyGasArgsDtoType)[keyof typeof EvmLegacyGasArgsDtoType];
declare const EvmLegacyGasArgsDtoType: {
    readonly NUMBER_0: 0;
};

interface EvmLegacyGasArgsDto {
    gasPrice: string;
    type: EvmLegacyGasArgsDtoType;
}

type ActionList200 = InfinityPaginatedDto & ActionList200AllOf;

interface BalanceResponseDto {
    amount: string;
    token: TokenDto;
}

type BalanceTypes = (typeof BalanceTypes)[keyof typeof BalanceTypes];
declare const BalanceTypes: {
    readonly available: "available";
    readonly staked: "staked";
    readonly unstaking: "unstaking";
    readonly unstaked: "unstaked";
    readonly preparing: "preparing";
    readonly rewards: "rewards";
    readonly locked: "locked";
    readonly unlocking: "unlocking";
};

type FeeConfigurationStatus = (typeof FeeConfigurationStatus)[keyof typeof FeeConfigurationStatus];
declare const FeeConfigurationStatus: {
    readonly REQUESTED: "REQUESTED";
    readonly PROCESSING: "PROCESSING";
    readonly LIVE: "LIVE";
    readonly CHANGES_REQUESTED: "CHANGES_REQUESTED";
};

interface FeeConfigurationDto {
    allocatorVaultContractAddress: string | null;
    depositFeeBps: number | null;
    feeWrapperContractAddress: string | null;
    id: string;
    integrationId: string;
    managementFeeBps: number | null;
    performanceFeeBps: number | null;
    projectId: string;
    status: FeeConfigurationStatus;
}

/**
 * Custom gas properties to request transaction construction with. Can include properties like `gasPrice`, `maxGasPerFee`, etc for EVM chains.
 */
type GasModeValueDtoGasArgs = CosmosGasArgsDto | EvmEIP1559GasArgsDto | EvmLegacyGasArgsDto;

type GasMode = (typeof GasMode)[keyof typeof GasMode];
declare const GasMode: {
    readonly slow: "slow";
    readonly average: "average";
    readonly fast: "fast";
    readonly custom: "custom";
};

interface GasModeValueDto {
    /** Custom gas properties to request transaction construction with. Can include properties like `gasPrice`, `maxGasPerFee`, etc for EVM chains. */
    gasArgs: GasModeValueDtoGasArgs;
    name: GasMode;
    value: string;
}

interface GasModesDto {
    /** The denomination of the token gas is quoted in */
    denom: string;
    values: GasModeValueDto[];
}

interface GasForNetworkResponseDto {
    customisable: boolean;
    modes: GasModesDto;
}

type HealthStatus = (typeof HealthStatus)[keyof typeof HealthStatus];
declare const HealthStatus: {
    readonly OK: "OK";
    readonly FAIL: "FAIL";
    readonly DEGRADED: "DEGRADED";
};

interface HealthStatusDto {
    db: HealthStatus;
    status: HealthStatus;
}

interface PendingActionDto {
    /** Any user chosen options for the pending action. Possible options can be  */
    args?: ActionArgumentOptionsDto;
    /** A server generated passthrough that must passed back when pulling the transactions for a given pending action */
    passthrough: string;
    type: ActionTypes;
}

type YieldBalanceLabelDtoParams = {
    [key: string]: any;
};

interface YieldBalanceLabelDto {
    params: YieldBalanceLabelDtoParams;
    type: string;
}

interface YieldBalanceDto {
    amount: string;
    date?: string;
    groupId: string;
    label?: YieldBalanceLabelDto;
    pendingActions: PendingActionDto[];
    /** The price of the reward token as a multiple of the underlying token. Used when dealing with index based yields where the reward asset appreciates in value over time. */
    pricePerShare: string;
    providerId?: string;
    token: TokenDto;
    type: BalanceTypes;
    validatorAddress?: string;
    validatorAddresses?: string[];
}

interface PriceResponseDto {
    [key: string]: any;
}

interface SubmitResponseDto {
    /** Link to the blockchain explorer */
    link: string;
    transactionHash: string;
}

interface TokenBalanceScanResponseDto {
    amount: string;
    availableYields: string[];
    token: TokenDto;
}

interface TokenWithAvailableYieldsDto {
    availableYields: string[];
    token: TokenDto;
}

type TransactionStatusResponseDtoRaw = {
    [key: string]: any;
};

interface TransactionStatusResponseDto {
    blockNumber?: string;
    hash: string;
    network: Networks;
    raw: TransactionStatusResponseDtoRaw;
    status: TransactionStatus;
    url: string;
}

interface TransactionVerificationMessageDto {
    message: string;
}

interface ValidatorSearchResultDto {
    integrationId: string;
    validators: ValidatorDto[];
}

interface YieldBalancesWithIntegrationIdDto {
    balances: YieldBalanceDto[];
    integrationId: string;
}

type YieldGetMyYields200 = InfinityPaginatedDto & YieldGetMyYields200AllOf;

interface YieldRewardsSummaryDto {
    last24H: string;
    last30D: string;
    last7D: string;
    lastYear: string;
    total: string;
}

interface YieldRewardsSummaryResponseDto {
    rewards: YieldRewardsSummaryDto;
    token: TokenDto;
}

type YieldV2Yields200 = InfinityPaginatedDto & YieldV2Yields200AllOf;

type YieldYields200 = InfinityPaginatedDto & YieldYields200AllOf;

export { EvmLegacyGasArgsDtoType as $, type AddressesDto as A, type BinanceAdditionalAddressesDto as B, type CosmosGasArgsDto as C, type YieldV2Yields200 as D, type EvmEIP1559GasArgsDto as E, type FeeConfigurationDto as F, type GasEstimateDto as G, type HealthStatusDto as H, type InfinityPaginatedDto as I, type YieldV2Yields200AllOf as J, type ActionArgumentOptionsDto as K, type ActionArgumentResponseDto as L, type AddressArgumentsDto as M, Networks as N, type AddressesDtoAdditionalAddresses as O, type PriceResponseDto as P, type AmountArgumentOptionsDto as Q, type ApeNativeArgumentOptionsDto as R, type SolanaAdditionalAddressesDto as S, type TokenDto as T, type ArgumentOptionsDto as U, type ValidatorSearchResultDto as V, BalanceTypes as W, type BinanceAdditionalAddressesStakeArgumentOptionsDto as X, type YieldBalanceDto as Y, type DurationArgumentOptionsDto as Z, EvmEIP1559GasArgsDtoType as _, type EvmLegacyGasArgsDto as a, FeeConfigurationStatus as a0, GasMode as a1, type GasModeValueDto as a2, type GasModeValueDtoGasArgs as a3, type GasModesDto as a4, HealthStatus as a5, type InfinityPaginatedDtoData as a6, type PendingActionDto as a7, type RequiredArgumentDto as a8, type RequiredArgumentWithNetworkDto as a9, RewardClaiming as aa, RewardSchedule as ab, RewardTypes as ac, type TimePeriodDto as ad, type TransactionDtoGasEstimate as ae, TransactionStatus as af, type TransactionStatusResponseDtoRaw as ag, TransactionType as ah, type TronResourceArgumentOptionsDto as ai, ValidatorStatusTypes as aj, type YieldBalanceLabelDto as ak, type YieldBalanceLabelDtoParams as al, type YieldFeeDto as am, type YieldProviderDto as an, YieldProviders as ao, type YieldRevshareDto as ap, type YieldRewardsSummaryDto as aq, type YieldStatusResponseDto as ar, YieldType as as, ActionStatus as b, type TransactionDto as c, ActionTypes as d, type CosmosAdditionalAddressesDto as e, type TezosAdditionalAddressesDto as f, type AvalancheCAdditionalAddressesDto as g, type YieldMetadataDto as h, type ActionDto as i, type ActionList200 as j, type ActionList200AllOf as k, type SubmitResponseDto as l, type TransactionStatusResponseDto as m, type GasForNetworkResponseDto as n, type TransactionVerificationMessageDto as o, type TokenWithAvailableYieldsDto as p, type BalanceResponseDto as q, type TokenBalanceScanResponseDto as r, type YieldYields200 as s, type YieldYields200AllOf as t, type YieldBalancesWithIntegrationIdDto as u, type YieldGetMyYields200 as v, type YieldGetMyYields200AllOf as w, type YieldDto as x, type ValidatorDto as y, type YieldRewardsSummaryResponseDto as z };
