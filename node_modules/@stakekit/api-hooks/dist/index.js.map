{"version":3,"sources":["../src/api/index.ts","../src/api-client-config.ts","../src/api-client.ts"],"names":["customFetch"],"mappings":"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","sourcesContent":["import { useMutation, useQuery } from '@tanstack/react-query';\nimport type {\n  MutationFunction,\n  QueryFunction,\n  QueryKey,\n  UseMutationOptions,\n  UseQueryOptions,\n  UseQueryResult,\n} from '@tanstack/react-query';\nimport type {\n  ActionDto,\n  ActionGasEstimateRequestDto,\n  ActionList200,\n  ActionListParams,\n  ActionRequestDto,\n  BalanceResponseDto,\n  BalancesRequestDto,\n  ConstructTransactionRequestDto,\n  FeeConfigurationDto,\n  GasEstimateDto,\n  GasForNetworkResponseDto,\n  GeolocationError,\n  HealthStatusDto,\n  PendingActionGasEstimateRequestDto,\n  PendingActionRequestDto,\n  PriceRequestDto,\n  PriceResponseDto,\n  StakeKitErrorDto,\n  SubmitHashRequestDto,\n  SubmitRequestDto,\n  SubmitResponseDto,\n  TokenBalanceScanDto,\n  TokenBalanceScanResponseDto,\n  TokenGetTokensParams,\n  TokenWithAvailableYieldsDto,\n  TransactionDto,\n  TransactionStatusResponseDto,\n  TransactionVerificationMessageDto,\n  TransactionVerificationMessageRequestDto,\n  ValidatorDto,\n  ValidatorSearchResultDto,\n  YieldBalanceDto,\n  YieldBalanceRequestDto,\n  YieldBalanceScanEvmRequestDto,\n  YieldBalanceScanRequestDto,\n  YieldBalanceWithIntegrationIdRequestDto,\n  YieldBalancesWithIntegrationIdDto,\n  YieldDto,\n  YieldFindValidatorsParams,\n  YieldGetMyYields200,\n  YieldGetMyYieldsParams,\n  YieldGetSingleYieldBalancesParams,\n  YieldGetValidatorsParams,\n  YieldRewardsSummaryRequestDto,\n  YieldRewardsSummaryResponseDto,\n  YieldV2FindValidatorsParams,\n  YieldV2FindYieldValidatorsParams,\n  YieldV2Yields200,\n  YieldV2YieldsParams,\n  YieldYieldOpportunityParams,\n  YieldYields200,\n  YieldYieldsParams,\n} from './schemas';\nimport { customFetch } from '../api-client';\n\nexport const healthHealthV2 = (signal?: AbortSignal) => {\n  return customFetch<HealthStatusDto>({\n    url: `/v2/health`,\n    method: 'GET',\n    signal,\n  });\n};\n\nexport const getHealthHealthV2QueryKey = () => {\n  return [`/v2/health`] as const;\n};\n\nexport const getHealthHealthV2QueryOptions = <\n  TData = Awaited<ReturnType<typeof healthHealthV2>>,\n  TError = StakeKitErrorDto,\n>(options?: {\n  query?: Partial<\n    UseQueryOptions<Awaited<ReturnType<typeof healthHealthV2>>, TError, TData>\n  >;\n}) => {\n  const { query: queryOptions } = options ?? {};\n\n  const queryKey = queryOptions?.queryKey ?? getHealthHealthV2QueryKey();\n\n  const queryFn: QueryFunction<Awaited<ReturnType<typeof healthHealthV2>>> = ({\n    signal,\n  }) => healthHealthV2(signal);\n\n  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<\n    Awaited<ReturnType<typeof healthHealthV2>>,\n    TError,\n    TData\n  > & { queryKey: QueryKey };\n};\n\nexport type HealthHealthV2QueryResult = NonNullable<\n  Awaited<ReturnType<typeof healthHealthV2>>\n>;\nexport type HealthHealthV2QueryError = StakeKitErrorDto;\n\nexport const useHealthHealthV2 = <\n  TData = Awaited<ReturnType<typeof healthHealthV2>>,\n  TError = StakeKitErrorDto,\n>(options?: {\n  query?: Partial<\n    UseQueryOptions<Awaited<ReturnType<typeof healthHealthV2>>, TError, TData>\n  >;\n}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {\n  const queryOptions = getHealthHealthV2QueryOptions(options);\n\n  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {\n    queryKey: QueryKey;\n  };\n\n  query.queryKey = queryOptions.queryKey;\n\n  return query;\n};\n\n/**\n * Returns a action with associated transactions\n * @summary Get action\n */\nexport const actionGetAction = (actionId: string, signal?: AbortSignal) => {\n  return customFetch<ActionDto>({\n    url: `/v1/actions/${actionId}`,\n    method: 'GET',\n    signal,\n  });\n};\n\nexport const getActionGetActionQueryKey = (actionId: string) => {\n  return [`/v1/actions/${actionId}`] as const;\n};\n\nexport const getActionGetActionQueryOptions = <\n  TData = Awaited<ReturnType<typeof actionGetAction>>,\n  TError = StakeKitErrorDto | GeolocationError,\n>(\n  actionId: string,\n  options?: {\n    query?: Partial<\n      UseQueryOptions<\n        Awaited<ReturnType<typeof actionGetAction>>,\n        TError,\n        TData\n      >\n    >;\n  },\n) => {\n  const { query: queryOptions } = options ?? {};\n\n  const queryKey =\n    queryOptions?.queryKey ?? getActionGetActionQueryKey(actionId);\n\n  const queryFn: QueryFunction<Awaited<ReturnType<typeof actionGetAction>>> = ({\n    signal,\n  }) => actionGetAction(actionId, signal);\n\n  return {\n    queryKey,\n    queryFn,\n    enabled: !!actionId,\n    ...queryOptions,\n  } as UseQueryOptions<\n    Awaited<ReturnType<typeof actionGetAction>>,\n    TError,\n    TData\n  > & { queryKey: QueryKey };\n};\n\nexport type ActionGetActionQueryResult = NonNullable<\n  Awaited<ReturnType<typeof actionGetAction>>\n>;\nexport type ActionGetActionQueryError = StakeKitErrorDto | GeolocationError;\n\n/**\n * @summary Get action\n */\nexport const useActionGetAction = <\n  TData = Awaited<ReturnType<typeof actionGetAction>>,\n  TError = StakeKitErrorDto | GeolocationError,\n>(\n  actionId: string,\n  options?: {\n    query?: Partial<\n      UseQueryOptions<\n        Awaited<ReturnType<typeof actionGetAction>>,\n        TError,\n        TData\n      >\n    >;\n  },\n): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {\n  const queryOptions = getActionGetActionQueryOptions(actionId, options);\n\n  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {\n    queryKey: QueryKey;\n  };\n\n  query.queryKey = queryOptions.queryKey;\n\n  return query;\n};\n\n/**\n * Returns a gas estimate\n * @summary Get estimated gas for action\n */\nexport const actionGetGasEstimate = (\n  actionId: string,\n  signal?: AbortSignal,\n) => {\n  return customFetch<GasEstimateDto>({\n    url: `/v1/actions/${actionId}/gas-estimate`,\n    method: 'GET',\n    signal,\n  });\n};\n\nexport const getActionGetGasEstimateQueryKey = (actionId: string) => {\n  return [`/v1/actions/${actionId}/gas-estimate`] as const;\n};\n\nexport const getActionGetGasEstimateQueryOptions = <\n  TData = Awaited<ReturnType<typeof actionGetGasEstimate>>,\n  TError = StakeKitErrorDto | GeolocationError,\n>(\n  actionId: string,\n  options?: {\n    query?: Partial<\n      UseQueryOptions<\n        Awaited<ReturnType<typeof actionGetGasEstimate>>,\n        TError,\n        TData\n      >\n    >;\n  },\n) => {\n  const { query: queryOptions } = options ?? {};\n\n  const queryKey =\n    queryOptions?.queryKey ?? getActionGetGasEstimateQueryKey(actionId);\n\n  const queryFn: QueryFunction<\n    Awaited<ReturnType<typeof actionGetGasEstimate>>\n  > = ({ signal }) => actionGetGasEstimate(actionId, signal);\n\n  return {\n    queryKey,\n    queryFn,\n    enabled: !!actionId,\n    ...queryOptions,\n  } as UseQueryOptions<\n    Awaited<ReturnType<typeof actionGetGasEstimate>>,\n    TError,\n    TData\n  > & { queryKey: QueryKey };\n};\n\nexport type ActionGetGasEstimateQueryResult = NonNullable<\n  Awaited<ReturnType<typeof actionGetGasEstimate>>\n>;\nexport type ActionGetGasEstimateQueryError =\n  | StakeKitErrorDto\n  | GeolocationError;\n\n/**\n * @summary Get estimated gas for action\n */\nexport const useActionGetGasEstimate = <\n  TData = Awaited<ReturnType<typeof actionGetGasEstimate>>,\n  TError = StakeKitErrorDto | GeolocationError,\n>(\n  actionId: string,\n  options?: {\n    query?: Partial<\n      UseQueryOptions<\n        Awaited<ReturnType<typeof actionGetGasEstimate>>,\n        TError,\n        TData\n      >\n    >;\n  },\n): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {\n  const queryOptions = getActionGetGasEstimateQueryOptions(actionId, options);\n\n  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {\n    queryKey: QueryKey;\n  };\n\n  query.queryKey = queryOptions.queryKey;\n\n  return query;\n};\n\n/**\n * Get the transactions necessary to enter a yield bearing position\n * @summary Create \"enter\" action\n */\nexport const actionEnter = (actionRequestDto: ActionRequestDto) => {\n  return customFetch<ActionDto>({\n    url: `/v1/actions/enter`,\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    data: actionRequestDto,\n  });\n};\n\nexport const getActionEnterMutationOptions = <\n  TError = StakeKitErrorDto | GeolocationError,\n  TContext = unknown,\n>(options?: {\n  mutation?: UseMutationOptions<\n    Awaited<ReturnType<typeof actionEnter>>,\n    TError,\n    { data: ActionRequestDto },\n    TContext\n  >;\n}): UseMutationOptions<\n  Awaited<ReturnType<typeof actionEnter>>,\n  TError,\n  { data: ActionRequestDto },\n  TContext\n> => {\n  const { mutation: mutationOptions } = options ?? {};\n\n  const mutationFn: MutationFunction<\n    Awaited<ReturnType<typeof actionEnter>>,\n    { data: ActionRequestDto }\n  > = (props) => {\n    const { data } = props ?? {};\n\n    return actionEnter(data);\n  };\n\n  return { mutationFn, ...mutationOptions };\n};\n\nexport type ActionEnterMutationResult = NonNullable<\n  Awaited<ReturnType<typeof actionEnter>>\n>;\nexport type ActionEnterMutationBody = ActionRequestDto;\nexport type ActionEnterMutationError = StakeKitErrorDto | GeolocationError;\n\n/**\n * @summary Create \"enter\" action\n */\nexport const useActionEnter = <\n  TError = StakeKitErrorDto | GeolocationError,\n  TContext = unknown,\n>(options?: {\n  mutation?: UseMutationOptions<\n    Awaited<ReturnType<typeof actionEnter>>,\n    TError,\n    { data: ActionRequestDto },\n    TContext\n  >;\n}) => {\n  const mutationOptions = getActionEnterMutationOptions(options);\n\n  return useMutation(mutationOptions);\n};\n\n/**\n * Get the transactions necessary to exit a yield bearing position\n * @summary Create \"exit\" action\n */\nexport const actionExit = (actionRequestDto: ActionRequestDto) => {\n  return customFetch<ActionDto>({\n    url: `/v1/actions/exit`,\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    data: actionRequestDto,\n  });\n};\n\nexport const getActionExitMutationOptions = <\n  TError = StakeKitErrorDto | GeolocationError,\n  TContext = unknown,\n>(options?: {\n  mutation?: UseMutationOptions<\n    Awaited<ReturnType<typeof actionExit>>,\n    TError,\n    { data: ActionRequestDto },\n    TContext\n  >;\n}): UseMutationOptions<\n  Awaited<ReturnType<typeof actionExit>>,\n  TError,\n  { data: ActionRequestDto },\n  TContext\n> => {\n  const { mutation: mutationOptions } = options ?? {};\n\n  const mutationFn: MutationFunction<\n    Awaited<ReturnType<typeof actionExit>>,\n    { data: ActionRequestDto }\n  > = (props) => {\n    const { data } = props ?? {};\n\n    return actionExit(data);\n  };\n\n  return { mutationFn, ...mutationOptions };\n};\n\nexport type ActionExitMutationResult = NonNullable<\n  Awaited<ReturnType<typeof actionExit>>\n>;\nexport type ActionExitMutationBody = ActionRequestDto;\nexport type ActionExitMutationError = StakeKitErrorDto | GeolocationError;\n\n/**\n * @summary Create \"exit\" action\n */\nexport const useActionExit = <\n  TError = StakeKitErrorDto | GeolocationError,\n  TContext = unknown,\n>(options?: {\n  mutation?: UseMutationOptions<\n    Awaited<ReturnType<typeof actionExit>>,\n    TError,\n    { data: ActionRequestDto },\n    TContext\n  >;\n}) => {\n  const mutationOptions = getActionExitMutationOptions(options);\n\n  return useMutation(mutationOptions);\n};\n\n/**\n * Get the transactions to apply a pending action\n * @summary Create \"pending\" action\n */\nexport const actionPending = (\n  pendingActionRequestDto: PendingActionRequestDto,\n) => {\n  return customFetch<ActionDto>({\n    url: `/v1/actions/pending`,\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    data: pendingActionRequestDto,\n  });\n};\n\nexport const getActionPendingMutationOptions = <\n  TError = StakeKitErrorDto | GeolocationError,\n  TContext = unknown,\n>(options?: {\n  mutation?: UseMutationOptions<\n    Awaited<ReturnType<typeof actionPending>>,\n    TError,\n    { data: PendingActionRequestDto },\n    TContext\n  >;\n}): UseMutationOptions<\n  Awaited<ReturnType<typeof actionPending>>,\n  TError,\n  { data: PendingActionRequestDto },\n  TContext\n> => {\n  const { mutation: mutationOptions } = options ?? {};\n\n  const mutationFn: MutationFunction<\n    Awaited<ReturnType<typeof actionPending>>,\n    { data: PendingActionRequestDto }\n  > = (props) => {\n    const { data } = props ?? {};\n\n    return actionPending(data);\n  };\n\n  return { mutationFn, ...mutationOptions };\n};\n\nexport type ActionPendingMutationResult = NonNullable<\n  Awaited<ReturnType<typeof actionPending>>\n>;\nexport type ActionPendingMutationBody = PendingActionRequestDto;\nexport type ActionPendingMutationError = StakeKitErrorDto | GeolocationError;\n\n/**\n * @summary Create \"pending\" action\n */\nexport const useActionPending = <\n  TError = StakeKitErrorDto | GeolocationError,\n  TContext = unknown,\n>(options?: {\n  mutation?: UseMutationOptions<\n    Awaited<ReturnType<typeof actionPending>>,\n    TError,\n    { data: PendingActionRequestDto },\n    TContext\n  >;\n}) => {\n  const mutationOptions = getActionPendingMutationOptions(options);\n\n  return useMutation(mutationOptions);\n};\n\n/**\n * Get the estimated gas necessary to enter a yield bearing position\n * @summary Estimate gas for the \"enter\" action\n */\nexport const actionEnterGasEstimation = (\n  actionGasEstimateRequestDto: ActionGasEstimateRequestDto,\n) => {\n  return customFetch<GasEstimateDto>({\n    url: `/v1/actions/enter/estimate-gas`,\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    data: actionGasEstimateRequestDto,\n  });\n};\n\nexport const getActionEnterGasEstimationQueryKey = (\n  actionGasEstimateRequestDto: ActionGasEstimateRequestDto,\n) => {\n  return [\n    `/v1/actions/enter/estimate-gas`,\n    actionGasEstimateRequestDto,\n  ] as const;\n};\n\nexport const getActionEnterGasEstimationQueryOptions = <\n  TData = Awaited<ReturnType<typeof actionEnterGasEstimation>>,\n  TError = StakeKitErrorDto | GeolocationError,\n>(\n  actionGasEstimateRequestDto: ActionGasEstimateRequestDto,\n  options?: {\n    query?: Partial<\n      UseQueryOptions<\n        Awaited<ReturnType<typeof actionEnterGasEstimation>>,\n        TError,\n        TData\n      >\n    >;\n  },\n) => {\n  const { query: queryOptions } = options ?? {};\n\n  const queryKey =\n    queryOptions?.queryKey ??\n    getActionEnterGasEstimationQueryKey(actionGasEstimateRequestDto);\n\n  const queryFn: QueryFunction<\n    Awaited<ReturnType<typeof actionEnterGasEstimation>>\n  > = () => actionEnterGasEstimation(actionGasEstimateRequestDto);\n\n  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<\n    Awaited<ReturnType<typeof actionEnterGasEstimation>>,\n    TError,\n    TData\n  > & { queryKey: QueryKey };\n};\n\nexport type ActionEnterGasEstimationQueryResult = NonNullable<\n  Awaited<ReturnType<typeof actionEnterGasEstimation>>\n>;\nexport type ActionEnterGasEstimationQueryError =\n  | StakeKitErrorDto\n  | GeolocationError;\n\n/**\n * @summary Estimate gas for the \"enter\" action\n */\nexport const useActionEnterGasEstimation = <\n  TData = Awaited<ReturnType<typeof actionEnterGasEstimation>>,\n  TError = StakeKitErrorDto | GeolocationError,\n>(\n  actionGasEstimateRequestDto: ActionGasEstimateRequestDto,\n  options?: {\n    query?: Partial<\n      UseQueryOptions<\n        Awaited<ReturnType<typeof actionEnterGasEstimation>>,\n        TError,\n        TData\n      >\n    >;\n  },\n): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {\n  const queryOptions = getActionEnterGasEstimationQueryOptions(\n    actionGasEstimateRequestDto,\n    options,\n  );\n\n  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {\n    queryKey: QueryKey;\n  };\n\n  query.queryKey = queryOptions.queryKey;\n\n  return query;\n};\n\n/**\n * Get the estimated gas necessary to exit a yield bearing position\n * @summary Estimate gas for the \"exit\" action\n */\nexport const actionExitGasEstimate = (\n  actionGasEstimateRequestDto: ActionGasEstimateRequestDto,\n) => {\n  return customFetch<GasEstimateDto>({\n    url: `/v1/actions/exit/estimate-gas`,\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    data: actionGasEstimateRequestDto,\n  });\n};\n\nexport const getActionExitGasEstimateQueryKey = (\n  actionGasEstimateRequestDto: ActionGasEstimateRequestDto,\n) => {\n  return [\n    `/v1/actions/exit/estimate-gas`,\n    actionGasEstimateRequestDto,\n  ] as const;\n};\n\nexport const getActionExitGasEstimateQueryOptions = <\n  TData = Awaited<ReturnType<typeof actionExitGasEstimate>>,\n  TError = StakeKitErrorDto | GeolocationError,\n>(\n  actionGasEstimateRequestDto: ActionGasEstimateRequestDto,\n  options?: {\n    query?: Partial<\n      UseQueryOptions<\n        Awaited<ReturnType<typeof actionExitGasEstimate>>,\n        TError,\n        TData\n      >\n    >;\n  },\n) => {\n  const { query: queryOptions } = options ?? {};\n\n  const queryKey =\n    queryOptions?.queryKey ??\n    getActionExitGasEstimateQueryKey(actionGasEstimateRequestDto);\n\n  const queryFn: QueryFunction<\n    Awaited<ReturnType<typeof actionExitGasEstimate>>\n  > = () => actionExitGasEstimate(actionGasEstimateRequestDto);\n\n  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<\n    Awaited<ReturnType<typeof actionExitGasEstimate>>,\n    TError,\n    TData\n  > & { queryKey: QueryKey };\n};\n\nexport type ActionExitGasEstimateQueryResult = NonNullable<\n  Awaited<ReturnType<typeof actionExitGasEstimate>>\n>;\nexport type ActionExitGasEstimateQueryError =\n  | StakeKitErrorDto\n  | GeolocationError;\n\n/**\n * @summary Estimate gas for the \"exit\" action\n */\nexport const useActionExitGasEstimate = <\n  TData = Awaited<ReturnType<typeof actionExitGasEstimate>>,\n  TError = StakeKitErrorDto | GeolocationError,\n>(\n  actionGasEstimateRequestDto: ActionGasEstimateRequestDto,\n  options?: {\n    query?: Partial<\n      UseQueryOptions<\n        Awaited<ReturnType<typeof actionExitGasEstimate>>,\n        TError,\n        TData\n      >\n    >;\n  },\n): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {\n  const queryOptions = getActionExitGasEstimateQueryOptions(\n    actionGasEstimateRequestDto,\n    options,\n  );\n\n  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {\n    queryKey: QueryKey;\n  };\n\n  query.queryKey = queryOptions.queryKey;\n\n  return query;\n};\n\nexport const actionList = (params: ActionListParams, signal?: AbortSignal) => {\n  return customFetch<ActionList200>({\n    url: `/v1/actions`,\n    method: 'GET',\n    params,\n    signal,\n  });\n};\n\nexport const getActionListQueryKey = (params: ActionListParams) => {\n  return [`/v1/actions`, ...(params ? [params] : [])] as const;\n};\n\nexport const getActionListQueryOptions = <\n  TData = Awaited<ReturnType<typeof actionList>>,\n  TError = StakeKitErrorDto,\n>(\n  params: ActionListParams,\n  options?: {\n    query?: Partial<\n      UseQueryOptions<Awaited<ReturnType<typeof actionList>>, TError, TData>\n    >;\n  },\n) => {\n  const { query: queryOptions } = options ?? {};\n\n  const queryKey = queryOptions?.queryKey ?? getActionListQueryKey(params);\n\n  const queryFn: QueryFunction<Awaited<ReturnType<typeof actionList>>> = ({\n    signal,\n  }) => actionList(params, signal);\n\n  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<\n    Awaited<ReturnType<typeof actionList>>,\n    TError,\n    TData\n  > & { queryKey: QueryKey };\n};\n\nexport type ActionListQueryResult = NonNullable<\n  Awaited<ReturnType<typeof actionList>>\n>;\nexport type ActionListQueryError = StakeKitErrorDto;\n\nexport const useActionList = <\n  TData = Awaited<ReturnType<typeof actionList>>,\n  TError = StakeKitErrorDto,\n>(\n  params: ActionListParams,\n  options?: {\n    query?: Partial<\n      UseQueryOptions<Awaited<ReturnType<typeof actionList>>, TError, TData>\n    >;\n  },\n): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {\n  const queryOptions = getActionListQueryOptions(params, options);\n\n  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {\n    queryKey: QueryKey;\n  };\n\n  query.queryKey = queryOptions.queryKey;\n\n  return query;\n};\n\n/**\n * Get the estimated gas necessary to apply a pending action\n * @summary Estimate gas for the \"pending\" action\n */\nexport const actionPendingGasEstimate = (\n  pendingActionGasEstimateRequestDto: PendingActionGasEstimateRequestDto,\n) => {\n  return customFetch<GasEstimateDto>({\n    url: `/v1/actions/pending/estimate-gas`,\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    data: pendingActionGasEstimateRequestDto,\n  });\n};\n\nexport const getActionPendingGasEstimateQueryKey = (\n  pendingActionGasEstimateRequestDto: PendingActionGasEstimateRequestDto,\n) => {\n  return [\n    `/v1/actions/pending/estimate-gas`,\n    pendingActionGasEstimateRequestDto,\n  ] as const;\n};\n\nexport const getActionPendingGasEstimateQueryOptions = <\n  TData = Awaited<ReturnType<typeof actionPendingGasEstimate>>,\n  TError = StakeKitErrorDto | GeolocationError,\n>(\n  pendingActionGasEstimateRequestDto: PendingActionGasEstimateRequestDto,\n  options?: {\n    query?: Partial<\n      UseQueryOptions<\n        Awaited<ReturnType<typeof actionPendingGasEstimate>>,\n        TError,\n        TData\n      >\n    >;\n  },\n) => {\n  const { query: queryOptions } = options ?? {};\n\n  const queryKey =\n    queryOptions?.queryKey ??\n    getActionPendingGasEstimateQueryKey(pendingActionGasEstimateRequestDto);\n\n  const queryFn: QueryFunction<\n    Awaited<ReturnType<typeof actionPendingGasEstimate>>\n  > = () => actionPendingGasEstimate(pendingActionGasEstimateRequestDto);\n\n  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<\n    Awaited<ReturnType<typeof actionPendingGasEstimate>>,\n    TError,\n    TData\n  > & { queryKey: QueryKey };\n};\n\nexport type ActionPendingGasEstimateQueryResult = NonNullable<\n  Awaited<ReturnType<typeof actionPendingGasEstimate>>\n>;\nexport type ActionPendingGasEstimateQueryError =\n  | StakeKitErrorDto\n  | GeolocationError;\n\n/**\n * @summary Estimate gas for the \"pending\" action\n */\nexport const useActionPendingGasEstimate = <\n  TData = Awaited<ReturnType<typeof actionPendingGasEstimate>>,\n  TError = StakeKitErrorDto | GeolocationError,\n>(\n  pendingActionGasEstimateRequestDto: PendingActionGasEstimateRequestDto,\n  options?: {\n    query?: Partial<\n      UseQueryOptions<\n        Awaited<ReturnType<typeof actionPendingGasEstimate>>,\n        TError,\n        TData\n      >\n    >;\n  },\n): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {\n  const queryOptions = getActionPendingGasEstimateQueryOptions(\n    pendingActionGasEstimateRequestDto,\n    options,\n  );\n\n  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {\n    queryKey: QueryKey;\n  };\n\n  query.queryKey = queryOptions.queryKey;\n\n  return query;\n};\n\n/**\n * Returns a transaction\n * @summary Get transaction\n */\nexport const transactionGetTransaction = (\n  transactionId: string,\n  signal?: AbortSignal,\n) => {\n  return customFetch<TransactionDto>({\n    url: `/v1/transactions/${transactionId}`,\n    method: 'GET',\n    signal,\n  });\n};\n\nexport const getTransactionGetTransactionQueryKey = (transactionId: string) => {\n  return [`/v1/transactions/${transactionId}`] as const;\n};\n\nexport const getTransactionGetTransactionQueryOptions = <\n  TData = Awaited<ReturnType<typeof transactionGetTransaction>>,\n  TError = StakeKitErrorDto | GeolocationError,\n>(\n  transactionId: string,\n  options?: {\n    query?: Partial<\n      UseQueryOptions<\n        Awaited<ReturnType<typeof transactionGetTransaction>>,\n        TError,\n        TData\n      >\n    >;\n  },\n) => {\n  const { query: queryOptions } = options ?? {};\n\n  const queryKey =\n    queryOptions?.queryKey ??\n    getTransactionGetTransactionQueryKey(transactionId);\n\n  const queryFn: QueryFunction<\n    Awaited<ReturnType<typeof transactionGetTransaction>>\n  > = ({ signal }) => transactionGetTransaction(transactionId, signal);\n\n  return {\n    queryKey,\n    queryFn,\n    enabled: !!transactionId,\n    ...queryOptions,\n  } as UseQueryOptions<\n    Awaited<ReturnType<typeof transactionGetTransaction>>,\n    TError,\n    TData\n  > & { queryKey: QueryKey };\n};\n\nexport type TransactionGetTransactionQueryResult = NonNullable<\n  Awaited<ReturnType<typeof transactionGetTransaction>>\n>;\nexport type TransactionGetTransactionQueryError =\n  | StakeKitErrorDto\n  | GeolocationError;\n\n/**\n * @summary Get transaction\n */\nexport const useTransactionGetTransaction = <\n  TData = Awaited<ReturnType<typeof transactionGetTransaction>>,\n  TError = StakeKitErrorDto | GeolocationError,\n>(\n  transactionId: string,\n  options?: {\n    query?: Partial<\n      UseQueryOptions<\n        Awaited<ReturnType<typeof transactionGetTransaction>>,\n        TError,\n        TData\n      >\n    >;\n  },\n): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {\n  const queryOptions = getTransactionGetTransactionQueryOptions(\n    transactionId,\n    options,\n  );\n\n  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {\n    queryKey: QueryKey;\n  };\n\n  query.queryKey = queryOptions.queryKey;\n\n  return query;\n};\n\n/**\n * Constructs an unsigned transaction given a transaction id and optional gas parameters\n * @summary Construct transaction\n */\nexport const transactionConstruct = (\n  transactionId: string,\n  constructTransactionRequestDto: ConstructTransactionRequestDto,\n) => {\n  return customFetch<TransactionDto>({\n    url: `/v1/transactions/${transactionId}`,\n    method: 'PATCH',\n    headers: { 'Content-Type': 'application/json' },\n    data: constructTransactionRequestDto,\n  });\n};\n\nexport const getTransactionConstructMutationOptions = <\n  TError = StakeKitErrorDto | GeolocationError,\n  TContext = unknown,\n>(options?: {\n  mutation?: UseMutationOptions<\n    Awaited<ReturnType<typeof transactionConstruct>>,\n    TError,\n    { transactionId: string; data: ConstructTransactionRequestDto },\n    TContext\n  >;\n}): UseMutationOptions<\n  Awaited<ReturnType<typeof transactionConstruct>>,\n  TError,\n  { transactionId: string; data: ConstructTransactionRequestDto },\n  TContext\n> => {\n  const { mutation: mutationOptions } = options ?? {};\n\n  const mutationFn: MutationFunction<\n    Awaited<ReturnType<typeof transactionConstruct>>,\n    { transactionId: string; data: ConstructTransactionRequestDto }\n  > = (props) => {\n    const { transactionId, data } = props ?? {};\n\n    return transactionConstruct(transactionId, data);\n  };\n\n  return { mutationFn, ...mutationOptions };\n};\n\nexport type TransactionConstructMutationResult = NonNullable<\n  Awaited<ReturnType<typeof transactionConstruct>>\n>;\nexport type TransactionConstructMutationBody = ConstructTransactionRequestDto;\nexport type TransactionConstructMutationError =\n  | StakeKitErrorDto\n  | GeolocationError;\n\n/**\n * @summary Construct transaction\n */\nexport const useTransactionConstruct = <\n  TError = StakeKitErrorDto | GeolocationError,\n  TContext = unknown,\n>(options?: {\n  mutation?: UseMutationOptions<\n    Awaited<ReturnType<typeof transactionConstruct>>,\n    TError,\n    { transactionId: string; data: ConstructTransactionRequestDto },\n    TContext\n  >;\n}) => {\n  const mutationOptions = getTransactionConstructMutationOptions(options);\n\n  return useMutation(mutationOptions);\n};\n\n/**\n * Submits the signed transactions for broadcasting\n * @summary Submit transaction\n */\nexport const transactionSubmit = (\n  transactionId: string,\n  submitRequestDto: SubmitRequestDto,\n) => {\n  return customFetch<SubmitResponseDto>({\n    url: `/v1/transactions/${transactionId}/submit`,\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    data: submitRequestDto,\n  });\n};\n\nexport const getTransactionSubmitMutationOptions = <\n  TError = StakeKitErrorDto | GeolocationError,\n  TContext = unknown,\n>(options?: {\n  mutation?: UseMutationOptions<\n    Awaited<ReturnType<typeof transactionSubmit>>,\n    TError,\n    { transactionId: string; data: SubmitRequestDto },\n    TContext\n  >;\n}): UseMutationOptions<\n  Awaited<ReturnType<typeof transactionSubmit>>,\n  TError,\n  { transactionId: string; data: SubmitRequestDto },\n  TContext\n> => {\n  const { mutation: mutationOptions } = options ?? {};\n\n  const mutationFn: MutationFunction<\n    Awaited<ReturnType<typeof transactionSubmit>>,\n    { transactionId: string; data: SubmitRequestDto }\n  > = (props) => {\n    const { transactionId, data } = props ?? {};\n\n    return transactionSubmit(transactionId, data);\n  };\n\n  return { mutationFn, ...mutationOptions };\n};\n\nexport type TransactionSubmitMutationResult = NonNullable<\n  Awaited<ReturnType<typeof transactionSubmit>>\n>;\nexport type TransactionSubmitMutationBody = SubmitRequestDto;\nexport type TransactionSubmitMutationError =\n  | StakeKitErrorDto\n  | GeolocationError;\n\n/**\n * @summary Submit transaction\n */\nexport const useTransactionSubmit = <\n  TError = StakeKitErrorDto | GeolocationError,\n  TContext = unknown,\n>(options?: {\n  mutation?: UseMutationOptions<\n    Awaited<ReturnType<typeof transactionSubmit>>,\n    TError,\n    { transactionId: string; data: SubmitRequestDto },\n    TContext\n  >;\n}) => {\n  const mutationOptions = getTransactionSubmitMutationOptions(options);\n\n  return useMutation(mutationOptions);\n};\n\n/**\n * Submit a hash of an already broadcasted transaction\n * @summary Submit transaction hash\n */\nexport const transactionSubmitHash = (\n  transactionId: string,\n  submitHashRequestDto: SubmitHashRequestDto,\n) => {\n  return customFetch<void>({\n    url: `/v1/transactions/${transactionId}/submit_hash`,\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    data: submitHashRequestDto,\n  });\n};\n\nexport const getTransactionSubmitHashMutationOptions = <\n  TError = StakeKitErrorDto | GeolocationError,\n  TContext = unknown,\n>(options?: {\n  mutation?: UseMutationOptions<\n    Awaited<ReturnType<typeof transactionSubmitHash>>,\n    TError,\n    { transactionId: string; data: SubmitHashRequestDto },\n    TContext\n  >;\n}): UseMutationOptions<\n  Awaited<ReturnType<typeof transactionSubmitHash>>,\n  TError,\n  { transactionId: string; data: SubmitHashRequestDto },\n  TContext\n> => {\n  const { mutation: mutationOptions } = options ?? {};\n\n  const mutationFn: MutationFunction<\n    Awaited<ReturnType<typeof transactionSubmitHash>>,\n    { transactionId: string; data: SubmitHashRequestDto }\n  > = (props) => {\n    const { transactionId, data } = props ?? {};\n\n    return transactionSubmitHash(transactionId, data);\n  };\n\n  return { mutationFn, ...mutationOptions };\n};\n\nexport type TransactionSubmitHashMutationResult = NonNullable<\n  Awaited<ReturnType<typeof transactionSubmitHash>>\n>;\nexport type TransactionSubmitHashMutationBody = SubmitHashRequestDto;\nexport type TransactionSubmitHashMutationError =\n  | StakeKitErrorDto\n  | GeolocationError;\n\n/**\n * @summary Submit transaction hash\n */\nexport const useTransactionSubmitHash = <\n  TError = StakeKitErrorDto | GeolocationError,\n  TContext = unknown,\n>(options?: {\n  mutation?: UseMutationOptions<\n    Awaited<ReturnType<typeof transactionSubmitHash>>,\n    TError,\n    { transactionId: string; data: SubmitHashRequestDto },\n    TContext\n  >;\n}) => {\n  const mutationOptions = getTransactionSubmitHashMutationOptions(options);\n\n  return useMutation(mutationOptions);\n};\n\n/**\n * Returns the transaction status given a transaction id\n * @summary Get transaction status\n */\nexport const transactionGetTransactionStatusFromId = (\n  transactionId: string,\n  signal?: AbortSignal,\n) => {\n  return customFetch<TransactionStatusResponseDto>({\n    url: `/v1/transactions/${transactionId}/status`,\n    method: 'GET',\n    signal,\n  });\n};\n\nexport const getTransactionGetTransactionStatusFromIdQueryKey = (\n  transactionId: string,\n) => {\n  return [`/v1/transactions/${transactionId}/status`] as const;\n};\n\nexport const getTransactionGetTransactionStatusFromIdQueryOptions = <\n  TData = Awaited<ReturnType<typeof transactionGetTransactionStatusFromId>>,\n  TError = StakeKitErrorDto | GeolocationError,\n>(\n  transactionId: string,\n  options?: {\n    query?: Partial<\n      UseQueryOptions<\n        Awaited<ReturnType<typeof transactionGetTransactionStatusFromId>>,\n        TError,\n        TData\n      >\n    >;\n  },\n) => {\n  const { query: queryOptions } = options ?? {};\n\n  const queryKey =\n    queryOptions?.queryKey ??\n    getTransactionGetTransactionStatusFromIdQueryKey(transactionId);\n\n  const queryFn: QueryFunction<\n    Awaited<ReturnType<typeof transactionGetTransactionStatusFromId>>\n  > = ({ signal }) =>\n    transactionGetTransactionStatusFromId(transactionId, signal);\n\n  return {\n    queryKey,\n    queryFn,\n    enabled: !!transactionId,\n    ...queryOptions,\n  } as UseQueryOptions<\n    Awaited<ReturnType<typeof transactionGetTransactionStatusFromId>>,\n    TError,\n    TData\n  > & { queryKey: QueryKey };\n};\n\nexport type TransactionGetTransactionStatusFromIdQueryResult = NonNullable<\n  Awaited<ReturnType<typeof transactionGetTransactionStatusFromId>>\n>;\nexport type TransactionGetTransactionStatusFromIdQueryError =\n  | StakeKitErrorDto\n  | GeolocationError;\n\n/**\n * @summary Get transaction status\n */\nexport const useTransactionGetTransactionStatusFromId = <\n  TData = Awaited<ReturnType<typeof transactionGetTransactionStatusFromId>>,\n  TError = StakeKitErrorDto | GeolocationError,\n>(\n  transactionId: string,\n  options?: {\n    query?: Partial<\n      UseQueryOptions<\n        Awaited<ReturnType<typeof transactionGetTransactionStatusFromId>>,\n        TError,\n        TData\n      >\n    >;\n  },\n): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {\n  const queryOptions = getTransactionGetTransactionStatusFromIdQueryOptions(\n    transactionId,\n    options,\n  );\n\n  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {\n    queryKey: QueryKey;\n  };\n\n  query.queryKey = queryOptions.queryKey;\n\n  return query;\n};\n\n/**\n * Returns the current gas parameters for a network\n * @summary Get current gas parameters\n */\nexport const transactionGetGasForNetwork = (\n  network: string,\n  signal?: AbortSignal,\n) => {\n  return customFetch<GasForNetworkResponseDto>({\n    url: `/v1/transactions/gas/${network}`,\n    method: 'GET',\n    signal,\n  });\n};\n\nexport const getTransactionGetGasForNetworkQueryKey = (network: string) => {\n  return [`/v1/transactions/gas/${network}`] as const;\n};\n\nexport const getTransactionGetGasForNetworkQueryOptions = <\n  TData = Awaited<ReturnType<typeof transactionGetGasForNetwork>>,\n  TError = StakeKitErrorDto | GeolocationError,\n>(\n  network: string,\n  options?: {\n    query?: Partial<\n      UseQueryOptions<\n        Awaited<ReturnType<typeof transactionGetGasForNetwork>>,\n        TError,\n        TData\n      >\n    >;\n  },\n) => {\n  const { query: queryOptions } = options ?? {};\n\n  const queryKey =\n    queryOptions?.queryKey ?? getTransactionGetGasForNetworkQueryKey(network);\n\n  const queryFn: QueryFunction<\n    Awaited<ReturnType<typeof transactionGetGasForNetwork>>\n  > = ({ signal }) => transactionGetGasForNetwork(network, signal);\n\n  return {\n    queryKey,\n    queryFn,\n    enabled: !!network,\n    ...queryOptions,\n  } as UseQueryOptions<\n    Awaited<ReturnType<typeof transactionGetGasForNetwork>>,\n    TError,\n    TData\n  > & { queryKey: QueryKey };\n};\n\nexport type TransactionGetGasForNetworkQueryResult = NonNullable<\n  Awaited<ReturnType<typeof transactionGetGasForNetwork>>\n>;\nexport type TransactionGetGasForNetworkQueryError =\n  | StakeKitErrorDto\n  | GeolocationError;\n\n/**\n * @summary Get current gas parameters\n */\nexport const useTransactionGetGasForNetwork = <\n  TData = Awaited<ReturnType<typeof transactionGetGasForNetwork>>,\n  TError = StakeKitErrorDto | GeolocationError,\n>(\n  network: string,\n  options?: {\n    query?: Partial<\n      UseQueryOptions<\n        Awaited<ReturnType<typeof transactionGetGasForNetwork>>,\n        TError,\n        TData\n      >\n    >;\n  },\n): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {\n  const queryOptions = getTransactionGetGasForNetworkQueryOptions(\n    network,\n    options,\n  );\n\n  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {\n    queryKey: QueryKey;\n  };\n\n  query.queryKey = queryOptions.queryKey;\n\n  return query;\n};\n\n/**\n * Returns the transaction status given a transaction hash and a network\n * @summary Get transaction status\n */\nexport const transactionGetTransactionStatusByNetworkAndHash = (\n  network: string,\n  hash: string,\n  signal?: AbortSignal,\n) => {\n  return customFetch<TransactionStatusResponseDto>({\n    url: `/v1/transactions/status/${network}/${hash}`,\n    method: 'GET',\n    signal,\n  });\n};\n\nexport const getTransactionGetTransactionStatusByNetworkAndHashQueryKey = (\n  network: string,\n  hash: string,\n) => {\n  return [`/v1/transactions/status/${network}/${hash}`] as const;\n};\n\nexport const getTransactionGetTransactionStatusByNetworkAndHashQueryOptions = <\n  TData = Awaited<\n    ReturnType<typeof transactionGetTransactionStatusByNetworkAndHash>\n  >,\n  TError = StakeKitErrorDto | GeolocationError,\n>(\n  network: string,\n  hash: string,\n  options?: {\n    query?: Partial<\n      UseQueryOptions<\n        Awaited<\n          ReturnType<typeof transactionGetTransactionStatusByNetworkAndHash>\n        >,\n        TError,\n        TData\n      >\n    >;\n  },\n) => {\n  const { query: queryOptions } = options ?? {};\n\n  const queryKey =\n    queryOptions?.queryKey ??\n    getTransactionGetTransactionStatusByNetworkAndHashQueryKey(network, hash);\n\n  const queryFn: QueryFunction<\n    Awaited<ReturnType<typeof transactionGetTransactionStatusByNetworkAndHash>>\n  > = ({ signal }) =>\n    transactionGetTransactionStatusByNetworkAndHash(network, hash, signal);\n\n  return {\n    queryKey,\n    queryFn,\n    enabled: !!(network && hash),\n    ...queryOptions,\n  } as UseQueryOptions<\n    Awaited<ReturnType<typeof transactionGetTransactionStatusByNetworkAndHash>>,\n    TError,\n    TData\n  > & { queryKey: QueryKey };\n};\n\nexport type TransactionGetTransactionStatusByNetworkAndHashQueryResult =\n  NonNullable<\n    Awaited<ReturnType<typeof transactionGetTransactionStatusByNetworkAndHash>>\n  >;\nexport type TransactionGetTransactionStatusByNetworkAndHashQueryError =\n  | StakeKitErrorDto\n  | GeolocationError;\n\n/**\n * @summary Get transaction status\n */\nexport const useTransactionGetTransactionStatusByNetworkAndHash = <\n  TData = Awaited<\n    ReturnType<typeof transactionGetTransactionStatusByNetworkAndHash>\n  >,\n  TError = StakeKitErrorDto | GeolocationError,\n>(\n  network: string,\n  hash: string,\n  options?: {\n    query?: Partial<\n      UseQueryOptions<\n        Awaited<\n          ReturnType<typeof transactionGetTransactionStatusByNetworkAndHash>\n        >,\n        TError,\n        TData\n      >\n    >;\n  },\n): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {\n  const queryOptions =\n    getTransactionGetTransactionStatusByNetworkAndHashQueryOptions(\n      network,\n      hash,\n      options,\n    );\n\n  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {\n    queryKey: QueryKey;\n  };\n\n  query.queryKey = queryOptions.queryKey;\n\n  return query;\n};\n\n/**\n * Returns the transaction or message to sign to provide verification\n * @summary Get transaction verification transaction/message\n */\nexport const transactionGetTransactionVerificationMessageForNetwork = (\n  network: string,\n  transactionVerificationMessageRequestDto: TransactionVerificationMessageRequestDto,\n) => {\n  return customFetch<TransactionVerificationMessageDto>({\n    url: `/v1/transactions/verification/${network}`,\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    data: transactionVerificationMessageRequestDto,\n  });\n};\n\nexport const getTransactionGetTransactionVerificationMessageForNetworkMutationOptions =\n  <TError = StakeKitErrorDto | GeolocationError, TContext = unknown>(options?: {\n    mutation?: UseMutationOptions<\n      Awaited<\n        ReturnType<\n          typeof transactionGetTransactionVerificationMessageForNetwork\n        >\n      >,\n      TError,\n      { network: string; data: TransactionVerificationMessageRequestDto },\n      TContext\n    >;\n  }): UseMutationOptions<\n    Awaited<\n      ReturnType<typeof transactionGetTransactionVerificationMessageForNetwork>\n    >,\n    TError,\n    { network: string; data: TransactionVerificationMessageRequestDto },\n    TContext\n  > => {\n    const { mutation: mutationOptions } = options ?? {};\n\n    const mutationFn: MutationFunction<\n      Awaited<\n        ReturnType<\n          typeof transactionGetTransactionVerificationMessageForNetwork\n        >\n      >,\n      { network: string; data: TransactionVerificationMessageRequestDto }\n    > = (props) => {\n      const { network, data } = props ?? {};\n\n      return transactionGetTransactionVerificationMessageForNetwork(\n        network,\n        data,\n      );\n    };\n\n    return { mutationFn, ...mutationOptions };\n  };\n\nexport type TransactionGetTransactionVerificationMessageForNetworkMutationResult =\n  NonNullable<\n    Awaited<\n      ReturnType<typeof transactionGetTransactionVerificationMessageForNetwork>\n    >\n  >;\nexport type TransactionGetTransactionVerificationMessageForNetworkMutationBody =\n  TransactionVerificationMessageRequestDto;\nexport type TransactionGetTransactionVerificationMessageForNetworkMutationError =\n  StakeKitErrorDto | GeolocationError;\n\n/**\n * @summary Get transaction verification transaction/message\n */\nexport const useTransactionGetTransactionVerificationMessageForNetwork = <\n  TError = StakeKitErrorDto | GeolocationError,\n  TContext = unknown,\n>(options?: {\n  mutation?: UseMutationOptions<\n    Awaited<\n      ReturnType<typeof transactionGetTransactionVerificationMessageForNetwork>\n    >,\n    TError,\n    { network: string; data: TransactionVerificationMessageRequestDto },\n    TContext\n  >;\n}) => {\n  const mutationOptions =\n    getTransactionGetTransactionVerificationMessageForNetworkMutationOptions(\n      options,\n    );\n\n  return useMutation(mutationOptions);\n};\n\n/**\n * Returns the tokens with available yields\n * @summary Get all tokens\n */\nexport const tokenGetTokens = (\n  params?: TokenGetTokensParams,\n  signal?: AbortSignal,\n) => {\n  return customFetch<TokenWithAvailableYieldsDto[]>({\n    url: `/v1/tokens`,\n    method: 'GET',\n    params,\n    signal,\n  });\n};\n\nexport const getTokenGetTokensQueryKey = (params?: TokenGetTokensParams) => {\n  return [`/v1/tokens`, ...(params ? [params] : [])] as const;\n};\n\nexport const getTokenGetTokensQueryOptions = <\n  TData = Awaited<ReturnType<typeof tokenGetTokens>>,\n  TError = StakeKitErrorDto,\n>(\n  params?: TokenGetTokensParams,\n  options?: {\n    query?: Partial<\n      UseQueryOptions<Awaited<ReturnType<typeof tokenGetTokens>>, TError, TData>\n    >;\n  },\n) => {\n  const { query: queryOptions } = options ?? {};\n\n  const queryKey = queryOptions?.queryKey ?? getTokenGetTokensQueryKey(params);\n\n  const queryFn: QueryFunction<Awaited<ReturnType<typeof tokenGetTokens>>> = ({\n    signal,\n  }) => tokenGetTokens(params, signal);\n\n  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<\n    Awaited<ReturnType<typeof tokenGetTokens>>,\n    TError,\n    TData\n  > & { queryKey: QueryKey };\n};\n\nexport type TokenGetTokensQueryResult = NonNullable<\n  Awaited<ReturnType<typeof tokenGetTokens>>\n>;\nexport type TokenGetTokensQueryError = StakeKitErrorDto;\n\n/**\n * @summary Get all tokens\n */\nexport const useTokenGetTokens = <\n  TData = Awaited<ReturnType<typeof tokenGetTokens>>,\n  TError = StakeKitErrorDto,\n>(\n  params?: TokenGetTokensParams,\n  options?: {\n    query?: Partial<\n      UseQueryOptions<Awaited<ReturnType<typeof tokenGetTokens>>, TError, TData>\n    >;\n  },\n): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {\n  const queryOptions = getTokenGetTokensQueryOptions(params, options);\n\n  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {\n    queryKey: QueryKey;\n  };\n\n  query.queryKey = queryOptions.queryKey;\n\n  return query;\n};\n\n/**\n * Returns the token prices for a specific list of tokens\n * @summary Get token prices\n */\nexport const tokenGetTokenPrices = (priceRequestDto: PriceRequestDto) => {\n  return customFetch<PriceResponseDto>({\n    url: `/v1/tokens/prices`,\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    data: priceRequestDto,\n  });\n};\n\nexport const getTokenGetTokenPricesQueryKey = (\n  priceRequestDto: PriceRequestDto,\n) => {\n  return [`/v1/tokens/prices`, priceRequestDto] as const;\n};\n\nexport const getTokenGetTokenPricesQueryOptions = <\n  TData = Awaited<ReturnType<typeof tokenGetTokenPrices>>,\n  TError = StakeKitErrorDto,\n>(\n  priceRequestDto: PriceRequestDto,\n  options?: {\n    query?: Partial<\n      UseQueryOptions<\n        Awaited<ReturnType<typeof tokenGetTokenPrices>>,\n        TError,\n        TData\n      >\n    >;\n  },\n) => {\n  const { query: queryOptions } = options ?? {};\n\n  const queryKey =\n    queryOptions?.queryKey ?? getTokenGetTokenPricesQueryKey(priceRequestDto);\n\n  const queryFn: QueryFunction<\n    Awaited<ReturnType<typeof tokenGetTokenPrices>>\n  > = () => tokenGetTokenPrices(priceRequestDto);\n\n  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<\n    Awaited<ReturnType<typeof tokenGetTokenPrices>>,\n    TError,\n    TData\n  > & { queryKey: QueryKey };\n};\n\nexport type TokenGetTokenPricesQueryResult = NonNullable<\n  Awaited<ReturnType<typeof tokenGetTokenPrices>>\n>;\nexport type TokenGetTokenPricesQueryError = StakeKitErrorDto;\n\n/**\n * @summary Get token prices\n */\nexport const useTokenGetTokenPrices = <\n  TData = Awaited<ReturnType<typeof tokenGetTokenPrices>>,\n  TError = StakeKitErrorDto,\n>(\n  priceRequestDto: PriceRequestDto,\n  options?: {\n    query?: Partial<\n      UseQueryOptions<\n        Awaited<ReturnType<typeof tokenGetTokenPrices>>,\n        TError,\n        TData\n      >\n    >;\n  },\n): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {\n  const queryOptions = getTokenGetTokenPricesQueryOptions(\n    priceRequestDto,\n    options,\n  );\n\n  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {\n    queryKey: QueryKey;\n  };\n\n  query.queryKey = queryOptions.queryKey;\n\n  return query;\n};\n\n/**\n * Returns the balances for specific addresses and token addresses\n * @summary Get token balances\n */\nexport const tokenGetTokenBalances = (\n  balancesRequestDto: BalancesRequestDto,\n) => {\n  return customFetch<BalanceResponseDto[]>({\n    url: `/v1/tokens/balances`,\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    data: balancesRequestDto,\n  });\n};\n\nexport const getTokenGetTokenBalancesQueryKey = (\n  balancesRequestDto: BalancesRequestDto,\n) => {\n  return [`/v1/tokens/balances`, balancesRequestDto] as const;\n};\n\nexport const getTokenGetTokenBalancesQueryOptions = <\n  TData = Awaited<ReturnType<typeof tokenGetTokenBalances>>,\n  TError = StakeKitErrorDto,\n>(\n  balancesRequestDto: BalancesRequestDto,\n  options?: {\n    query?: Partial<\n      UseQueryOptions<\n        Awaited<ReturnType<typeof tokenGetTokenBalances>>,\n        TError,\n        TData\n      >\n    >;\n  },\n) => {\n  const { query: queryOptions } = options ?? {};\n\n  const queryKey =\n    queryOptions?.queryKey ??\n    getTokenGetTokenBalancesQueryKey(balancesRequestDto);\n\n  const queryFn: QueryFunction<\n    Awaited<ReturnType<typeof tokenGetTokenBalances>>\n  > = () => tokenGetTokenBalances(balancesRequestDto);\n\n  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<\n    Awaited<ReturnType<typeof tokenGetTokenBalances>>,\n    TError,\n    TData\n  > & { queryKey: QueryKey };\n};\n\nexport type TokenGetTokenBalancesQueryResult = NonNullable<\n  Awaited<ReturnType<typeof tokenGetTokenBalances>>\n>;\nexport type TokenGetTokenBalancesQueryError = StakeKitErrorDto;\n\n/**\n * @summary Get token balances\n */\nexport const useTokenGetTokenBalances = <\n  TData = Awaited<ReturnType<typeof tokenGetTokenBalances>>,\n  TError = StakeKitErrorDto,\n>(\n  balancesRequestDto: BalancesRequestDto,\n  options?: {\n    query?: Partial<\n      UseQueryOptions<\n        Awaited<ReturnType<typeof tokenGetTokenBalances>>,\n        TError,\n        TData\n      >\n    >;\n  },\n): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {\n  const queryOptions = getTokenGetTokenBalancesQueryOptions(\n    balancesRequestDto,\n    options,\n  );\n\n  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {\n    queryKey: QueryKey;\n  };\n\n  query.queryKey = queryOptions.queryKey;\n\n  return query;\n};\n\n/**\n * Scans for tokens with balance with available yields\n * @summary Scan for token balances\n */\nexport const tokenTokenBalancesScan = (\n  tokenBalanceScanDto: TokenBalanceScanDto,\n) => {\n  return customFetch<TokenBalanceScanResponseDto[]>({\n    url: `/v1/tokens/balances/scan`,\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    data: tokenBalanceScanDto,\n  });\n};\n\nexport const getTokenTokenBalancesScanQueryKey = (\n  tokenBalanceScanDto: TokenBalanceScanDto,\n) => {\n  return [`/v1/tokens/balances/scan`, tokenBalanceScanDto] as const;\n};\n\nexport const getTokenTokenBalancesScanQueryOptions = <\n  TData = Awaited<ReturnType<typeof tokenTokenBalancesScan>>,\n  TError = StakeKitErrorDto,\n>(\n  tokenBalanceScanDto: TokenBalanceScanDto,\n  options?: {\n    query?: Partial<\n      UseQueryOptions<\n        Awaited<ReturnType<typeof tokenTokenBalancesScan>>,\n        TError,\n        TData\n      >\n    >;\n  },\n) => {\n  const { query: queryOptions } = options ?? {};\n\n  const queryKey =\n    queryOptions?.queryKey ??\n    getTokenTokenBalancesScanQueryKey(tokenBalanceScanDto);\n\n  const queryFn: QueryFunction<\n    Awaited<ReturnType<typeof tokenTokenBalancesScan>>\n  > = () => tokenTokenBalancesScan(tokenBalanceScanDto);\n\n  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<\n    Awaited<ReturnType<typeof tokenTokenBalancesScan>>,\n    TError,\n    TData\n  > & { queryKey: QueryKey };\n};\n\nexport type TokenTokenBalancesScanQueryResult = NonNullable<\n  Awaited<ReturnType<typeof tokenTokenBalancesScan>>\n>;\nexport type TokenTokenBalancesScanQueryError = StakeKitErrorDto;\n\n/**\n * @summary Scan for token balances\n */\nexport const useTokenTokenBalancesScan = <\n  TData = Awaited<ReturnType<typeof tokenTokenBalancesScan>>,\n  TError = StakeKitErrorDto,\n>(\n  tokenBalanceScanDto: TokenBalanceScanDto,\n  options?: {\n    query?: Partial<\n      UseQueryOptions<\n        Awaited<ReturnType<typeof tokenTokenBalancesScan>>,\n        TError,\n        TData\n      >\n    >;\n  },\n): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {\n  const queryOptions = getTokenTokenBalancesScanQueryOptions(\n    tokenBalanceScanDto,\n    options,\n  );\n\n  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {\n    queryKey: QueryKey;\n  };\n\n  query.queryKey = queryOptions.queryKey;\n\n  return query;\n};\n\n/**\n * Returns the available yields (staking, lending, vaults, etc) with associated configuration and metadata\n * @summary Get all yields\n */\nexport const yieldYields = (\n  params?: YieldYieldsParams,\n  signal?: AbortSignal,\n) => {\n  return customFetch<YieldYields200>({\n    url: `/v1/yields`,\n    method: 'GET',\n    params,\n    signal,\n  });\n};\n\nexport const getYieldYieldsQueryKey = (params?: YieldYieldsParams) => {\n  return [`/v1/yields`, ...(params ? [params] : [])] as const;\n};\n\nexport const getYieldYieldsQueryOptions = <\n  TData = Awaited<ReturnType<typeof yieldYields>>,\n  TError = StakeKitErrorDto,\n>(\n  params?: YieldYieldsParams,\n  options?: {\n    query?: Partial<\n      UseQueryOptions<Awaited<ReturnType<typeof yieldYields>>, TError, TData>\n    >;\n  },\n) => {\n  const { query: queryOptions } = options ?? {};\n\n  const queryKey = queryOptions?.queryKey ?? getYieldYieldsQueryKey(params);\n\n  const queryFn: QueryFunction<Awaited<ReturnType<typeof yieldYields>>> = ({\n    signal,\n  }) => yieldYields(params, signal);\n\n  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<\n    Awaited<ReturnType<typeof yieldYields>>,\n    TError,\n    TData\n  > & { queryKey: QueryKey };\n};\n\nexport type YieldYieldsQueryResult = NonNullable<\n  Awaited<ReturnType<typeof yieldYields>>\n>;\nexport type YieldYieldsQueryError = StakeKitErrorDto;\n\n/**\n * @summary Get all yields\n */\nexport const useYieldYields = <\n  TData = Awaited<ReturnType<typeof yieldYields>>,\n  TError = StakeKitErrorDto,\n>(\n  params?: YieldYieldsParams,\n  options?: {\n    query?: Partial<\n      UseQueryOptions<Awaited<ReturnType<typeof yieldYields>>, TError, TData>\n    >;\n  },\n): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {\n  const queryOptions = getYieldYieldsQueryOptions(params, options);\n\n  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {\n    queryKey: QueryKey;\n  };\n\n  query.queryKey = queryOptions.queryKey;\n\n  return query;\n};\n\n/**\n * Given addresses and integration ids, returns respective balances and configuration.\n * @summary Get multiple yield balances\n */\nexport const yieldGetMultipleYieldBalances = (\n  yieldBalanceWithIntegrationIdRequestDto: YieldBalanceWithIntegrationIdRequestDto[],\n) => {\n  return customFetch<YieldBalancesWithIntegrationIdDto[]>({\n    url: `/v1/yields/balances`,\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    data: yieldBalanceWithIntegrationIdRequestDto,\n  });\n};\n\nexport const getYieldGetMultipleYieldBalancesQueryKey = (\n  yieldBalanceWithIntegrationIdRequestDto: YieldBalanceWithIntegrationIdRequestDto[],\n) => {\n  return [\n    `/v1/yields/balances`,\n    yieldBalanceWithIntegrationIdRequestDto,\n  ] as const;\n};\n\nexport const getYieldGetMultipleYieldBalancesQueryOptions = <\n  TData = Awaited<ReturnType<typeof yieldGetMultipleYieldBalances>>,\n  TError = StakeKitErrorDto,\n>(\n  yieldBalanceWithIntegrationIdRequestDto: YieldBalanceWithIntegrationIdRequestDto[],\n  options?: {\n    query?: Partial<\n      UseQueryOptions<\n        Awaited<ReturnType<typeof yieldGetMultipleYieldBalances>>,\n        TError,\n        TData\n      >\n    >;\n  },\n) => {\n  const { query: queryOptions } = options ?? {};\n\n  const queryKey =\n    queryOptions?.queryKey ??\n    getYieldGetMultipleYieldBalancesQueryKey(\n      yieldBalanceWithIntegrationIdRequestDto,\n    );\n\n  const queryFn: QueryFunction<\n    Awaited<ReturnType<typeof yieldGetMultipleYieldBalances>>\n  > = () =>\n    yieldGetMultipleYieldBalances(yieldBalanceWithIntegrationIdRequestDto);\n\n  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<\n    Awaited<ReturnType<typeof yieldGetMultipleYieldBalances>>,\n    TError,\n    TData\n  > & { queryKey: QueryKey };\n};\n\nexport type YieldGetMultipleYieldBalancesQueryResult = NonNullable<\n  Awaited<ReturnType<typeof yieldGetMultipleYieldBalances>>\n>;\nexport type YieldGetMultipleYieldBalancesQueryError = StakeKitErrorDto;\n\n/**\n * @summary Get multiple yield balances\n */\nexport const useYieldGetMultipleYieldBalances = <\n  TData = Awaited<ReturnType<typeof yieldGetMultipleYieldBalances>>,\n  TError = StakeKitErrorDto,\n>(\n  yieldBalanceWithIntegrationIdRequestDto: YieldBalanceWithIntegrationIdRequestDto[],\n  options?: {\n    query?: Partial<\n      UseQueryOptions<\n        Awaited<ReturnType<typeof yieldGetMultipleYieldBalances>>,\n        TError,\n        TData\n      >\n    >;\n  },\n): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {\n  const queryOptions = getYieldGetMultipleYieldBalancesQueryOptions(\n    yieldBalanceWithIntegrationIdRequestDto,\n    options,\n  );\n\n  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {\n    queryKey: QueryKey;\n  };\n\n  query.queryKey = queryOptions.queryKey;\n\n  return query;\n};\n\n/**\n * Scans for yield balances among enabled yields.\n * @summary Scan for yield balances\n */\nexport const yieldYieldBalancesScan = (\n  yieldBalanceScanRequestDto: YieldBalanceScanRequestDto,\n) => {\n  return customFetch<YieldBalancesWithIntegrationIdDto[]>({\n    url: `/v1/yields/balances/scan`,\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    data: yieldBalanceScanRequestDto,\n  });\n};\n\nexport const getYieldYieldBalancesScanQueryKey = (\n  yieldBalanceScanRequestDto: YieldBalanceScanRequestDto,\n) => {\n  return [`/v1/yields/balances/scan`, yieldBalanceScanRequestDto] as const;\n};\n\nexport const getYieldYieldBalancesScanQueryOptions = <\n  TData = Awaited<ReturnType<typeof yieldYieldBalancesScan>>,\n  TError = StakeKitErrorDto,\n>(\n  yieldBalanceScanRequestDto: YieldBalanceScanRequestDto,\n  options?: {\n    query?: Partial<\n      UseQueryOptions<\n        Awaited<ReturnType<typeof yieldYieldBalancesScan>>,\n        TError,\n        TData\n      >\n    >;\n  },\n) => {\n  const { query: queryOptions } = options ?? {};\n\n  const queryKey =\n    queryOptions?.queryKey ??\n    getYieldYieldBalancesScanQueryKey(yieldBalanceScanRequestDto);\n\n  const queryFn: QueryFunction<\n    Awaited<ReturnType<typeof yieldYieldBalancesScan>>\n  > = () => yieldYieldBalancesScan(yieldBalanceScanRequestDto);\n\n  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<\n    Awaited<ReturnType<typeof yieldYieldBalancesScan>>,\n    TError,\n    TData\n  > & { queryKey: QueryKey };\n};\n\nexport type YieldYieldBalancesScanQueryResult = NonNullable<\n  Awaited<ReturnType<typeof yieldYieldBalancesScan>>\n>;\nexport type YieldYieldBalancesScanQueryError = StakeKitErrorDto;\n\n/**\n * @summary Scan for yield balances\n */\nexport const useYieldYieldBalancesScan = <\n  TData = Awaited<ReturnType<typeof yieldYieldBalancesScan>>,\n  TError = StakeKitErrorDto,\n>(\n  yieldBalanceScanRequestDto: YieldBalanceScanRequestDto,\n  options?: {\n    query?: Partial<\n      UseQueryOptions<\n        Awaited<ReturnType<typeof yieldYieldBalancesScan>>,\n        TError,\n        TData\n      >\n    >;\n  },\n): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {\n  const queryOptions = getYieldYieldBalancesScanQueryOptions(\n    yieldBalanceScanRequestDto,\n    options,\n  );\n\n  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {\n    queryKey: QueryKey;\n  };\n\n  query.queryKey = queryOptions.queryKey;\n\n  return query;\n};\n\n/**\n * Scans for all EVM yield balances among enabled yields.\n * @summary Scan for all EVM yield balances\n */\nexport const yieldYieldBalancesScanEvm = (\n  yieldBalanceScanEvmRequestDto: YieldBalanceScanEvmRequestDto,\n) => {\n  return customFetch<YieldBalancesWithIntegrationIdDto[]>({\n    url: `/v1/yields/balances/scan/evm`,\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    data: yieldBalanceScanEvmRequestDto,\n  });\n};\n\nexport const getYieldYieldBalancesScanEvmMutationOptions = <\n  TError = StakeKitErrorDto,\n  TContext = unknown,\n>(options?: {\n  mutation?: UseMutationOptions<\n    Awaited<ReturnType<typeof yieldYieldBalancesScanEvm>>,\n    TError,\n    { data: YieldBalanceScanEvmRequestDto },\n    TContext\n  >;\n}): UseMutationOptions<\n  Awaited<ReturnType<typeof yieldYieldBalancesScanEvm>>,\n  TError,\n  { data: YieldBalanceScanEvmRequestDto },\n  TContext\n> => {\n  const { mutation: mutationOptions } = options ?? {};\n\n  const mutationFn: MutationFunction<\n    Awaited<ReturnType<typeof yieldYieldBalancesScanEvm>>,\n    { data: YieldBalanceScanEvmRequestDto }\n  > = (props) => {\n    const { data } = props ?? {};\n\n    return yieldYieldBalancesScanEvm(data);\n  };\n\n  return { mutationFn, ...mutationOptions };\n};\n\nexport type YieldYieldBalancesScanEvmMutationResult = NonNullable<\n  Awaited<ReturnType<typeof yieldYieldBalancesScanEvm>>\n>;\nexport type YieldYieldBalancesScanEvmMutationBody =\n  YieldBalanceScanEvmRequestDto;\nexport type YieldYieldBalancesScanEvmMutationError = StakeKitErrorDto;\n\n/**\n * @summary Scan for all EVM yield balances\n */\nexport const useYieldYieldBalancesScanEvm = <\n  TError = StakeKitErrorDto,\n  TContext = unknown,\n>(options?: {\n  mutation?: UseMutationOptions<\n    Awaited<ReturnType<typeof yieldYieldBalancesScanEvm>>,\n    TError,\n    { data: YieldBalanceScanEvmRequestDto },\n    TContext\n  >;\n}) => {\n  const mutationOptions = getYieldYieldBalancesScanEvmMutationOptions(options);\n\n  return useMutation(mutationOptions);\n};\n\n/**\n * Returns the enabled yields (staking, lending, vaults, etc) associated with current API key with configuration and metadata\n * @summary Get enabled yields\n */\nexport const yieldGetMyYields = (\n  params?: YieldGetMyYieldsParams,\n  signal?: AbortSignal,\n) => {\n  return customFetch<YieldGetMyYields200>({\n    url: `/v1/yields/enabled`,\n    method: 'GET',\n    params,\n    signal,\n  });\n};\n\nexport const getYieldGetMyYieldsQueryKey = (\n  params?: YieldGetMyYieldsParams,\n) => {\n  return [`/v1/yields/enabled`, ...(params ? [params] : [])] as const;\n};\n\nexport const getYieldGetMyYieldsQueryOptions = <\n  TData = Awaited<ReturnType<typeof yieldGetMyYields>>,\n  TError = StakeKitErrorDto,\n>(\n  params?: YieldGetMyYieldsParams,\n  options?: {\n    query?: Partial<\n      UseQueryOptions<\n        Awaited<ReturnType<typeof yieldGetMyYields>>,\n        TError,\n        TData\n      >\n    >;\n  },\n) => {\n  const { query: queryOptions } = options ?? {};\n\n  const queryKey =\n    queryOptions?.queryKey ?? getYieldGetMyYieldsQueryKey(params);\n\n  const queryFn: QueryFunction<\n    Awaited<ReturnType<typeof yieldGetMyYields>>\n  > = ({ signal }) => yieldGetMyYields(params, signal);\n\n  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<\n    Awaited<ReturnType<typeof yieldGetMyYields>>,\n    TError,\n    TData\n  > & { queryKey: QueryKey };\n};\n\nexport type YieldGetMyYieldsQueryResult = NonNullable<\n  Awaited<ReturnType<typeof yieldGetMyYields>>\n>;\nexport type YieldGetMyYieldsQueryError = StakeKitErrorDto;\n\n/**\n * @summary Get enabled yields\n */\nexport const useYieldGetMyYields = <\n  TData = Awaited<ReturnType<typeof yieldGetMyYields>>,\n  TError = StakeKitErrorDto,\n>(\n  params?: YieldGetMyYieldsParams,\n  options?: {\n    query?: Partial<\n      UseQueryOptions<\n        Awaited<ReturnType<typeof yieldGetMyYields>>,\n        TError,\n        TData\n      >\n    >;\n  },\n): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {\n  const queryOptions = getYieldGetMyYieldsQueryOptions(params, options);\n\n  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {\n    queryKey: QueryKey;\n  };\n\n  query.queryKey = queryOptions.queryKey;\n\n  return query;\n};\n\n/**\n * Returns the networks that has enabled yields\n * @summary Get enabled networks\n */\nexport const yieldGetMyNetworks = (signal?: AbortSignal) => {\n  return customFetch<string[]>({\n    url: `/v1/yields/enabled/networks`,\n    method: 'GET',\n    signal,\n  });\n};\n\nexport const getYieldGetMyNetworksQueryKey = () => {\n  return [`/v1/yields/enabled/networks`] as const;\n};\n\nexport const getYieldGetMyNetworksQueryOptions = <\n  TData = Awaited<ReturnType<typeof yieldGetMyNetworks>>,\n  TError = StakeKitErrorDto | string[],\n>(options?: {\n  query?: Partial<\n    UseQueryOptions<\n      Awaited<ReturnType<typeof yieldGetMyNetworks>>,\n      TError,\n      TData\n    >\n  >;\n}) => {\n  const { query: queryOptions } = options ?? {};\n\n  const queryKey = queryOptions?.queryKey ?? getYieldGetMyNetworksQueryKey();\n\n  const queryFn: QueryFunction<\n    Awaited<ReturnType<typeof yieldGetMyNetworks>>\n  > = ({ signal }) => yieldGetMyNetworks(signal);\n\n  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<\n    Awaited<ReturnType<typeof yieldGetMyNetworks>>,\n    TError,\n    TData\n  > & { queryKey: QueryKey };\n};\n\nexport type YieldGetMyNetworksQueryResult = NonNullable<\n  Awaited<ReturnType<typeof yieldGetMyNetworks>>\n>;\nexport type YieldGetMyNetworksQueryError = StakeKitErrorDto | string[];\n\n/**\n * @summary Get enabled networks\n */\nexport const useYieldGetMyNetworks = <\n  TData = Awaited<ReturnType<typeof yieldGetMyNetworks>>,\n  TError = StakeKitErrorDto | string[],\n>(options?: {\n  query?: Partial<\n    UseQueryOptions<\n      Awaited<ReturnType<typeof yieldGetMyNetworks>>,\n      TError,\n      TData\n    >\n  >;\n}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {\n  const queryOptions = getYieldGetMyNetworksQueryOptions(options);\n\n  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {\n    queryKey: QueryKey;\n  };\n\n  query.queryKey = queryOptions.queryKey;\n\n  return query;\n};\n\n/**\n * Returns a list of available validators to specify when providing a `validatorAddress` property.\n * @summary Get validators\n */\nexport const yieldFindValidators = (\n  params?: YieldFindValidatorsParams,\n  signal?: AbortSignal,\n) => {\n  return customFetch<ValidatorSearchResultDto[]>({\n    url: `/v1/yields/validators`,\n    method: 'GET',\n    params,\n    signal,\n  });\n};\n\nexport const getYieldFindValidatorsQueryKey = (\n  params?: YieldFindValidatorsParams,\n) => {\n  return [`/v1/yields/validators`, ...(params ? [params] : [])] as const;\n};\n\nexport const getYieldFindValidatorsQueryOptions = <\n  TData = Awaited<ReturnType<typeof yieldFindValidators>>,\n  TError = StakeKitErrorDto,\n>(\n  params?: YieldFindValidatorsParams,\n  options?: {\n    query?: Partial<\n      UseQueryOptions<\n        Awaited<ReturnType<typeof yieldFindValidators>>,\n        TError,\n        TData\n      >\n    >;\n  },\n) => {\n  const { query: queryOptions } = options ?? {};\n\n  const queryKey =\n    queryOptions?.queryKey ?? getYieldFindValidatorsQueryKey(params);\n\n  const queryFn: QueryFunction<\n    Awaited<ReturnType<typeof yieldFindValidators>>\n  > = ({ signal }) => yieldFindValidators(params, signal);\n\n  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<\n    Awaited<ReturnType<typeof yieldFindValidators>>,\n    TError,\n    TData\n  > & { queryKey: QueryKey };\n};\n\nexport type YieldFindValidatorsQueryResult = NonNullable<\n  Awaited<ReturnType<typeof yieldFindValidators>>\n>;\nexport type YieldFindValidatorsQueryError = StakeKitErrorDto;\n\n/**\n * @summary Get validators\n */\nexport const useYieldFindValidators = <\n  TData = Awaited<ReturnType<typeof yieldFindValidators>>,\n  TError = StakeKitErrorDto,\n>(\n  params?: YieldFindValidatorsParams,\n  options?: {\n    query?: Partial<\n      UseQueryOptions<\n        Awaited<ReturnType<typeof yieldFindValidators>>,\n        TError,\n        TData\n      >\n    >;\n  },\n): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {\n  const queryOptions = getYieldFindValidatorsQueryOptions(params, options);\n\n  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {\n    queryKey: QueryKey;\n  };\n\n  query.queryKey = queryOptions.queryKey;\n\n  return query;\n};\n\n/**\n * Returns a yield that is associated with given integration ID\n * @summary Get a yield given an integration ID\n */\nexport const yieldYieldOpportunity = (\n  integrationId: string,\n  params?: YieldYieldOpportunityParams,\n  signal?: AbortSignal,\n) => {\n  return customFetch<YieldDto>({\n    url: `/v1/yields/${integrationId}`,\n    method: 'GET',\n    params,\n    signal,\n  });\n};\n\nexport const getYieldYieldOpportunityQueryKey = (\n  integrationId: string,\n  params?: YieldYieldOpportunityParams,\n) => {\n  return [`/v1/yields/${integrationId}`, ...(params ? [params] : [])] as const;\n};\n\nexport const getYieldYieldOpportunityQueryOptions = <\n  TData = Awaited<ReturnType<typeof yieldYieldOpportunity>>,\n  TError = StakeKitErrorDto,\n>(\n  integrationId: string,\n  params?: YieldYieldOpportunityParams,\n  options?: {\n    query?: Partial<\n      UseQueryOptions<\n        Awaited<ReturnType<typeof yieldYieldOpportunity>>,\n        TError,\n        TData\n      >\n    >;\n  },\n) => {\n  const { query: queryOptions } = options ?? {};\n\n  const queryKey =\n    queryOptions?.queryKey ??\n    getYieldYieldOpportunityQueryKey(integrationId, params);\n\n  const queryFn: QueryFunction<\n    Awaited<ReturnType<typeof yieldYieldOpportunity>>\n  > = ({ signal }) => yieldYieldOpportunity(integrationId, params, signal);\n\n  return {\n    queryKey,\n    queryFn,\n    enabled: !!integrationId,\n    ...queryOptions,\n  } as UseQueryOptions<\n    Awaited<ReturnType<typeof yieldYieldOpportunity>>,\n    TError,\n    TData\n  > & { queryKey: QueryKey };\n};\n\nexport type YieldYieldOpportunityQueryResult = NonNullable<\n  Awaited<ReturnType<typeof yieldYieldOpportunity>>\n>;\nexport type YieldYieldOpportunityQueryError = StakeKitErrorDto;\n\n/**\n * @summary Get a yield given an integration ID\n */\nexport const useYieldYieldOpportunity = <\n  TData = Awaited<ReturnType<typeof yieldYieldOpportunity>>,\n  TError = StakeKitErrorDto,\n>(\n  integrationId: string,\n  params?: YieldYieldOpportunityParams,\n  options?: {\n    query?: Partial<\n      UseQueryOptions<\n        Awaited<ReturnType<typeof yieldYieldOpportunity>>,\n        TError,\n        TData\n      >\n    >;\n  },\n): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {\n  const queryOptions = getYieldYieldOpportunityQueryOptions(\n    integrationId,\n    params,\n    options,\n  );\n\n  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {\n    queryKey: QueryKey;\n  };\n\n  query.queryKey = queryOptions.queryKey;\n\n  return query;\n};\n\n/**\n * Returns a list of available validators to specify when providing a `validatorAddress` property.\n * @summary Get validators given an integration ID\n */\nexport const yieldGetValidators = (\n  integrationId: string,\n  params?: YieldGetValidatorsParams,\n  signal?: AbortSignal,\n) => {\n  return customFetch<ValidatorDto[]>({\n    url: `/v1/yields/${integrationId}/validators`,\n    method: 'GET',\n    params,\n    signal,\n  });\n};\n\nexport const getYieldGetValidatorsQueryKey = (\n  integrationId: string,\n  params?: YieldGetValidatorsParams,\n) => {\n  return [\n    `/v1/yields/${integrationId}/validators`,\n    ...(params ? [params] : []),\n  ] as const;\n};\n\nexport const getYieldGetValidatorsQueryOptions = <\n  TData = Awaited<ReturnType<typeof yieldGetValidators>>,\n  TError = StakeKitErrorDto,\n>(\n  integrationId: string,\n  params?: YieldGetValidatorsParams,\n  options?: {\n    query?: Partial<\n      UseQueryOptions<\n        Awaited<ReturnType<typeof yieldGetValidators>>,\n        TError,\n        TData\n      >\n    >;\n  },\n) => {\n  const { query: queryOptions } = options ?? {};\n\n  const queryKey =\n    queryOptions?.queryKey ??\n    getYieldGetValidatorsQueryKey(integrationId, params);\n\n  const queryFn: QueryFunction<\n    Awaited<ReturnType<typeof yieldGetValidators>>\n  > = ({ signal }) => yieldGetValidators(integrationId, params, signal);\n\n  return {\n    queryKey,\n    queryFn,\n    enabled: !!integrationId,\n    ...queryOptions,\n  } as UseQueryOptions<\n    Awaited<ReturnType<typeof yieldGetValidators>>,\n    TError,\n    TData\n  > & { queryKey: QueryKey };\n};\n\nexport type YieldGetValidatorsQueryResult = NonNullable<\n  Awaited<ReturnType<typeof yieldGetValidators>>\n>;\nexport type YieldGetValidatorsQueryError = StakeKitErrorDto;\n\n/**\n * @summary Get validators given an integration ID\n */\nexport const useYieldGetValidators = <\n  TData = Awaited<ReturnType<typeof yieldGetValidators>>,\n  TError = StakeKitErrorDto,\n>(\n  integrationId: string,\n  params?: YieldGetValidatorsParams,\n  options?: {\n    query?: Partial<\n      UseQueryOptions<\n        Awaited<ReturnType<typeof yieldGetValidators>>,\n        TError,\n        TData\n      >\n    >;\n  },\n): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {\n  const queryOptions = getYieldGetValidatorsQueryOptions(\n    integrationId,\n    params,\n    options,\n  );\n\n  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {\n    queryKey: QueryKey;\n  };\n\n  query.queryKey = queryOptions.queryKey;\n\n  return query;\n};\n\n/**\n * Given addresses, returns the available, deposited balance, pending actions and associated configuration for any yield\n * @summary Get yield balances given an integration ID\n */\nexport const yieldGetSingleYieldBalances = (\n  integrationId: string,\n  yieldBalanceRequestDto: YieldBalanceRequestDto,\n  params?: YieldGetSingleYieldBalancesParams,\n) => {\n  return customFetch<YieldBalanceDto[]>({\n    url: `/v1/yields/${integrationId}/balances`,\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    data: yieldBalanceRequestDto,\n    params,\n  });\n};\n\nexport const getYieldGetSingleYieldBalancesQueryKey = (\n  integrationId: string,\n  yieldBalanceRequestDto: YieldBalanceRequestDto,\n  params?: YieldGetSingleYieldBalancesParams,\n) => {\n  return [\n    `/v1/yields/${integrationId}/balances`,\n    ...(params ? [params] : []),\n    yieldBalanceRequestDto,\n  ] as const;\n};\n\nexport const getYieldGetSingleYieldBalancesQueryOptions = <\n  TData = Awaited<ReturnType<typeof yieldGetSingleYieldBalances>>,\n  TError = StakeKitErrorDto,\n>(\n  integrationId: string,\n  yieldBalanceRequestDto: YieldBalanceRequestDto,\n  params?: YieldGetSingleYieldBalancesParams,\n  options?: {\n    query?: Partial<\n      UseQueryOptions<\n        Awaited<ReturnType<typeof yieldGetSingleYieldBalances>>,\n        TError,\n        TData\n      >\n    >;\n  },\n) => {\n  const { query: queryOptions } = options ?? {};\n\n  const queryKey =\n    queryOptions?.queryKey ??\n    getYieldGetSingleYieldBalancesQueryKey(\n      integrationId,\n      yieldBalanceRequestDto,\n      params,\n    );\n\n  const queryFn: QueryFunction<\n    Awaited<ReturnType<typeof yieldGetSingleYieldBalances>>\n  > = () =>\n    yieldGetSingleYieldBalances(integrationId, yieldBalanceRequestDto, params);\n\n  return {\n    queryKey,\n    queryFn,\n    enabled: !!integrationId,\n    ...queryOptions,\n  } as UseQueryOptions<\n    Awaited<ReturnType<typeof yieldGetSingleYieldBalances>>,\n    TError,\n    TData\n  > & { queryKey: QueryKey };\n};\n\nexport type YieldGetSingleYieldBalancesQueryResult = NonNullable<\n  Awaited<ReturnType<typeof yieldGetSingleYieldBalances>>\n>;\nexport type YieldGetSingleYieldBalancesQueryError = StakeKitErrorDto;\n\n/**\n * @summary Get yield balances given an integration ID\n */\nexport const useYieldGetSingleYieldBalances = <\n  TData = Awaited<ReturnType<typeof yieldGetSingleYieldBalances>>,\n  TError = StakeKitErrorDto,\n>(\n  integrationId: string,\n  yieldBalanceRequestDto: YieldBalanceRequestDto,\n  params?: YieldGetSingleYieldBalancesParams,\n  options?: {\n    query?: Partial<\n      UseQueryOptions<\n        Awaited<ReturnType<typeof yieldGetSingleYieldBalances>>,\n        TError,\n        TData\n      >\n    >;\n  },\n): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {\n  const queryOptions = getYieldGetSingleYieldBalancesQueryOptions(\n    integrationId,\n    yieldBalanceRequestDto,\n    params,\n    options,\n  );\n\n  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {\n    queryKey: QueryKey;\n  };\n\n  query.queryKey = queryOptions.queryKey;\n\n  return query;\n};\n\n/**\n * Given addresses, returns a historic rewards summary for any yield\n * @summary Get historic rewards summary given an integration ID\n */\nexport const yieldGetSingleYieldRewardsSummary = (\n  integrationId: string,\n  yieldRewardsSummaryRequestDto: YieldRewardsSummaryRequestDto,\n) => {\n  return customFetch<YieldRewardsSummaryResponseDto[]>({\n    url: `/v1/yields/${integrationId}/rewards-summary`,\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    data: yieldRewardsSummaryRequestDto,\n  });\n};\n\nexport const getYieldGetSingleYieldRewardsSummaryMutationOptions = <\n  TError = StakeKitErrorDto,\n  TContext = unknown,\n>(options?: {\n  mutation?: UseMutationOptions<\n    Awaited<ReturnType<typeof yieldGetSingleYieldRewardsSummary>>,\n    TError,\n    { integrationId: string; data: YieldRewardsSummaryRequestDto },\n    TContext\n  >;\n}): UseMutationOptions<\n  Awaited<ReturnType<typeof yieldGetSingleYieldRewardsSummary>>,\n  TError,\n  { integrationId: string; data: YieldRewardsSummaryRequestDto },\n  TContext\n> => {\n  const { mutation: mutationOptions } = options ?? {};\n\n  const mutationFn: MutationFunction<\n    Awaited<ReturnType<typeof yieldGetSingleYieldRewardsSummary>>,\n    { integrationId: string; data: YieldRewardsSummaryRequestDto }\n  > = (props) => {\n    const { integrationId, data } = props ?? {};\n\n    return yieldGetSingleYieldRewardsSummary(integrationId, data);\n  };\n\n  return { mutationFn, ...mutationOptions };\n};\n\nexport type YieldGetSingleYieldRewardsSummaryMutationResult = NonNullable<\n  Awaited<ReturnType<typeof yieldGetSingleYieldRewardsSummary>>\n>;\nexport type YieldGetSingleYieldRewardsSummaryMutationBody =\n  YieldRewardsSummaryRequestDto;\nexport type YieldGetSingleYieldRewardsSummaryMutationError = StakeKitErrorDto;\n\n/**\n * @summary Get historic rewards summary given an integration ID\n */\nexport const useYieldGetSingleYieldRewardsSummary = <\n  TError = StakeKitErrorDto,\n  TContext = unknown,\n>(options?: {\n  mutation?: UseMutationOptions<\n    Awaited<ReturnType<typeof yieldGetSingleYieldRewardsSummary>>,\n    TError,\n    { integrationId: string; data: YieldRewardsSummaryRequestDto },\n    TContext\n  >;\n}) => {\n  const mutationOptions =\n    getYieldGetSingleYieldRewardsSummaryMutationOptions(options);\n\n  return useMutation(mutationOptions);\n};\n\n/**\n * Returns a fee configuraion that contains details about fees taken when interacting with the yield.\n * @summary Get fee configuration given an integration ID\n */\nexport const yieldGetFeeConfiguration = (\n  integrationId: string,\n  signal?: AbortSignal,\n) => {\n  return customFetch<FeeConfigurationDto>({\n    url: `/v1/yields/${integrationId}/fee-configuration`,\n    method: 'GET',\n    signal,\n  });\n};\n\nexport const getYieldGetFeeConfigurationQueryKey = (integrationId: string) => {\n  return [`/v1/yields/${integrationId}/fee-configuration`] as const;\n};\n\nexport const getYieldGetFeeConfigurationQueryOptions = <\n  TData = Awaited<ReturnType<typeof yieldGetFeeConfiguration>>,\n  TError = StakeKitErrorDto | void,\n>(\n  integrationId: string,\n  options?: {\n    query?: Partial<\n      UseQueryOptions<\n        Awaited<ReturnType<typeof yieldGetFeeConfiguration>>,\n        TError,\n        TData\n      >\n    >;\n  },\n) => {\n  const { query: queryOptions } = options ?? {};\n\n  const queryKey =\n    queryOptions?.queryKey ??\n    getYieldGetFeeConfigurationQueryKey(integrationId);\n\n  const queryFn: QueryFunction<\n    Awaited<ReturnType<typeof yieldGetFeeConfiguration>>\n  > = ({ signal }) => yieldGetFeeConfiguration(integrationId, signal);\n\n  return {\n    queryKey,\n    queryFn,\n    enabled: !!integrationId,\n    ...queryOptions,\n  } as UseQueryOptions<\n    Awaited<ReturnType<typeof yieldGetFeeConfiguration>>,\n    TError,\n    TData\n  > & { queryKey: QueryKey };\n};\n\nexport type YieldGetFeeConfigurationQueryResult = NonNullable<\n  Awaited<ReturnType<typeof yieldGetFeeConfiguration>>\n>;\nexport type YieldGetFeeConfigurationQueryError = StakeKitErrorDto | void;\n\n/**\n * @summary Get fee configuration given an integration ID\n */\nexport const useYieldGetFeeConfiguration = <\n  TData = Awaited<ReturnType<typeof yieldGetFeeConfiguration>>,\n  TError = StakeKitErrorDto | void,\n>(\n  integrationId: string,\n  options?: {\n    query?: Partial<\n      UseQueryOptions<\n        Awaited<ReturnType<typeof yieldGetFeeConfiguration>>,\n        TError,\n        TData\n      >\n    >;\n  },\n): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {\n  const queryOptions = getYieldGetFeeConfigurationQueryOptions(\n    integrationId,\n    options,\n  );\n\n  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {\n    queryKey: QueryKey;\n  };\n\n  query.queryKey = queryOptions.queryKey;\n\n  return query;\n};\n\n/**\n * Returns the available yields (staking, lending, vaults, etc) with associated configuration and metadata\n * @summary Get all yields\n */\nexport const yieldV2Yields = (\n  params?: YieldV2YieldsParams,\n  signal?: AbortSignal,\n) => {\n  return customFetch<YieldV2Yields200>({\n    url: `/v2/yields`,\n    method: 'GET',\n    params,\n    signal,\n  });\n};\n\nexport const getYieldV2YieldsQueryKey = (params?: YieldV2YieldsParams) => {\n  return [`/v2/yields`, ...(params ? [params] : [])] as const;\n};\n\nexport const getYieldV2YieldsQueryOptions = <\n  TData = Awaited<ReturnType<typeof yieldV2Yields>>,\n  TError = StakeKitErrorDto,\n>(\n  params?: YieldV2YieldsParams,\n  options?: {\n    query?: Partial<\n      UseQueryOptions<Awaited<ReturnType<typeof yieldV2Yields>>, TError, TData>\n    >;\n  },\n) => {\n  const { query: queryOptions } = options ?? {};\n\n  const queryKey = queryOptions?.queryKey ?? getYieldV2YieldsQueryKey(params);\n\n  const queryFn: QueryFunction<Awaited<ReturnType<typeof yieldV2Yields>>> = ({\n    signal,\n  }) => yieldV2Yields(params, signal);\n\n  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<\n    Awaited<ReturnType<typeof yieldV2Yields>>,\n    TError,\n    TData\n  > & { queryKey: QueryKey };\n};\n\nexport type YieldV2YieldsQueryResult = NonNullable<\n  Awaited<ReturnType<typeof yieldV2Yields>>\n>;\nexport type YieldV2YieldsQueryError = StakeKitErrorDto;\n\n/**\n * @summary Get all yields\n */\nexport const useYieldV2Yields = <\n  TData = Awaited<ReturnType<typeof yieldV2Yields>>,\n  TError = StakeKitErrorDto,\n>(\n  params?: YieldV2YieldsParams,\n  options?: {\n    query?: Partial<\n      UseQueryOptions<Awaited<ReturnType<typeof yieldV2Yields>>, TError, TData>\n    >;\n  },\n): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {\n  const queryOptions = getYieldV2YieldsQueryOptions(params, options);\n\n  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {\n    queryKey: QueryKey;\n  };\n\n  query.queryKey = queryOptions.queryKey;\n\n  return query;\n};\n\n/**\n * Returns yield given an id\n * @summary Get yield\n */\nexport const yieldV2GetYieldById = (yieldId: string, signal?: AbortSignal) => {\n  return customFetch<YieldDto>({\n    url: `/v2/yields/${yieldId}`,\n    method: 'GET',\n    signal,\n  });\n};\n\nexport const getYieldV2GetYieldByIdQueryKey = (yieldId: string) => {\n  return [`/v2/yields/${yieldId}`] as const;\n};\n\nexport const getYieldV2GetYieldByIdQueryOptions = <\n  TData = Awaited<ReturnType<typeof yieldV2GetYieldById>>,\n  TError = StakeKitErrorDto,\n>(\n  yieldId: string,\n  options?: {\n    query?: Partial<\n      UseQueryOptions<\n        Awaited<ReturnType<typeof yieldV2GetYieldById>>,\n        TError,\n        TData\n      >\n    >;\n  },\n) => {\n  const { query: queryOptions } = options ?? {};\n\n  const queryKey =\n    queryOptions?.queryKey ?? getYieldV2GetYieldByIdQueryKey(yieldId);\n\n  const queryFn: QueryFunction<\n    Awaited<ReturnType<typeof yieldV2GetYieldById>>\n  > = ({ signal }) => yieldV2GetYieldById(yieldId, signal);\n\n  return {\n    queryKey,\n    queryFn,\n    enabled: !!yieldId,\n    ...queryOptions,\n  } as UseQueryOptions<\n    Awaited<ReturnType<typeof yieldV2GetYieldById>>,\n    TError,\n    TData\n  > & { queryKey: QueryKey };\n};\n\nexport type YieldV2GetYieldByIdQueryResult = NonNullable<\n  Awaited<ReturnType<typeof yieldV2GetYieldById>>\n>;\nexport type YieldV2GetYieldByIdQueryError = StakeKitErrorDto;\n\n/**\n * @summary Get yield\n */\nexport const useYieldV2GetYieldById = <\n  TData = Awaited<ReturnType<typeof yieldV2GetYieldById>>,\n  TError = StakeKitErrorDto,\n>(\n  yieldId: string,\n  options?: {\n    query?: Partial<\n      UseQueryOptions<\n        Awaited<ReturnType<typeof yieldV2GetYieldById>>,\n        TError,\n        TData\n      >\n    >;\n  },\n): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {\n  const queryOptions = getYieldV2GetYieldByIdQueryOptions(yieldId, options);\n\n  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {\n    queryKey: QueryKey;\n  };\n\n  query.queryKey = queryOptions.queryKey;\n\n  return query;\n};\n\n/**\n * Given a yield, returns a list of available validators to specify when providing a `validatorAddress` property.\n * @summary Get yield validators\n */\nexport const yieldV2FindYieldValidators = (\n  yieldId: string,\n  params?: YieldV2FindYieldValidatorsParams,\n  signal?: AbortSignal,\n) => {\n  return customFetch<ValidatorSearchResultDto[]>({\n    url: `/v2/yields/${yieldId}/validators`,\n    method: 'GET',\n    params,\n    signal,\n  });\n};\n\nexport const getYieldV2FindYieldValidatorsQueryKey = (\n  yieldId: string,\n  params?: YieldV2FindYieldValidatorsParams,\n) => {\n  return [\n    `/v2/yields/${yieldId}/validators`,\n    ...(params ? [params] : []),\n  ] as const;\n};\n\nexport const getYieldV2FindYieldValidatorsQueryOptions = <\n  TData = Awaited<ReturnType<typeof yieldV2FindYieldValidators>>,\n  TError = StakeKitErrorDto,\n>(\n  yieldId: string,\n  params?: YieldV2FindYieldValidatorsParams,\n  options?: {\n    query?: Partial<\n      UseQueryOptions<\n        Awaited<ReturnType<typeof yieldV2FindYieldValidators>>,\n        TError,\n        TData\n      >\n    >;\n  },\n) => {\n  const { query: queryOptions } = options ?? {};\n\n  const queryKey =\n    queryOptions?.queryKey ??\n    getYieldV2FindYieldValidatorsQueryKey(yieldId, params);\n\n  const queryFn: QueryFunction<\n    Awaited<ReturnType<typeof yieldV2FindYieldValidators>>\n  > = ({ signal }) => yieldV2FindYieldValidators(yieldId, params, signal);\n\n  return {\n    queryKey,\n    queryFn,\n    enabled: !!yieldId,\n    ...queryOptions,\n  } as UseQueryOptions<\n    Awaited<ReturnType<typeof yieldV2FindYieldValidators>>,\n    TError,\n    TData\n  > & { queryKey: QueryKey };\n};\n\nexport type YieldV2FindYieldValidatorsQueryResult = NonNullable<\n  Awaited<ReturnType<typeof yieldV2FindYieldValidators>>\n>;\nexport type YieldV2FindYieldValidatorsQueryError = StakeKitErrorDto;\n\n/**\n * @summary Get yield validators\n */\nexport const useYieldV2FindYieldValidators = <\n  TData = Awaited<ReturnType<typeof yieldV2FindYieldValidators>>,\n  TError = StakeKitErrorDto,\n>(\n  yieldId: string,\n  params?: YieldV2FindYieldValidatorsParams,\n  options?: {\n    query?: Partial<\n      UseQueryOptions<\n        Awaited<ReturnType<typeof yieldV2FindYieldValidators>>,\n        TError,\n        TData\n      >\n    >;\n  },\n): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {\n  const queryOptions = getYieldV2FindYieldValidatorsQueryOptions(\n    yieldId,\n    params,\n    options,\n  );\n\n  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {\n    queryKey: QueryKey;\n  };\n\n  query.queryKey = queryOptions.queryKey;\n\n  return query;\n};\n\n/**\n * Returns a list of available validators to specify when providing a `validatorAddress` property.\n * @summary Get validators\n */\nexport const yieldV2FindValidators = (\n  params?: YieldV2FindValidatorsParams,\n  signal?: AbortSignal,\n) => {\n  return customFetch<ValidatorSearchResultDto[]>({\n    url: `/v2/yields/validators`,\n    method: 'GET',\n    params,\n    signal,\n  });\n};\n\nexport const getYieldV2FindValidatorsQueryKey = (\n  params?: YieldV2FindValidatorsParams,\n) => {\n  return [`/v2/yields/validators`, ...(params ? [params] : [])] as const;\n};\n\nexport const getYieldV2FindValidatorsQueryOptions = <\n  TData = Awaited<ReturnType<typeof yieldV2FindValidators>>,\n  TError = StakeKitErrorDto,\n>(\n  params?: YieldV2FindValidatorsParams,\n  options?: {\n    query?: Partial<\n      UseQueryOptions<\n        Awaited<ReturnType<typeof yieldV2FindValidators>>,\n        TError,\n        TData\n      >\n    >;\n  },\n) => {\n  const { query: queryOptions } = options ?? {};\n\n  const queryKey =\n    queryOptions?.queryKey ?? getYieldV2FindValidatorsQueryKey(params);\n\n  const queryFn: QueryFunction<\n    Awaited<ReturnType<typeof yieldV2FindValidators>>\n  > = ({ signal }) => yieldV2FindValidators(params, signal);\n\n  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<\n    Awaited<ReturnType<typeof yieldV2FindValidators>>,\n    TError,\n    TData\n  > & { queryKey: QueryKey };\n};\n\nexport type YieldV2FindValidatorsQueryResult = NonNullable<\n  Awaited<ReturnType<typeof yieldV2FindValidators>>\n>;\nexport type YieldV2FindValidatorsQueryError = StakeKitErrorDto;\n\n/**\n * @summary Get validators\n */\nexport const useYieldV2FindValidators = <\n  TData = Awaited<ReturnType<typeof yieldV2FindValidators>>,\n  TError = StakeKitErrorDto,\n>(\n  params?: YieldV2FindValidatorsParams,\n  options?: {\n    query?: Partial<\n      UseQueryOptions<\n        Awaited<ReturnType<typeof yieldV2FindValidators>>,\n        TError,\n        TData\n      >\n    >;\n  },\n): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {\n  const queryOptions = getYieldV2FindValidatorsQueryOptions(params, options);\n\n  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {\n    queryKey: QueryKey;\n  };\n\n  query.queryKey = queryOptions.queryKey;\n\n  return query;\n};\n","type CustomFetch = <T>(\n  input: RequestInfo | URL,\n  init?: RequestInit,\n) => Promise<T>;\n\nexport class StakeKitApiClient {\n  private static config: {\n    apiKey: string;\n    baseURL: string;\n    customFetch?: CustomFetch;\n  };\n\n  static configure({\n    apiKey,\n    baseURL,\n    customFetch,\n  }: {\n    apiKey: string;\n    baseURL?: string;\n    customFetch?: CustomFetch;\n  }) {\n    StakeKitApiClient.config = {\n      apiKey,\n      baseURL: baseURL || 'https://api.stakek.it/',\n      customFetch,\n    };\n  }\n\n  static getConfig() {\n    return StakeKitApiClient.config;\n  }\n}\n","import { StakeKitApiClient } from './api-client-config';\n\nconst getUrl = ({\n  baseURL,\n  path,\n  params,\n}: {\n  baseURL: string;\n  path: string;\n  params?: Record<string, any>;\n}): string => {\n  const url = new URL(baseURL);\n  url.pathname = path;\n\n  if (params) {\n    const urlSearchParams = new URLSearchParams();\n\n    Object.keys(params).forEach((key) => {\n      const val = params[key];\n      if (val === undefined || val === null || val === '') return;\n\n      urlSearchParams.append(key, params[key]);\n    });\n\n    url.search = urlSearchParams.toString();\n  }\n\n  return url.toString();\n};\n\nexport const customFetch = async <T>({\n  url,\n  data,\n  method,\n  params,\n  headers,\n  signal,\n}: {\n  url: string;\n  method: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH';\n  params?: any;\n  data?: Record<string, any>;\n  headers?: Record<string, any>;\n  signal?: AbortSignal;\n}): Promise<T> => {\n  const { apiKey, baseURL, customFetch } = StakeKitApiClient.getConfig();\n\n  const fetchInstance = customFetch || fetch;\n\n  const response = await fetchInstance(getUrl({ baseURL, path: url, params }), {\n    method,\n    headers: { ...headers, 'X-API-KEY': apiKey },\n    signal,\n    ...(data && { body: JSON.stringify(data) }),\n  });\n\n  if (response.ok) {\n    return response.json();\n  }\n\n  return Promise.reject(response);\n};\n"]}