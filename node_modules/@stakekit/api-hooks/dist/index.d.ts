import { T as TokenDto, C as CosmosGasArgsDto, E as EvmEIP1559GasArgsDto, a as EvmLegacyGasArgsDto, A as AddressesDto, N as Networks, b as ActionStatus, c as TransactionDto, d as ActionTypes, e as CosmosAdditionalAddressesDto, B as BinanceAdditionalAddressesDto, S as SolanaAdditionalAddressesDto, f as TezosAdditionalAddressesDto, g as AvalancheCAdditionalAddressesDto, Y as YieldBalanceDto, h as YieldMetadataDto, H as HealthStatusDto, i as ActionDto, G as GasEstimateDto, j as ActionList200, I as InfinityPaginatedDto, k as ActionList200AllOf, l as SubmitResponseDto, m as TransactionStatusResponseDto, n as GasForNetworkResponseDto, o as TransactionVerificationMessageDto, p as TokenWithAvailableYieldsDto, P as PriceResponseDto, q as BalanceResponseDto, r as TokenBalanceScanResponseDto, s as YieldYields200, t as YieldYields200AllOf, u as YieldBalancesWithIntegrationIdDto, v as YieldGetMyYields200, w as YieldGetMyYields200AllOf, V as ValidatorSearchResultDto, x as YieldDto, y as ValidatorDto, z as YieldRewardsSummaryResponseDto, F as FeeConfigurationDto, D as YieldV2Yields200, J as YieldV2Yields200AllOf } from './yieldYields200-aQf46KDL.js';
export { K as ActionArgumentOptionsDto, L as ActionArgumentResponseDto, M as AddressArgumentsDto, O as AddressesDtoAdditionalAddresses, Q as AmountArgumentOptionsDto, R as ApeNativeArgumentOptionsDto, U as ArgumentOptionsDto, W as BalanceTypes, X as BinanceAdditionalAddressesStakeArgumentOptionsDto, Z as DurationArgumentOptionsDto, _ as EvmEIP1559GasArgsDtoType, $ as EvmLegacyGasArgsDtoType, a0 as FeeConfigurationStatus, a1 as GasMode, a2 as GasModeValueDto, a3 as GasModeValueDtoGasArgs, a4 as GasModesDto, a5 as HealthStatus, a6 as InfinityPaginatedDtoData, a7 as PendingActionDto, a8 as RequiredArgumentDto, a9 as RequiredArgumentWithNetworkDto, aa as RewardClaiming, ab as RewardSchedule, ac as RewardTypes, ad as TimePeriodDto, ae as TransactionDtoGasEstimate, af as TransactionStatus, ag as TransactionStatusResponseDtoRaw, ah as TransactionType, ai as TronResourceArgumentOptionsDto, aj as ValidatorStatusTypes, ak as YieldBalanceLabelDto, al as YieldBalanceLabelDtoParams, am as YieldFeeDto, an as YieldProviderDto, ao as YieldProviders, ap as YieldRevshareDto, aq as YieldRewardsSummaryDto, ar as YieldStatusResponseDto, as as YieldType } from './yieldYields200-aQf46KDL.js';
import * as _tanstack_react_query from '@tanstack/react-query';
import { UseQueryOptions, QueryKey, UseQueryResult, UseMutationOptions } from '@tanstack/react-query';

interface ApeNativeArgumentsDto {
    bakcId?: string;
    baycId?: string;
    maycId?: string;
}

interface SignatureVerificationArgumentsDto {
    message: string;
    signed: string;
}

type TronResourceType = (typeof TronResourceType)[keyof typeof TronResourceType];
declare const TronResourceType: {
    readonly BANDWIDTH: "BANDWIDTH";
    readonly ENERGY: "ENERGY";
};

interface ActionArgumentsDto {
    amount: string;
    duration?: number;
    inputToken?: TokenDto;
    ledgerWalletAPICompatible?: boolean;
    nfts?: ApeNativeArgumentsDto;
    providerId?: string;
    signatureVerification?: SignatureVerificationArgumentsDto;
    tronResource?: TronResourceType;
    validatorAddress?: string;
    validatorAddresses?: string[];
}

/**
 * Custom gas properties to request gas estimate with. Can include properties like `gasPrice`, `maxGasPerFee`, etc for EVM chains.
 */
type ActionGasEstimateRequestDtoGasArgs = CosmosGasArgsDto | EvmEIP1559GasArgsDto | EvmLegacyGasArgsDto;

interface ActionGasEstimateRequestDto {
    addresses: AddressesDto;
    args: ActionArgumentsDto;
    /** Custom gas properties to request gas estimate with. Can include properties like `gasPrice`, `maxGasPerFee`, etc for EVM chains. */
    gasArgs?: ActionGasEstimateRequestDtoGasArgs;
    integrationId: string;
    referralCode?: string;
}

type ActionListStatus = (typeof ActionListStatus)[keyof typeof ActionListStatus];
declare const ActionListStatus: {
    readonly CANCELED: "CANCELED";
    readonly CREATED: "CREATED";
    readonly WAITING_FOR_NEXT: "WAITING_FOR_NEXT";
    readonly PROCESSING: "PROCESSING";
    readonly FAILED: "FAILED";
    readonly SUCCESS: "SUCCESS";
    readonly STALE: "STALE";
};

type ActionListType = (typeof ActionListType)[keyof typeof ActionListType];
declare const ActionListType: {
    readonly STAKE: "STAKE";
    readonly UNSTAKE: "UNSTAKE";
    readonly CLAIM_REWARDS: "CLAIM_REWARDS";
    readonly RESTAKE_REWARDS: "RESTAKE_REWARDS";
    readonly WITHDRAW: "WITHDRAW";
    readonly RESTAKE: "RESTAKE";
    readonly CLAIM_UNSTAKED: "CLAIM_UNSTAKED";
    readonly UNLOCK_LOCKED: "UNLOCK_LOCKED";
    readonly STAKE_LOCKED: "STAKE_LOCKED";
    readonly VOTE: "VOTE";
    readonly REVOKE: "REVOKE";
    readonly VOTE_LOCKED: "VOTE_LOCKED";
    readonly REVOTE: "REVOTE";
    readonly REBOND: "REBOND";
    readonly MIGRATE: "MIGRATE";
};

type ActionListSort = (typeof ActionListSort)[keyof typeof ActionListSort];
declare const ActionListSort: {
    readonly createdAtAsc: "createdAtAsc";
    readonly createdAtDesc: "createdAtDesc";
};

type ActionListParams = {
    walletAddress: string;
    status?: ActionListStatus;
    type?: ActionListType;
    sort?: ActionListSort;
    network?: Networks;
    limit?: number;
    page?: number;
};

interface ActionRequestDto {
    addresses: AddressesDto;
    args: ActionArgumentsDto;
    integrationId: string;
    referralCode?: string;
}

interface ActionWithLivePriceDto {
    accountAddresses?: string[];
    addresses: AddressesDto;
    amount: string | null;
    completedAt: string | null;
    createdAt: string;
    currentStepIndex: number;
    currentUSDAmount: string | null;
    id: string;
    inputToken?: TokenDto;
    integrationId: string;
    status: ActionStatus;
    tokenId: string | null;
    transactions: TransactionDto[];
    type: ActionTypes;
    USDAmount: string | null;
    validatorAddress: string | null;
    validatorAddresses: string[] | null;
}

type AddressWithTokenDtoAdditionalAddresses = CosmosAdditionalAddressesDto | BinanceAdditionalAddressesDto | SolanaAdditionalAddressesDto | TezosAdditionalAddressesDto | AvalancheCAdditionalAddressesDto;

interface AddressWithTokenDto {
    additionalAddresses?: AddressWithTokenDtoAdditionalAddresses;
    address: string;
    explorerUrl?: string;
    network: Networks;
    tokenAddress?: string;
}

interface AuthConfirmEmailDto {
    hash: string;
}

interface AuthEmailLoginDto {
    email: string;
    password: string;
}

type Role = (typeof Role)[keyof typeof Role];
declare const Role: {
    readonly admin: "admin";
    readonly member: "member";
    readonly superAdmin: "superAdmin";
};

interface UserDto {
    email: string;
    emailVerified: boolean;
    id: string;
    lastAccessedAt: string | null;
    name: string | null;
    role: Role;
    serviceConditionsAcceptedAt: string | null;
    surname: string | null;
    teamId: string;
}

interface AuthEmailLoginResponseDto {
    token: string;
    user: UserDto;
}

interface AuthForgotPasswordDto {
    email: string;
}

interface AuthResetPasswordDto {
    hash: string;
    password: string;
}

interface AuthUpdateDto {
    name: string;
    oldPassword: string | null;
    password: string;
    surname: string;
}

interface BalancesRequestDto {
    addresses: AddressWithTokenDto[];
}

interface BannedRegionDto {
    country: string;
    id: string;
    region: string | null;
    updatedAt: string;
}

interface ConfirmUserMeDto {
    password: string;
}

/**
 * Custom gas properties to request transaction construction with. Can include properties like `gasPrice`, `maxGasPerFee`, etc for EVM chains.
 */
type ConstructTransactionRequestDtoGasArgs = CosmosGasArgsDto | EvmEIP1559GasArgsDto | EvmLegacyGasArgsDto;

interface ConstructTransactionRequestDto {
    /** Custom gas properties to request transaction construction with. Can include properties like `gasPrice`, `maxGasPerFee`, etc for EVM chains. */
    gasArgs?: ConstructTransactionRequestDtoGasArgs;
    ledgerWalletAPICompatible?: boolean;
}

interface CreateBannedRegionDto {
    country: string;
    region?: string;
}

interface CreateCustomUriDto {
    network: Networks;
    rpcUri: string;
}

interface CreateEnabledYieldDto {
    integrationId: string;
}

interface CreateFeeConfigurationDto {
    depositFeeBps?: number;
    integrationId: string;
    managementFeeBps?: number;
    performanceFeeBps?: number;
}

interface CreateKeyDto {
    info?: string;
    name: string;
}

interface CreateMasterBannedRegionDto {
    country: string;
    isMandatory: boolean;
    region?: string;
    tags: string[];
}

interface CreatePayoutAddressDto {
    address: string;
    network: string;
}

interface CreateProjectDto {
    description?: string;
    name: string;
}

type CreateTeamDtoContactDetails = {
    [key: string]: any;
};

interface CreateTeamDtoUser {
    email: string;
    name: string;
    surname: string;
}

interface CreateTeamDto {
    contactDetails: CreateTeamDtoContactDetails;
    name: string;
    user: CreateTeamDtoUser;
}

interface CreateUserDto {
    accessLevel: string;
    email: string;
    name: string;
    surname: string;
}

interface CreateWebhookSubscriptionDtoEvent {
    category: string;
    event: string;
}

interface CreateWebhookSubscriptionDto {
    callback: string;
    events: CreateWebhookSubscriptionDtoEvent[];
}

interface CustomUri {
    createdAt: string;
    id: string;
    network: Networks;
    projectId: string;
    rpcUri: string;
    updatedAt: string;
}

interface CustomValidatorAddresses {
    integrationId: string;
    validatorAddresses: string[];
}

/**
 * Related stakes status
 */
type DailyCumulativeStakeDtoStatus = (typeof DailyCumulativeStakeDtoStatus)[keyof typeof DailyCumulativeStakeDtoStatus];
declare const DailyCumulativeStakeDtoStatus: {
    readonly CANCELED: "CANCELED";
    readonly CREATED: "CREATED";
    readonly WAITING_FOR_NEXT: "WAITING_FOR_NEXT";
    readonly PROCESSING: "PROCESSING";
    readonly FAILED: "FAILED";
    readonly SUCCESS: "SUCCESS";
    readonly STALE: "STALE";
};

/**
 * Related stakes type
 */
type DailyCumulativeStakeDtoType = (typeof DailyCumulativeStakeDtoType)[keyof typeof DailyCumulativeStakeDtoType];
declare const DailyCumulativeStakeDtoType: {
    readonly STAKE: "STAKE";
    readonly UNSTAKE: "UNSTAKE";
    readonly CLAIM_REWARDS: "CLAIM_REWARDS";
    readonly RESTAKE_REWARDS: "RESTAKE_REWARDS";
    readonly WITHDRAW: "WITHDRAW";
    readonly RESTAKE: "RESTAKE";
    readonly CLAIM_UNSTAKED: "CLAIM_UNSTAKED";
    readonly UNLOCK_LOCKED: "UNLOCK_LOCKED";
    readonly STAKE_LOCKED: "STAKE_LOCKED";
    readonly VOTE: "VOTE";
    readonly REVOKE: "REVOKE";
    readonly VOTE_LOCKED: "VOTE_LOCKED";
    readonly REVOTE: "REVOTE";
    readonly REBOND: "REBOND";
    readonly MIGRATE: "MIGRATE";
};

interface DailyCumulativeStakeDto {
    amountUsd: string;
    date: string;
    /** Related stakes status */
    status: DailyCumulativeStakeDtoStatus;
    /** Related stakes type */
    type: DailyCumulativeStakeDtoType;
}

interface DeleteBannedRegionsDto {
    ids: string[];
}

interface DeleteEnabledYieldsDto {
    integrationIds: string[];
}

interface DeleteMasterBannedRegionsDto {
    ids: string[];
}

interface EnabledYieldDto {
    integrationId: string;
}

type EvmNetworks = (typeof EvmNetworks)[keyof typeof EvmNetworks];
declare const EvmNetworks: {
    readonly ethereum: "ethereum";
    readonly 'ethereum-goerli': "ethereum-goerli";
    readonly 'ethereum-holesky': "ethereum-holesky";
    readonly arbitrum: "arbitrum";
    readonly base: "base";
    readonly gnosis: "gnosis";
    readonly optimism: "optimism";
    readonly polygon: "polygon";
    readonly starknet: "starknet";
    readonly zksync: "zksync";
    readonly linea: "linea";
    readonly 'avalanche-c': "avalanche-c";
    readonly 'avalanche-c-atomic': "avalanche-c-atomic";
    readonly 'avalanche-p': "avalanche-p";
    readonly binance: "binance";
    readonly celo: "celo";
    readonly fantom: "fantom";
    readonly harmony: "harmony";
    readonly moonriver: "moonriver";
    readonly okc: "okc";
    readonly viction: "viction";
    readonly core: "core";
};

type GeolocationErrorDetails = {
    [key: string]: any;
};

type GeolocationErrorRegionCode = {
    [key: string]: any;
};

type GeolocationErrorTagsItem = (typeof GeolocationErrorTagsItem)[keyof typeof GeolocationErrorTagsItem];
declare const GeolocationErrorTagsItem: {
    readonly Crypto_Ban: "Crypto Ban";
    readonly OFAC: "OFAC";
    readonly OFSI: "OFSI";
    readonly Pending_Litigation: "Pending Litigation";
    readonly Staking_Ban: "Staking Ban";
};

type GeolocationErrorType = (typeof GeolocationErrorType)[keyof typeof GeolocationErrorType];
declare const GeolocationErrorType: {
    readonly GEO_LOCATION: "GEO_LOCATION";
};

interface GeolocationError {
    code: number;
    countryCode: string;
    details?: GeolocationErrorDetails;
    message: string;
    regionCode?: GeolocationErrorRegionCode;
    tags?: GeolocationErrorTagsItem[];
    type: GeolocationErrorType;
}

interface Key {
    apiKey: string;
    category: string;
    createdAt: string;
    deletedAt: string | null;
    id: string;
    info: string | null;
    lastUsedAt: string | null;
    name: string;
    projectId: string;
    updatedAt: string;
}

type KeyCategory = (typeof KeyCategory)[keyof typeof KeyCategory];
declare const KeyCategory: {
    readonly pro: "pro";
    readonly standard: "standard";
    readonly trial: "trial";
};

type MasterBannedRegionDtoTagsItem = (typeof MasterBannedRegionDtoTagsItem)[keyof typeof MasterBannedRegionDtoTagsItem];
declare const MasterBannedRegionDtoTagsItem: {
    readonly Crypto_Ban: "Crypto Ban";
    readonly OFAC: "OFAC";
    readonly OFSI: "OFSI";
    readonly Pending_Litigation: "Pending Litigation";
    readonly Staking_Ban: "Staking Ban";
};

interface MasterBannedRegionDto {
    country: string;
    id: string;
    region: string | null;
    tags: MasterBannedRegionDtoTagsItem[];
}

type MasterBannedYieldDtoTagsItem = (typeof MasterBannedYieldDtoTagsItem)[keyof typeof MasterBannedYieldDtoTagsItem];
declare const MasterBannedYieldDtoTagsItem: {
    readonly Crypto_Ban: "Crypto Ban";
    readonly OFAC: "OFAC";
    readonly OFSI: "OFSI";
    readonly Pending_Litigation: "Pending Litigation";
    readonly Staking_Ban: "Staking Ban";
};

interface MasterBannedYieldDto {
    country: string;
    region: string | null;
    tags: MasterBannedYieldDtoTagsItem[];
    yieldId: string;
}

interface PayoutAddressDto {
    address: string;
    id: string;
    lastPayout: string | null;
    network: string;
    projectId: string;
}

interface PendingActionArgumentsDto {
    amount?: string;
    duration?: number;
    nfts?: ApeNativeArgumentsDto;
    validatorAddress?: string;
    validatorAddresses?: string[];
}

/**
 * Custom gas properties to request gas estimate with. Can include properties like `gasPrice`, `maxGasPerFee`, etc for EVM chains.
 */
type PendingActionGasEstimateRequestDtoGasArgs = CosmosGasArgsDto | EvmEIP1559GasArgsDto | EvmLegacyGasArgsDto;

interface PendingActionGasEstimateRequestDto {
    args?: PendingActionArgumentsDto;
    /** Custom gas properties to request gas estimate with. Can include properties like `gasPrice`, `maxGasPerFee`, etc for EVM chains. */
    gasArgs?: PendingActionGasEstimateRequestDtoGasArgs;
    integrationId: string;
    /** The corresponding passthrough for the pending action to be run, returned in the balances endpoint */
    passthrough: string;
    type: ActionTypes;
}

interface PendingActionRequestDto {
    args?: PendingActionArgumentsDto;
    integrationId: string;
    /** The corresponding passthrough for the pending action to be run, returned in the balances endpoint */
    passthrough: string;
    type: ActionTypes;
}

interface PositionDto {
    balances: YieldBalanceDto[];
    integrationId: string;
}

interface PriceRequestDto {
    currency: string;
    tokenList: TokenDto[];
}

interface Project {
    autoComplaintBansEnabled: boolean;
    createdAt: string;
    deletedAt: string | null;
    description: string | null;
    id: string;
    name: string;
    teamId: string;
    updatedAt: string;
}

interface ReferralDto {
    code: string;
    id: string;
}

interface ReportEntryDto {
    action: ActionWithLivePriceDto;
    address: AddressesDto;
    metadata: YieldMetadataDto;
}

type StakeKitErrorDtoDetails = {
    [key: string]: any;
};

interface StakeKitErrorDto {
    code: number;
    details?: StakeKitErrorDtoDetails;
    message: string;
    path?: string;
    type?: string;
}

interface SubmitHashRequestDto {
    /** Hash of submitted transaction */
    hash: string;
}

interface SubmitRequestDto {
    /** Signed transaction to be broadcast to the network */
    signedTransaction: string;
}

type TeamCategory = (typeof TeamCategory)[keyof typeof TeamCategory];
declare const TeamCategory: {
    readonly pro: "pro";
    readonly standard: "standard";
    readonly trial: "trial";
};

type TeamContactDetails = {
    [key: string]: any;
};

type TeamType = (typeof TeamType)[keyof typeof TeamType];
declare const TeamType: {
    readonly provider: "provider";
    readonly integrator: "integrator";
};

interface Team {
    activated: boolean;
    category: TeamCategory;
    contactDetails: TeamContactDetails;
    createdAt: string;
    deletedAt: string | null;
    id: string;
    name: string;
    providerId: string | null;
    serviceConditionsAcceptedAt: string | null;
    type: TeamType;
    updatedAt: string;
}

type TeamDtoContactDetails = {
    [key: string]: any;
};

interface TeamDto {
    activated: boolean;
    adminUsers: UserDto[];
    category: string;
    contactDetails: TeamDtoContactDetails;
    createdAt: string;
    deletedAt: string | null;
    id: string;
    name: string;
    serviceConditionsAcceptedAt: string | null;
}

interface TokenBalanceScanDto {
    addresses: AddressesDto;
    network: Networks;
}

type TokenGetTokensParams = {
    network?: Networks;
};

interface TransactionVerificationMessageRequestDto {
    addresses: AddressesDto;
}

interface UpdateCustomUriDto {
    network?: Networks;
    rpcUri?: string;
}

interface UpdateFeeConfigurationDto {
    depositFeeBps?: number | null;
    managementFeeBps?: number | null;
    performanceFeeBps?: number | null;
}

interface UpdateKeyDto {
    info: string;
    name: string;
}

interface UpdatePayoutAddressDto {
    address: string;
    network: Networks;
}

interface UpdateProjectDto {
    autoComplaintBansEnabled?: boolean;
    description?: string;
    name?: string;
}

interface UpdateTeamDto {
    activated?: boolean;
    category?: KeyCategory;
    name?: string;
    serviceConditionsAccepted?: boolean;
}

interface UpdateUserDto {
    active?: boolean;
    role?: string;
}

interface UpdateUserMeDto {
    active?: boolean;
    name?: string;
    password?: string;
    serviceConditionsAccepted?: boolean;
    surname?: string;
}

interface UpdateWebhookSubscriptionDtoEvent {
    category: string;
    event: string;
}

interface UpdateWebhookSubscriptionDto {
    callback?: string;
    events: UpdateWebhookSubscriptionDtoEvent[];
}

interface ValidatorAddressesDto {
    validatorAddresses?: string[];
}

type WebhookSubscriptionEventDtoEvent = (typeof WebhookSubscriptionEventDtoEvent)[keyof typeof WebhookSubscriptionEventDtoEvent];
declare const WebhookSubscriptionEventDtoEvent: {
    readonly '*': "*";
    readonly maintenance: "maintenance";
    readonly 'proxy-contract-upgrade': "proxy-contract-upgrade";
    readonly 'opportunity-deprecation': "opportunity-deprecation";
    readonly 'opportunity-pause': "opportunity-pause";
    readonly 'opportunity-resume': "opportunity-resume";
    readonly failure: "failure";
    readonly success: "success";
    readonly 'claim-rewards': "claim-rewards";
    readonly 'waiting-for-next': "waiting-for-next";
    readonly 'withdraw-funds': "withdraw-funds";
};

interface WebhookSubscriptionEventDto {
    category: string;
    event: WebhookSubscriptionEventDtoEvent;
}

interface WebhookSubscriptionDto {
    callback: string;
    events: WebhookSubscriptionEventDto[];
    id: string;
}

interface YieldBalanceRequestDto {
    addresses: AddressesDto;
    args?: ValidatorAddressesDto;
}

interface YieldBalanceScanEvmRequestDto {
    addresses: AddressesDto;
    customValidators?: CustomValidatorAddresses[];
    networks: EvmNetworks;
}

interface YieldBalanceScanRequestDto {
    addresses: AddressesDto;
    customValidators?: CustomValidatorAddresses[];
    network: Networks;
}

interface YieldBalanceWithIntegrationIdRequestDto {
    addresses: AddressesDto;
    args?: ValidatorAddressesDto;
    integrationId: string;
}

type YieldFindValidatorsParams = {
    ledgerWalletAPICompatible?: boolean;
    network?: string;
    query?: string;
};

type YieldGetMyYieldsType = (typeof YieldGetMyYieldsType)[keyof typeof YieldGetMyYieldsType];
declare const YieldGetMyYieldsType: {
    readonly staking: "staking";
    readonly 'liquid-staking': "liquid-staking";
    readonly lending: "lending";
    readonly restaking: "restaking";
    readonly vault: "vault";
};

type YieldGetMyYieldsSortBy = (typeof YieldGetMyYieldsSortBy)[keyof typeof YieldGetMyYieldsSortBy];
declare const YieldGetMyYieldsSortBy: {
    readonly name: "name";
    readonly nameAsc: "nameAsc";
    readonly nameDesc: "nameDesc";
    readonly relevantYieldType: "relevantYieldType";
    readonly relevantYieldTypeAsc: "relevantYieldTypeAsc";
    readonly relevantYieldTypeDesc: "relevantYieldTypeDesc";
    readonly yieldType: "yieldType";
    readonly yieldTypeAsc: "yieldTypeAsc";
    readonly yieldTypeDesc: "yieldTypeDesc";
};

type YieldGetMyYieldsParams = {
    preferredValidatorsOnly?: boolean;
    ledgerWalletAPICompatible?: boolean;
    type?: YieldGetMyYieldsType;
    sortBy?: YieldGetMyYieldsSortBy;
    network?: Networks;
    page?: number;
    limit?: number;
};

type YieldGetSingleYieldBalancesParams = {
    ledgerWalletAPICompatible?: boolean;
};

type YieldGetValidatorsParams = {
    preferredValidatorsOnly?: boolean;
    ledgerWalletAPICompatible?: boolean;
};

interface YieldRewardsSummaryRequestDto {
    addresses: AddressesDto;
}

type YieldV2FindValidatorsParams = {
    preferredValidatorsOnly?: boolean;
    ledgerWalletAPICompatible?: boolean;
    network?: string;
    query?: string;
};

type YieldV2FindYieldValidatorsParams = {
    ledgerWalletAPICompatible?: boolean;
    network?: string;
    query?: string;
};

type YieldV2YieldsNetwork = (typeof YieldV2YieldsNetwork)[keyof typeof YieldV2YieldsNetwork];
declare const YieldV2YieldsNetwork: {
    readonly ethereum: "ethereum";
    readonly 'ethereum-goerli': "ethereum-goerli";
    readonly 'ethereum-holesky': "ethereum-holesky";
    readonly arbitrum: "arbitrum";
    readonly base: "base";
    readonly gnosis: "gnosis";
    readonly optimism: "optimism";
    readonly polygon: "polygon";
    readonly starknet: "starknet";
    readonly zksync: "zksync";
    readonly linea: "linea";
    readonly 'avalanche-c': "avalanche-c";
    readonly 'avalanche-c-atomic': "avalanche-c-atomic";
    readonly 'avalanche-p': "avalanche-p";
    readonly binance: "binance";
    readonly celo: "celo";
    readonly fantom: "fantom";
    readonly harmony: "harmony";
    readonly moonriver: "moonriver";
    readonly okc: "okc";
    readonly viction: "viction";
    readonly core: "core";
    readonly agoric: "agoric";
    readonly akash: "akash";
    readonly axelar: "axelar";
    readonly 'band-protocol': "band-protocol";
    readonly bitsong: "bitsong";
    readonly canto: "canto";
    readonly chihuahua: "chihuahua";
    readonly comdex: "comdex";
    readonly coreum: "coreum";
    readonly cosmos: "cosmos";
    readonly crescent: "crescent";
    readonly cronos: "cronos";
    readonly cudos: "cudos";
    readonly desmos: "desmos";
    readonly dydx: "dydx";
    readonly evmos: "evmos";
    readonly 'fetch-ai': "fetch-ai";
    readonly 'gravity-bridge': "gravity-bridge";
    readonly injective: "injective";
    readonly irisnet: "irisnet";
    readonly juno: "juno";
    readonly kava: "kava";
    readonly 'ki-network': "ki-network";
    readonly 'mars-protocol': "mars-protocol";
    readonly nym: "nym";
    readonly 'okex-chain': "okex-chain";
    readonly onomy: "onomy";
    readonly osmosis: "osmosis";
    readonly persistence: "persistence";
    readonly quicksilver: "quicksilver";
    readonly regen: "regen";
    readonly secret: "secret";
    readonly sentinel: "sentinel";
    readonly sommelier: "sommelier";
    readonly stafi: "stafi";
    readonly stargaze: "stargaze";
    readonly stride: "stride";
    readonly teritori: "teritori";
    readonly tgrade: "tgrade";
    readonly umee: "umee";
    readonly sei: "sei";
    readonly mantra: "mantra";
    readonly polkadot: "polkadot";
    readonly kusama: "kusama";
    readonly westend: "westend";
    readonly binancebeacon: "binancebeacon";
    readonly cardano: "cardano";
    readonly near: "near";
    readonly solana: "solana";
    readonly tezos: "tezos";
    readonly tron: "tron";
    readonly ton: "ton";
    readonly 'ton-testnet': "ton-testnet";
};

type YieldV2YieldsType = (typeof YieldV2YieldsType)[keyof typeof YieldV2YieldsType];
declare const YieldV2YieldsType: {
    readonly staking: "staking";
    readonly 'liquid-staking': "liquid-staking";
    readonly lending: "lending";
    readonly restaking: "restaking";
    readonly vault: "vault";
};

type YieldV2YieldsSortBy = (typeof YieldV2YieldsSortBy)[keyof typeof YieldV2YieldsSortBy];
declare const YieldV2YieldsSortBy: {
    readonly name: "name";
    readonly nameAsc: "nameAsc";
    readonly nameDesc: "nameDesc";
    readonly relevantYieldType: "relevantYieldType";
    readonly relevantYieldTypeAsc: "relevantYieldTypeAsc";
    readonly relevantYieldTypeDesc: "relevantYieldTypeDesc";
    readonly yieldType: "yieldType";
    readonly yieldTypeAsc: "yieldTypeAsc";
    readonly yieldTypeDesc: "yieldTypeDesc";
};

type YieldV2YieldsRevenueOption = (typeof YieldV2YieldsRevenueOption)[keyof typeof YieldV2YieldsRevenueOption];
declare const YieldV2YieldsRevenueOption: {
    readonly supportsFee: "supportsFee";
    readonly supportsRevShare: "supportsRevShare";
};

type YieldV2YieldsParams = {
    enterStatus?: boolean;
    preferredValidatorsOnly?: boolean;
    ledgerWalletAPICompatible?: boolean;
    type?: YieldV2YieldsType;
    sortBy?: YieldV2YieldsSortBy;
    revenueOption?: YieldV2YieldsRevenueOption;
    page?: number;
    network?: YieldV2YieldsNetwork;
    limit?: number;
};

type YieldYieldOpportunityParams = {
    preferredValidatorsOnly?: boolean;
    ledgerWalletAPICompatible?: boolean;
};

type YieldYieldsType = (typeof YieldYieldsType)[keyof typeof YieldYieldsType];
declare const YieldYieldsType: {
    readonly staking: "staking";
    readonly 'liquid-staking': "liquid-staking";
    readonly lending: "lending";
    readonly restaking: "restaking";
    readonly vault: "vault";
};

type YieldYieldsSortBy = (typeof YieldYieldsSortBy)[keyof typeof YieldYieldsSortBy];
declare const YieldYieldsSortBy: {
    readonly name: "name";
    readonly nameAsc: "nameAsc";
    readonly nameDesc: "nameDesc";
    readonly relevantYieldType: "relevantYieldType";
    readonly relevantYieldTypeAsc: "relevantYieldTypeAsc";
    readonly relevantYieldTypeDesc: "relevantYieldTypeDesc";
    readonly yieldType: "yieldType";
    readonly yieldTypeAsc: "yieldTypeAsc";
    readonly yieldTypeDesc: "yieldTypeDesc";
};

type YieldYieldsRevenueOption = (typeof YieldYieldsRevenueOption)[keyof typeof YieldYieldsRevenueOption];
declare const YieldYieldsRevenueOption: {
    readonly supportsFee: "supportsFee";
    readonly supportsRevShare: "supportsRevShare";
};

type YieldYieldsParams = {
    preferredValidatorsOnly?: boolean;
    ledgerWalletAPICompatible?: boolean;
    type?: YieldYieldsType;
    sortBy?: YieldYieldsSortBy;
    revenueOption?: YieldYieldsRevenueOption;
    page?: number;
    network?: Networks;
    limit?: number;
};

declare const healthHealthV2: (signal?: AbortSignal) => Promise<HealthStatusDto>;
declare const getHealthHealthV2QueryKey: () => readonly ["/v2/health"];
declare const getHealthHealthV2QueryOptions: <TData = HealthStatusDto, TError = StakeKitErrorDto>(options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof healthHealthV2>>, TError, TData>>;
}) => UseQueryOptions<HealthStatusDto, TError, TData, QueryKey> & {
    queryKey: QueryKey;
};
type HealthHealthV2QueryResult = NonNullable<Awaited<ReturnType<typeof healthHealthV2>>>;
type HealthHealthV2QueryError = StakeKitErrorDto;
declare const useHealthHealthV2: <TData = HealthStatusDto, TError = StakeKitErrorDto>(options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof healthHealthV2>>, TError, TData>>;
}) => UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
};
/**
 * Returns a action with associated transactions
 * @summary Get action
 */
declare const actionGetAction: (actionId: string, signal?: AbortSignal) => Promise<ActionDto>;
declare const getActionGetActionQueryKey: (actionId: string) => readonly [`/v1/actions/${string}`];
declare const getActionGetActionQueryOptions: <TData = ActionDto, TError = GeolocationError | StakeKitErrorDto>(actionId: string, options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof actionGetAction>>, TError, TData>>;
}) => UseQueryOptions<ActionDto, TError, TData, QueryKey> & {
    queryKey: QueryKey;
};
type ActionGetActionQueryResult = NonNullable<Awaited<ReturnType<typeof actionGetAction>>>;
type ActionGetActionQueryError = StakeKitErrorDto | GeolocationError;
/**
 * @summary Get action
 */
declare const useActionGetAction: <TData = ActionDto, TError = GeolocationError | StakeKitErrorDto>(actionId: string, options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof actionGetAction>>, TError, TData>>;
}) => UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
};
/**
 * Returns a gas estimate
 * @summary Get estimated gas for action
 */
declare const actionGetGasEstimate: (actionId: string, signal?: AbortSignal) => Promise<GasEstimateDto>;
declare const getActionGetGasEstimateQueryKey: (actionId: string) => readonly [`/v1/actions/${string}/gas-estimate`];
declare const getActionGetGasEstimateQueryOptions: <TData = GasEstimateDto, TError = GeolocationError | StakeKitErrorDto>(actionId: string, options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof actionGetGasEstimate>>, TError, TData>>;
}) => UseQueryOptions<GasEstimateDto, TError, TData, QueryKey> & {
    queryKey: QueryKey;
};
type ActionGetGasEstimateQueryResult = NonNullable<Awaited<ReturnType<typeof actionGetGasEstimate>>>;
type ActionGetGasEstimateQueryError = StakeKitErrorDto | GeolocationError;
/**
 * @summary Get estimated gas for action
 */
declare const useActionGetGasEstimate: <TData = GasEstimateDto, TError = GeolocationError | StakeKitErrorDto>(actionId: string, options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof actionGetGasEstimate>>, TError, TData>>;
}) => UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
};
/**
 * Get the transactions necessary to enter a yield bearing position
 * @summary Create "enter" action
 */
declare const actionEnter: (actionRequestDto: ActionRequestDto) => Promise<ActionDto>;
declare const getActionEnterMutationOptions: <TError = GeolocationError | StakeKitErrorDto, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof actionEnter>>, TError, {
        data: ActionRequestDto;
    }, TContext>;
}) => UseMutationOptions<Awaited<ReturnType<typeof actionEnter>>, TError, {
    data: ActionRequestDto;
}, TContext>;
type ActionEnterMutationResult = NonNullable<Awaited<ReturnType<typeof actionEnter>>>;
type ActionEnterMutationBody = ActionRequestDto;
type ActionEnterMutationError = StakeKitErrorDto | GeolocationError;
/**
 * @summary Create "enter" action
 */
declare const useActionEnter: <TError = GeolocationError | StakeKitErrorDto, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof actionEnter>>, TError, {
        data: ActionRequestDto;
    }, TContext>;
}) => _tanstack_react_query.UseMutationResult<ActionDto, TError, {
    data: ActionRequestDto;
}, TContext>;
/**
 * Get the transactions necessary to exit a yield bearing position
 * @summary Create "exit" action
 */
declare const actionExit: (actionRequestDto: ActionRequestDto) => Promise<ActionDto>;
declare const getActionExitMutationOptions: <TError = GeolocationError | StakeKitErrorDto, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof actionExit>>, TError, {
        data: ActionRequestDto;
    }, TContext>;
}) => UseMutationOptions<Awaited<ReturnType<typeof actionExit>>, TError, {
    data: ActionRequestDto;
}, TContext>;
type ActionExitMutationResult = NonNullable<Awaited<ReturnType<typeof actionExit>>>;
type ActionExitMutationBody = ActionRequestDto;
type ActionExitMutationError = StakeKitErrorDto | GeolocationError;
/**
 * @summary Create "exit" action
 */
declare const useActionExit: <TError = GeolocationError | StakeKitErrorDto, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof actionExit>>, TError, {
        data: ActionRequestDto;
    }, TContext>;
}) => _tanstack_react_query.UseMutationResult<ActionDto, TError, {
    data: ActionRequestDto;
}, TContext>;
/**
 * Get the transactions to apply a pending action
 * @summary Create "pending" action
 */
declare const actionPending: (pendingActionRequestDto: PendingActionRequestDto) => Promise<ActionDto>;
declare const getActionPendingMutationOptions: <TError = GeolocationError | StakeKitErrorDto, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof actionPending>>, TError, {
        data: PendingActionRequestDto;
    }, TContext>;
}) => UseMutationOptions<Awaited<ReturnType<typeof actionPending>>, TError, {
    data: PendingActionRequestDto;
}, TContext>;
type ActionPendingMutationResult = NonNullable<Awaited<ReturnType<typeof actionPending>>>;
type ActionPendingMutationBody = PendingActionRequestDto;
type ActionPendingMutationError = StakeKitErrorDto | GeolocationError;
/**
 * @summary Create "pending" action
 */
declare const useActionPending: <TError = GeolocationError | StakeKitErrorDto, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof actionPending>>, TError, {
        data: PendingActionRequestDto;
    }, TContext>;
}) => _tanstack_react_query.UseMutationResult<ActionDto, TError, {
    data: PendingActionRequestDto;
}, TContext>;
/**
 * Get the estimated gas necessary to enter a yield bearing position
 * @summary Estimate gas for the "enter" action
 */
declare const actionEnterGasEstimation: (actionGasEstimateRequestDto: ActionGasEstimateRequestDto) => Promise<GasEstimateDto>;
declare const getActionEnterGasEstimationQueryKey: (actionGasEstimateRequestDto: ActionGasEstimateRequestDto) => readonly ["/v1/actions/enter/estimate-gas", ActionGasEstimateRequestDto];
declare const getActionEnterGasEstimationQueryOptions: <TData = GasEstimateDto, TError = GeolocationError | StakeKitErrorDto>(actionGasEstimateRequestDto: ActionGasEstimateRequestDto, options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof actionEnterGasEstimation>>, TError, TData>>;
}) => UseQueryOptions<GasEstimateDto, TError, TData, QueryKey> & {
    queryKey: QueryKey;
};
type ActionEnterGasEstimationQueryResult = NonNullable<Awaited<ReturnType<typeof actionEnterGasEstimation>>>;
type ActionEnterGasEstimationQueryError = StakeKitErrorDto | GeolocationError;
/**
 * @summary Estimate gas for the "enter" action
 */
declare const useActionEnterGasEstimation: <TData = GasEstimateDto, TError = GeolocationError | StakeKitErrorDto>(actionGasEstimateRequestDto: ActionGasEstimateRequestDto, options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof actionEnterGasEstimation>>, TError, TData>>;
}) => UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
};
/**
 * Get the estimated gas necessary to exit a yield bearing position
 * @summary Estimate gas for the "exit" action
 */
declare const actionExitGasEstimate: (actionGasEstimateRequestDto: ActionGasEstimateRequestDto) => Promise<GasEstimateDto>;
declare const getActionExitGasEstimateQueryKey: (actionGasEstimateRequestDto: ActionGasEstimateRequestDto) => readonly ["/v1/actions/exit/estimate-gas", ActionGasEstimateRequestDto];
declare const getActionExitGasEstimateQueryOptions: <TData = GasEstimateDto, TError = GeolocationError | StakeKitErrorDto>(actionGasEstimateRequestDto: ActionGasEstimateRequestDto, options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof actionExitGasEstimate>>, TError, TData>>;
}) => UseQueryOptions<GasEstimateDto, TError, TData, QueryKey> & {
    queryKey: QueryKey;
};
type ActionExitGasEstimateQueryResult = NonNullable<Awaited<ReturnType<typeof actionExitGasEstimate>>>;
type ActionExitGasEstimateQueryError = StakeKitErrorDto | GeolocationError;
/**
 * @summary Estimate gas for the "exit" action
 */
declare const useActionExitGasEstimate: <TData = GasEstimateDto, TError = GeolocationError | StakeKitErrorDto>(actionGasEstimateRequestDto: ActionGasEstimateRequestDto, options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof actionExitGasEstimate>>, TError, TData>>;
}) => UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
};
declare const actionList: (params: ActionListParams, signal?: AbortSignal) => Promise<ActionList200>;
declare const getActionListQueryKey: (params: ActionListParams) => readonly ["/v1/actions", ...ActionListParams[]];
declare const getActionListQueryOptions: <TData = InfinityPaginatedDto & ActionList200AllOf, TError = StakeKitErrorDto>(params: ActionListParams, options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof actionList>>, TError, TData>>;
}) => UseQueryOptions<InfinityPaginatedDto & ActionList200AllOf, TError, TData, QueryKey> & {
    queryKey: QueryKey;
};
type ActionListQueryResult = NonNullable<Awaited<ReturnType<typeof actionList>>>;
type ActionListQueryError = StakeKitErrorDto;
declare const useActionList: <TData = InfinityPaginatedDto & ActionList200AllOf, TError = StakeKitErrorDto>(params: ActionListParams, options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof actionList>>, TError, TData>>;
}) => UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
};
/**
 * Get the estimated gas necessary to apply a pending action
 * @summary Estimate gas for the "pending" action
 */
declare const actionPendingGasEstimate: (pendingActionGasEstimateRequestDto: PendingActionGasEstimateRequestDto) => Promise<GasEstimateDto>;
declare const getActionPendingGasEstimateQueryKey: (pendingActionGasEstimateRequestDto: PendingActionGasEstimateRequestDto) => readonly ["/v1/actions/pending/estimate-gas", PendingActionGasEstimateRequestDto];
declare const getActionPendingGasEstimateQueryOptions: <TData = GasEstimateDto, TError = GeolocationError | StakeKitErrorDto>(pendingActionGasEstimateRequestDto: PendingActionGasEstimateRequestDto, options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof actionPendingGasEstimate>>, TError, TData>>;
}) => UseQueryOptions<GasEstimateDto, TError, TData, QueryKey> & {
    queryKey: QueryKey;
};
type ActionPendingGasEstimateQueryResult = NonNullable<Awaited<ReturnType<typeof actionPendingGasEstimate>>>;
type ActionPendingGasEstimateQueryError = StakeKitErrorDto | GeolocationError;
/**
 * @summary Estimate gas for the "pending" action
 */
declare const useActionPendingGasEstimate: <TData = GasEstimateDto, TError = GeolocationError | StakeKitErrorDto>(pendingActionGasEstimateRequestDto: PendingActionGasEstimateRequestDto, options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof actionPendingGasEstimate>>, TError, TData>>;
}) => UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
};
/**
 * Returns a transaction
 * @summary Get transaction
 */
declare const transactionGetTransaction: (transactionId: string, signal?: AbortSignal) => Promise<TransactionDto>;
declare const getTransactionGetTransactionQueryKey: (transactionId: string) => readonly [`/v1/transactions/${string}`];
declare const getTransactionGetTransactionQueryOptions: <TData = TransactionDto, TError = GeolocationError | StakeKitErrorDto>(transactionId: string, options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof transactionGetTransaction>>, TError, TData>>;
}) => UseQueryOptions<TransactionDto, TError, TData, QueryKey> & {
    queryKey: QueryKey;
};
type TransactionGetTransactionQueryResult = NonNullable<Awaited<ReturnType<typeof transactionGetTransaction>>>;
type TransactionGetTransactionQueryError = StakeKitErrorDto | GeolocationError;
/**
 * @summary Get transaction
 */
declare const useTransactionGetTransaction: <TData = TransactionDto, TError = GeolocationError | StakeKitErrorDto>(transactionId: string, options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof transactionGetTransaction>>, TError, TData>>;
}) => UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
};
/**
 * Constructs an unsigned transaction given a transaction id and optional gas parameters
 * @summary Construct transaction
 */
declare const transactionConstruct: (transactionId: string, constructTransactionRequestDto: ConstructTransactionRequestDto) => Promise<TransactionDto>;
declare const getTransactionConstructMutationOptions: <TError = GeolocationError | StakeKitErrorDto, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof transactionConstruct>>, TError, {
        transactionId: string;
        data: ConstructTransactionRequestDto;
    }, TContext>;
}) => UseMutationOptions<Awaited<ReturnType<typeof transactionConstruct>>, TError, {
    transactionId: string;
    data: ConstructTransactionRequestDto;
}, TContext>;
type TransactionConstructMutationResult = NonNullable<Awaited<ReturnType<typeof transactionConstruct>>>;
type TransactionConstructMutationBody = ConstructTransactionRequestDto;
type TransactionConstructMutationError = StakeKitErrorDto | GeolocationError;
/**
 * @summary Construct transaction
 */
declare const useTransactionConstruct: <TError = GeolocationError | StakeKitErrorDto, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof transactionConstruct>>, TError, {
        transactionId: string;
        data: ConstructTransactionRequestDto;
    }, TContext>;
}) => _tanstack_react_query.UseMutationResult<TransactionDto, TError, {
    transactionId: string;
    data: ConstructTransactionRequestDto;
}, TContext>;
/**
 * Submits the signed transactions for broadcasting
 * @summary Submit transaction
 */
declare const transactionSubmit: (transactionId: string, submitRequestDto: SubmitRequestDto) => Promise<SubmitResponseDto>;
declare const getTransactionSubmitMutationOptions: <TError = GeolocationError | StakeKitErrorDto, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof transactionSubmit>>, TError, {
        transactionId: string;
        data: SubmitRequestDto;
    }, TContext>;
}) => UseMutationOptions<Awaited<ReturnType<typeof transactionSubmit>>, TError, {
    transactionId: string;
    data: SubmitRequestDto;
}, TContext>;
type TransactionSubmitMutationResult = NonNullable<Awaited<ReturnType<typeof transactionSubmit>>>;
type TransactionSubmitMutationBody = SubmitRequestDto;
type TransactionSubmitMutationError = StakeKitErrorDto | GeolocationError;
/**
 * @summary Submit transaction
 */
declare const useTransactionSubmit: <TError = GeolocationError | StakeKitErrorDto, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof transactionSubmit>>, TError, {
        transactionId: string;
        data: SubmitRequestDto;
    }, TContext>;
}) => _tanstack_react_query.UseMutationResult<SubmitResponseDto, TError, {
    transactionId: string;
    data: SubmitRequestDto;
}, TContext>;
/**
 * Submit a hash of an already broadcasted transaction
 * @summary Submit transaction hash
 */
declare const transactionSubmitHash: (transactionId: string, submitHashRequestDto: SubmitHashRequestDto) => Promise<void>;
declare const getTransactionSubmitHashMutationOptions: <TError = GeolocationError | StakeKitErrorDto, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof transactionSubmitHash>>, TError, {
        transactionId: string;
        data: SubmitHashRequestDto;
    }, TContext>;
}) => UseMutationOptions<Awaited<ReturnType<typeof transactionSubmitHash>>, TError, {
    transactionId: string;
    data: SubmitHashRequestDto;
}, TContext>;
type TransactionSubmitHashMutationResult = NonNullable<Awaited<ReturnType<typeof transactionSubmitHash>>>;
type TransactionSubmitHashMutationBody = SubmitHashRequestDto;
type TransactionSubmitHashMutationError = StakeKitErrorDto | GeolocationError;
/**
 * @summary Submit transaction hash
 */
declare const useTransactionSubmitHash: <TError = GeolocationError | StakeKitErrorDto, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof transactionSubmitHash>>, TError, {
        transactionId: string;
        data: SubmitHashRequestDto;
    }, TContext>;
}) => _tanstack_react_query.UseMutationResult<void, TError, {
    transactionId: string;
    data: SubmitHashRequestDto;
}, TContext>;
/**
 * Returns the transaction status given a transaction id
 * @summary Get transaction status
 */
declare const transactionGetTransactionStatusFromId: (transactionId: string, signal?: AbortSignal) => Promise<TransactionStatusResponseDto>;
declare const getTransactionGetTransactionStatusFromIdQueryKey: (transactionId: string) => readonly [`/v1/transactions/${string}/status`];
declare const getTransactionGetTransactionStatusFromIdQueryOptions: <TData = TransactionStatusResponseDto, TError = GeolocationError | StakeKitErrorDto>(transactionId: string, options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof transactionGetTransactionStatusFromId>>, TError, TData>>;
}) => UseQueryOptions<TransactionStatusResponseDto, TError, TData, QueryKey> & {
    queryKey: QueryKey;
};
type TransactionGetTransactionStatusFromIdQueryResult = NonNullable<Awaited<ReturnType<typeof transactionGetTransactionStatusFromId>>>;
type TransactionGetTransactionStatusFromIdQueryError = StakeKitErrorDto | GeolocationError;
/**
 * @summary Get transaction status
 */
declare const useTransactionGetTransactionStatusFromId: <TData = TransactionStatusResponseDto, TError = GeolocationError | StakeKitErrorDto>(transactionId: string, options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof transactionGetTransactionStatusFromId>>, TError, TData>>;
}) => UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
};
/**
 * Returns the current gas parameters for a network
 * @summary Get current gas parameters
 */
declare const transactionGetGasForNetwork: (network: string, signal?: AbortSignal) => Promise<GasForNetworkResponseDto>;
declare const getTransactionGetGasForNetworkQueryKey: (network: string) => readonly [`/v1/transactions/gas/${string}`];
declare const getTransactionGetGasForNetworkQueryOptions: <TData = GasForNetworkResponseDto, TError = GeolocationError | StakeKitErrorDto>(network: string, options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof transactionGetGasForNetwork>>, TError, TData>>;
}) => UseQueryOptions<GasForNetworkResponseDto, TError, TData, QueryKey> & {
    queryKey: QueryKey;
};
type TransactionGetGasForNetworkQueryResult = NonNullable<Awaited<ReturnType<typeof transactionGetGasForNetwork>>>;
type TransactionGetGasForNetworkQueryError = StakeKitErrorDto | GeolocationError;
/**
 * @summary Get current gas parameters
 */
declare const useTransactionGetGasForNetwork: <TData = GasForNetworkResponseDto, TError = GeolocationError | StakeKitErrorDto>(network: string, options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof transactionGetGasForNetwork>>, TError, TData>>;
}) => UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
};
/**
 * Returns the transaction status given a transaction hash and a network
 * @summary Get transaction status
 */
declare const transactionGetTransactionStatusByNetworkAndHash: (network: string, hash: string, signal?: AbortSignal) => Promise<TransactionStatusResponseDto>;
declare const getTransactionGetTransactionStatusByNetworkAndHashQueryKey: (network: string, hash: string) => readonly [`/v1/transactions/status/${string}/${string}`];
declare const getTransactionGetTransactionStatusByNetworkAndHashQueryOptions: <TData = TransactionStatusResponseDto, TError = GeolocationError | StakeKitErrorDto>(network: string, hash: string, options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof transactionGetTransactionStatusByNetworkAndHash>>, TError, TData>>;
}) => UseQueryOptions<TransactionStatusResponseDto, TError, TData, QueryKey> & {
    queryKey: QueryKey;
};
type TransactionGetTransactionStatusByNetworkAndHashQueryResult = NonNullable<Awaited<ReturnType<typeof transactionGetTransactionStatusByNetworkAndHash>>>;
type TransactionGetTransactionStatusByNetworkAndHashQueryError = StakeKitErrorDto | GeolocationError;
/**
 * @summary Get transaction status
 */
declare const useTransactionGetTransactionStatusByNetworkAndHash: <TData = TransactionStatusResponseDto, TError = GeolocationError | StakeKitErrorDto>(network: string, hash: string, options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof transactionGetTransactionStatusByNetworkAndHash>>, TError, TData>>;
}) => UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
};
/**
 * Returns the transaction or message to sign to provide verification
 * @summary Get transaction verification transaction/message
 */
declare const transactionGetTransactionVerificationMessageForNetwork: (network: string, transactionVerificationMessageRequestDto: TransactionVerificationMessageRequestDto) => Promise<TransactionVerificationMessageDto>;
declare const getTransactionGetTransactionVerificationMessageForNetworkMutationOptions: <TError = GeolocationError | StakeKitErrorDto, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof transactionGetTransactionVerificationMessageForNetwork>>, TError, {
        network: string;
        data: TransactionVerificationMessageRequestDto;
    }, TContext>;
}) => UseMutationOptions<Awaited<ReturnType<typeof transactionGetTransactionVerificationMessageForNetwork>>, TError, {
    network: string;
    data: TransactionVerificationMessageRequestDto;
}, TContext>;
type TransactionGetTransactionVerificationMessageForNetworkMutationResult = NonNullable<Awaited<ReturnType<typeof transactionGetTransactionVerificationMessageForNetwork>>>;
type TransactionGetTransactionVerificationMessageForNetworkMutationBody = TransactionVerificationMessageRequestDto;
type TransactionGetTransactionVerificationMessageForNetworkMutationError = StakeKitErrorDto | GeolocationError;
/**
 * @summary Get transaction verification transaction/message
 */
declare const useTransactionGetTransactionVerificationMessageForNetwork: <TError = GeolocationError | StakeKitErrorDto, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof transactionGetTransactionVerificationMessageForNetwork>>, TError, {
        network: string;
        data: TransactionVerificationMessageRequestDto;
    }, TContext>;
}) => _tanstack_react_query.UseMutationResult<TransactionVerificationMessageDto, TError, {
    network: string;
    data: TransactionVerificationMessageRequestDto;
}, TContext>;
/**
 * Returns the tokens with available yields
 * @summary Get all tokens
 */
declare const tokenGetTokens: (params?: TokenGetTokensParams, signal?: AbortSignal) => Promise<TokenWithAvailableYieldsDto[]>;
declare const getTokenGetTokensQueryKey: (params?: TokenGetTokensParams) => readonly ["/v1/tokens", ...TokenGetTokensParams[]];
declare const getTokenGetTokensQueryOptions: <TData = TokenWithAvailableYieldsDto[], TError = StakeKitErrorDto>(params?: TokenGetTokensParams, options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof tokenGetTokens>>, TError, TData>>;
}) => UseQueryOptions<TokenWithAvailableYieldsDto[], TError, TData, QueryKey> & {
    queryKey: QueryKey;
};
type TokenGetTokensQueryResult = NonNullable<Awaited<ReturnType<typeof tokenGetTokens>>>;
type TokenGetTokensQueryError = StakeKitErrorDto;
/**
 * @summary Get all tokens
 */
declare const useTokenGetTokens: <TData = TokenWithAvailableYieldsDto[], TError = StakeKitErrorDto>(params?: TokenGetTokensParams, options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof tokenGetTokens>>, TError, TData>>;
}) => UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
};
/**
 * Returns the token prices for a specific list of tokens
 * @summary Get token prices
 */
declare const tokenGetTokenPrices: (priceRequestDto: PriceRequestDto) => Promise<PriceResponseDto>;
declare const getTokenGetTokenPricesQueryKey: (priceRequestDto: PriceRequestDto) => readonly ["/v1/tokens/prices", PriceRequestDto];
declare const getTokenGetTokenPricesQueryOptions: <TData = PriceResponseDto, TError = StakeKitErrorDto>(priceRequestDto: PriceRequestDto, options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof tokenGetTokenPrices>>, TError, TData>>;
}) => UseQueryOptions<PriceResponseDto, TError, TData, QueryKey> & {
    queryKey: QueryKey;
};
type TokenGetTokenPricesQueryResult = NonNullable<Awaited<ReturnType<typeof tokenGetTokenPrices>>>;
type TokenGetTokenPricesQueryError = StakeKitErrorDto;
/**
 * @summary Get token prices
 */
declare const useTokenGetTokenPrices: <TData = PriceResponseDto, TError = StakeKitErrorDto>(priceRequestDto: PriceRequestDto, options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof tokenGetTokenPrices>>, TError, TData>>;
}) => UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
};
/**
 * Returns the balances for specific addresses and token addresses
 * @summary Get token balances
 */
declare const tokenGetTokenBalances: (balancesRequestDto: BalancesRequestDto) => Promise<BalanceResponseDto[]>;
declare const getTokenGetTokenBalancesQueryKey: (balancesRequestDto: BalancesRequestDto) => readonly ["/v1/tokens/balances", BalancesRequestDto];
declare const getTokenGetTokenBalancesQueryOptions: <TData = BalanceResponseDto[], TError = StakeKitErrorDto>(balancesRequestDto: BalancesRequestDto, options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof tokenGetTokenBalances>>, TError, TData>>;
}) => UseQueryOptions<BalanceResponseDto[], TError, TData, QueryKey> & {
    queryKey: QueryKey;
};
type TokenGetTokenBalancesQueryResult = NonNullable<Awaited<ReturnType<typeof tokenGetTokenBalances>>>;
type TokenGetTokenBalancesQueryError = StakeKitErrorDto;
/**
 * @summary Get token balances
 */
declare const useTokenGetTokenBalances: <TData = BalanceResponseDto[], TError = StakeKitErrorDto>(balancesRequestDto: BalancesRequestDto, options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof tokenGetTokenBalances>>, TError, TData>>;
}) => UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
};
/**
 * Scans for tokens with balance with available yields
 * @summary Scan for token balances
 */
declare const tokenTokenBalancesScan: (tokenBalanceScanDto: TokenBalanceScanDto) => Promise<TokenBalanceScanResponseDto[]>;
declare const getTokenTokenBalancesScanQueryKey: (tokenBalanceScanDto: TokenBalanceScanDto) => readonly ["/v1/tokens/balances/scan", TokenBalanceScanDto];
declare const getTokenTokenBalancesScanQueryOptions: <TData = TokenBalanceScanResponseDto[], TError = StakeKitErrorDto>(tokenBalanceScanDto: TokenBalanceScanDto, options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof tokenTokenBalancesScan>>, TError, TData>>;
}) => UseQueryOptions<TokenBalanceScanResponseDto[], TError, TData, QueryKey> & {
    queryKey: QueryKey;
};
type TokenTokenBalancesScanQueryResult = NonNullable<Awaited<ReturnType<typeof tokenTokenBalancesScan>>>;
type TokenTokenBalancesScanQueryError = StakeKitErrorDto;
/**
 * @summary Scan for token balances
 */
declare const useTokenTokenBalancesScan: <TData = TokenBalanceScanResponseDto[], TError = StakeKitErrorDto>(tokenBalanceScanDto: TokenBalanceScanDto, options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof tokenTokenBalancesScan>>, TError, TData>>;
}) => UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
};
/**
 * Returns the available yields (staking, lending, vaults, etc) with associated configuration and metadata
 * @summary Get all yields
 */
declare const yieldYields: (params?: YieldYieldsParams, signal?: AbortSignal) => Promise<YieldYields200>;
declare const getYieldYieldsQueryKey: (params?: YieldYieldsParams) => readonly ["/v1/yields", ...YieldYieldsParams[]];
declare const getYieldYieldsQueryOptions: <TData = InfinityPaginatedDto & YieldYields200AllOf, TError = StakeKitErrorDto>(params?: YieldYieldsParams, options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof yieldYields>>, TError, TData>>;
}) => UseQueryOptions<InfinityPaginatedDto & YieldYields200AllOf, TError, TData, QueryKey> & {
    queryKey: QueryKey;
};
type YieldYieldsQueryResult = NonNullable<Awaited<ReturnType<typeof yieldYields>>>;
type YieldYieldsQueryError = StakeKitErrorDto;
/**
 * @summary Get all yields
 */
declare const useYieldYields: <TData = InfinityPaginatedDto & YieldYields200AllOf, TError = StakeKitErrorDto>(params?: YieldYieldsParams, options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof yieldYields>>, TError, TData>>;
}) => UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
};
/**
 * Given addresses and integration ids, returns respective balances and configuration.
 * @summary Get multiple yield balances
 */
declare const yieldGetMultipleYieldBalances: (yieldBalanceWithIntegrationIdRequestDto: YieldBalanceWithIntegrationIdRequestDto[]) => Promise<YieldBalancesWithIntegrationIdDto[]>;
declare const getYieldGetMultipleYieldBalancesQueryKey: (yieldBalanceWithIntegrationIdRequestDto: YieldBalanceWithIntegrationIdRequestDto[]) => readonly ["/v1/yields/balances", YieldBalanceWithIntegrationIdRequestDto[]];
declare const getYieldGetMultipleYieldBalancesQueryOptions: <TData = YieldBalancesWithIntegrationIdDto[], TError = StakeKitErrorDto>(yieldBalanceWithIntegrationIdRequestDto: YieldBalanceWithIntegrationIdRequestDto[], options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof yieldGetMultipleYieldBalances>>, TError, TData>>;
}) => UseQueryOptions<YieldBalancesWithIntegrationIdDto[], TError, TData, QueryKey> & {
    queryKey: QueryKey;
};
type YieldGetMultipleYieldBalancesQueryResult = NonNullable<Awaited<ReturnType<typeof yieldGetMultipleYieldBalances>>>;
type YieldGetMultipleYieldBalancesQueryError = StakeKitErrorDto;
/**
 * @summary Get multiple yield balances
 */
declare const useYieldGetMultipleYieldBalances: <TData = YieldBalancesWithIntegrationIdDto[], TError = StakeKitErrorDto>(yieldBalanceWithIntegrationIdRequestDto: YieldBalanceWithIntegrationIdRequestDto[], options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof yieldGetMultipleYieldBalances>>, TError, TData>>;
}) => UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
};
/**
 * Scans for yield balances among enabled yields.
 * @summary Scan for yield balances
 */
declare const yieldYieldBalancesScan: (yieldBalanceScanRequestDto: YieldBalanceScanRequestDto) => Promise<YieldBalancesWithIntegrationIdDto[]>;
declare const getYieldYieldBalancesScanQueryKey: (yieldBalanceScanRequestDto: YieldBalanceScanRequestDto) => readonly ["/v1/yields/balances/scan", YieldBalanceScanRequestDto];
declare const getYieldYieldBalancesScanQueryOptions: <TData = YieldBalancesWithIntegrationIdDto[], TError = StakeKitErrorDto>(yieldBalanceScanRequestDto: YieldBalanceScanRequestDto, options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof yieldYieldBalancesScan>>, TError, TData>>;
}) => UseQueryOptions<YieldBalancesWithIntegrationIdDto[], TError, TData, QueryKey> & {
    queryKey: QueryKey;
};
type YieldYieldBalancesScanQueryResult = NonNullable<Awaited<ReturnType<typeof yieldYieldBalancesScan>>>;
type YieldYieldBalancesScanQueryError = StakeKitErrorDto;
/**
 * @summary Scan for yield balances
 */
declare const useYieldYieldBalancesScan: <TData = YieldBalancesWithIntegrationIdDto[], TError = StakeKitErrorDto>(yieldBalanceScanRequestDto: YieldBalanceScanRequestDto, options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof yieldYieldBalancesScan>>, TError, TData>>;
}) => UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
};
/**
 * Scans for all EVM yield balances among enabled yields.
 * @summary Scan for all EVM yield balances
 */
declare const yieldYieldBalancesScanEvm: (yieldBalanceScanEvmRequestDto: YieldBalanceScanEvmRequestDto) => Promise<YieldBalancesWithIntegrationIdDto[]>;
declare const getYieldYieldBalancesScanEvmMutationOptions: <TError = StakeKitErrorDto, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof yieldYieldBalancesScanEvm>>, TError, {
        data: YieldBalanceScanEvmRequestDto;
    }, TContext>;
}) => UseMutationOptions<Awaited<ReturnType<typeof yieldYieldBalancesScanEvm>>, TError, {
    data: YieldBalanceScanEvmRequestDto;
}, TContext>;
type YieldYieldBalancesScanEvmMutationResult = NonNullable<Awaited<ReturnType<typeof yieldYieldBalancesScanEvm>>>;
type YieldYieldBalancesScanEvmMutationBody = YieldBalanceScanEvmRequestDto;
type YieldYieldBalancesScanEvmMutationError = StakeKitErrorDto;
/**
 * @summary Scan for all EVM yield balances
 */
declare const useYieldYieldBalancesScanEvm: <TError = StakeKitErrorDto, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof yieldYieldBalancesScanEvm>>, TError, {
        data: YieldBalanceScanEvmRequestDto;
    }, TContext>;
}) => _tanstack_react_query.UseMutationResult<YieldBalancesWithIntegrationIdDto[], TError, {
    data: YieldBalanceScanEvmRequestDto;
}, TContext>;
/**
 * Returns the enabled yields (staking, lending, vaults, etc) associated with current API key with configuration and metadata
 * @summary Get enabled yields
 */
declare const yieldGetMyYields: (params?: YieldGetMyYieldsParams, signal?: AbortSignal) => Promise<YieldGetMyYields200>;
declare const getYieldGetMyYieldsQueryKey: (params?: YieldGetMyYieldsParams) => readonly ["/v1/yields/enabled", ...YieldGetMyYieldsParams[]];
declare const getYieldGetMyYieldsQueryOptions: <TData = InfinityPaginatedDto & YieldGetMyYields200AllOf, TError = StakeKitErrorDto>(params?: YieldGetMyYieldsParams, options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof yieldGetMyYields>>, TError, TData>>;
}) => UseQueryOptions<InfinityPaginatedDto & YieldGetMyYields200AllOf, TError, TData, QueryKey> & {
    queryKey: QueryKey;
};
type YieldGetMyYieldsQueryResult = NonNullable<Awaited<ReturnType<typeof yieldGetMyYields>>>;
type YieldGetMyYieldsQueryError = StakeKitErrorDto;
/**
 * @summary Get enabled yields
 */
declare const useYieldGetMyYields: <TData = InfinityPaginatedDto & YieldGetMyYields200AllOf, TError = StakeKitErrorDto>(params?: YieldGetMyYieldsParams, options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof yieldGetMyYields>>, TError, TData>>;
}) => UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
};
/**
 * Returns the networks that has enabled yields
 * @summary Get enabled networks
 */
declare const yieldGetMyNetworks: (signal?: AbortSignal) => Promise<string[]>;
declare const getYieldGetMyNetworksQueryKey: () => readonly ["/v1/yields/enabled/networks"];
declare const getYieldGetMyNetworksQueryOptions: <TData = string[], TError = string[] | StakeKitErrorDto>(options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof yieldGetMyNetworks>>, TError, TData>>;
}) => UseQueryOptions<string[], TError, TData, QueryKey> & {
    queryKey: QueryKey;
};
type YieldGetMyNetworksQueryResult = NonNullable<Awaited<ReturnType<typeof yieldGetMyNetworks>>>;
type YieldGetMyNetworksQueryError = StakeKitErrorDto | string[];
/**
 * @summary Get enabled networks
 */
declare const useYieldGetMyNetworks: <TData = string[], TError = string[] | StakeKitErrorDto>(options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof yieldGetMyNetworks>>, TError, TData>>;
}) => UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
};
/**
 * Returns a list of available validators to specify when providing a `validatorAddress` property.
 * @summary Get validators
 */
declare const yieldFindValidators: (params?: YieldFindValidatorsParams, signal?: AbortSignal) => Promise<ValidatorSearchResultDto[]>;
declare const getYieldFindValidatorsQueryKey: (params?: YieldFindValidatorsParams) => readonly ["/v1/yields/validators", ...YieldFindValidatorsParams[]];
declare const getYieldFindValidatorsQueryOptions: <TData = ValidatorSearchResultDto[], TError = StakeKitErrorDto>(params?: YieldFindValidatorsParams, options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof yieldFindValidators>>, TError, TData>>;
}) => UseQueryOptions<ValidatorSearchResultDto[], TError, TData, QueryKey> & {
    queryKey: QueryKey;
};
type YieldFindValidatorsQueryResult = NonNullable<Awaited<ReturnType<typeof yieldFindValidators>>>;
type YieldFindValidatorsQueryError = StakeKitErrorDto;
/**
 * @summary Get validators
 */
declare const useYieldFindValidators: <TData = ValidatorSearchResultDto[], TError = StakeKitErrorDto>(params?: YieldFindValidatorsParams, options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof yieldFindValidators>>, TError, TData>>;
}) => UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
};
/**
 * Returns a yield that is associated with given integration ID
 * @summary Get a yield given an integration ID
 */
declare const yieldYieldOpportunity: (integrationId: string, params?: YieldYieldOpportunityParams, signal?: AbortSignal) => Promise<YieldDto>;
declare const getYieldYieldOpportunityQueryKey: (integrationId: string, params?: YieldYieldOpportunityParams) => readonly [`/v1/yields/${string}`, ...YieldYieldOpportunityParams[]];
declare const getYieldYieldOpportunityQueryOptions: <TData = YieldDto, TError = StakeKitErrorDto>(integrationId: string, params?: YieldYieldOpportunityParams, options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof yieldYieldOpportunity>>, TError, TData>>;
}) => UseQueryOptions<YieldDto, TError, TData, QueryKey> & {
    queryKey: QueryKey;
};
type YieldYieldOpportunityQueryResult = NonNullable<Awaited<ReturnType<typeof yieldYieldOpportunity>>>;
type YieldYieldOpportunityQueryError = StakeKitErrorDto;
/**
 * @summary Get a yield given an integration ID
 */
declare const useYieldYieldOpportunity: <TData = YieldDto, TError = StakeKitErrorDto>(integrationId: string, params?: YieldYieldOpportunityParams, options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof yieldYieldOpportunity>>, TError, TData>>;
}) => UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
};
/**
 * Returns a list of available validators to specify when providing a `validatorAddress` property.
 * @summary Get validators given an integration ID
 */
declare const yieldGetValidators: (integrationId: string, params?: YieldGetValidatorsParams, signal?: AbortSignal) => Promise<ValidatorDto[]>;
declare const getYieldGetValidatorsQueryKey: (integrationId: string, params?: YieldGetValidatorsParams) => readonly [`/v1/yields/${string}/validators`, ...YieldGetValidatorsParams[]];
declare const getYieldGetValidatorsQueryOptions: <TData = ValidatorDto[], TError = StakeKitErrorDto>(integrationId: string, params?: YieldGetValidatorsParams, options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof yieldGetValidators>>, TError, TData>>;
}) => UseQueryOptions<ValidatorDto[], TError, TData, QueryKey> & {
    queryKey: QueryKey;
};
type YieldGetValidatorsQueryResult = NonNullable<Awaited<ReturnType<typeof yieldGetValidators>>>;
type YieldGetValidatorsQueryError = StakeKitErrorDto;
/**
 * @summary Get validators given an integration ID
 */
declare const useYieldGetValidators: <TData = ValidatorDto[], TError = StakeKitErrorDto>(integrationId: string, params?: YieldGetValidatorsParams, options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof yieldGetValidators>>, TError, TData>>;
}) => UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
};
/**
 * Given addresses, returns the available, deposited balance, pending actions and associated configuration for any yield
 * @summary Get yield balances given an integration ID
 */
declare const yieldGetSingleYieldBalances: (integrationId: string, yieldBalanceRequestDto: YieldBalanceRequestDto, params?: YieldGetSingleYieldBalancesParams) => Promise<YieldBalanceDto[]>;
declare const getYieldGetSingleYieldBalancesQueryKey: (integrationId: string, yieldBalanceRequestDto: YieldBalanceRequestDto, params?: YieldGetSingleYieldBalancesParams) => readonly [`/v1/yields/${string}/balances`, ...YieldGetSingleYieldBalancesParams[], YieldBalanceRequestDto];
declare const getYieldGetSingleYieldBalancesQueryOptions: <TData = YieldBalanceDto[], TError = StakeKitErrorDto>(integrationId: string, yieldBalanceRequestDto: YieldBalanceRequestDto, params?: YieldGetSingleYieldBalancesParams, options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof yieldGetSingleYieldBalances>>, TError, TData>>;
}) => UseQueryOptions<YieldBalanceDto[], TError, TData, QueryKey> & {
    queryKey: QueryKey;
};
type YieldGetSingleYieldBalancesQueryResult = NonNullable<Awaited<ReturnType<typeof yieldGetSingleYieldBalances>>>;
type YieldGetSingleYieldBalancesQueryError = StakeKitErrorDto;
/**
 * @summary Get yield balances given an integration ID
 */
declare const useYieldGetSingleYieldBalances: <TData = YieldBalanceDto[], TError = StakeKitErrorDto>(integrationId: string, yieldBalanceRequestDto: YieldBalanceRequestDto, params?: YieldGetSingleYieldBalancesParams, options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof yieldGetSingleYieldBalances>>, TError, TData>>;
}) => UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
};
/**
 * Given addresses, returns a historic rewards summary for any yield
 * @summary Get historic rewards summary given an integration ID
 */
declare const yieldGetSingleYieldRewardsSummary: (integrationId: string, yieldRewardsSummaryRequestDto: YieldRewardsSummaryRequestDto) => Promise<YieldRewardsSummaryResponseDto[]>;
declare const getYieldGetSingleYieldRewardsSummaryMutationOptions: <TError = StakeKitErrorDto, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof yieldGetSingleYieldRewardsSummary>>, TError, {
        integrationId: string;
        data: YieldRewardsSummaryRequestDto;
    }, TContext>;
}) => UseMutationOptions<Awaited<ReturnType<typeof yieldGetSingleYieldRewardsSummary>>, TError, {
    integrationId: string;
    data: YieldRewardsSummaryRequestDto;
}, TContext>;
type YieldGetSingleYieldRewardsSummaryMutationResult = NonNullable<Awaited<ReturnType<typeof yieldGetSingleYieldRewardsSummary>>>;
type YieldGetSingleYieldRewardsSummaryMutationBody = YieldRewardsSummaryRequestDto;
type YieldGetSingleYieldRewardsSummaryMutationError = StakeKitErrorDto;
/**
 * @summary Get historic rewards summary given an integration ID
 */
declare const useYieldGetSingleYieldRewardsSummary: <TError = StakeKitErrorDto, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof yieldGetSingleYieldRewardsSummary>>, TError, {
        integrationId: string;
        data: YieldRewardsSummaryRequestDto;
    }, TContext>;
}) => _tanstack_react_query.UseMutationResult<YieldRewardsSummaryResponseDto[], TError, {
    integrationId: string;
    data: YieldRewardsSummaryRequestDto;
}, TContext>;
/**
 * Returns a fee configuraion that contains details about fees taken when interacting with the yield.
 * @summary Get fee configuration given an integration ID
 */
declare const yieldGetFeeConfiguration: (integrationId: string, signal?: AbortSignal) => Promise<FeeConfigurationDto>;
declare const getYieldGetFeeConfigurationQueryKey: (integrationId: string) => readonly [`/v1/yields/${string}/fee-configuration`];
declare const getYieldGetFeeConfigurationQueryOptions: <TData = FeeConfigurationDto, TError = void | StakeKitErrorDto>(integrationId: string, options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof yieldGetFeeConfiguration>>, TError, TData>>;
}) => UseQueryOptions<FeeConfigurationDto, TError, TData, QueryKey> & {
    queryKey: QueryKey;
};
type YieldGetFeeConfigurationQueryResult = NonNullable<Awaited<ReturnType<typeof yieldGetFeeConfiguration>>>;
type YieldGetFeeConfigurationQueryError = StakeKitErrorDto | void;
/**
 * @summary Get fee configuration given an integration ID
 */
declare const useYieldGetFeeConfiguration: <TData = FeeConfigurationDto, TError = void | StakeKitErrorDto>(integrationId: string, options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof yieldGetFeeConfiguration>>, TError, TData>>;
}) => UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
};
/**
 * Returns the available yields (staking, lending, vaults, etc) with associated configuration and metadata
 * @summary Get all yields
 */
declare const yieldV2Yields: (params?: YieldV2YieldsParams, signal?: AbortSignal) => Promise<YieldV2Yields200>;
declare const getYieldV2YieldsQueryKey: (params?: YieldV2YieldsParams) => readonly ["/v2/yields", ...YieldV2YieldsParams[]];
declare const getYieldV2YieldsQueryOptions: <TData = InfinityPaginatedDto & YieldV2Yields200AllOf, TError = StakeKitErrorDto>(params?: YieldV2YieldsParams, options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof yieldV2Yields>>, TError, TData>>;
}) => UseQueryOptions<InfinityPaginatedDto & YieldV2Yields200AllOf, TError, TData, QueryKey> & {
    queryKey: QueryKey;
};
type YieldV2YieldsQueryResult = NonNullable<Awaited<ReturnType<typeof yieldV2Yields>>>;
type YieldV2YieldsQueryError = StakeKitErrorDto;
/**
 * @summary Get all yields
 */
declare const useYieldV2Yields: <TData = InfinityPaginatedDto & YieldV2Yields200AllOf, TError = StakeKitErrorDto>(params?: YieldV2YieldsParams, options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof yieldV2Yields>>, TError, TData>>;
}) => UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
};
/**
 * Returns yield given an id
 * @summary Get yield
 */
declare const yieldV2GetYieldById: (yieldId: string, signal?: AbortSignal) => Promise<YieldDto>;
declare const getYieldV2GetYieldByIdQueryKey: (yieldId: string) => readonly [`/v2/yields/${string}`];
declare const getYieldV2GetYieldByIdQueryOptions: <TData = YieldDto, TError = StakeKitErrorDto>(yieldId: string, options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof yieldV2GetYieldById>>, TError, TData>>;
}) => UseQueryOptions<YieldDto, TError, TData, QueryKey> & {
    queryKey: QueryKey;
};
type YieldV2GetYieldByIdQueryResult = NonNullable<Awaited<ReturnType<typeof yieldV2GetYieldById>>>;
type YieldV2GetYieldByIdQueryError = StakeKitErrorDto;
/**
 * @summary Get yield
 */
declare const useYieldV2GetYieldById: <TData = YieldDto, TError = StakeKitErrorDto>(yieldId: string, options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof yieldV2GetYieldById>>, TError, TData>>;
}) => UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
};
/**
 * Given a yield, returns a list of available validators to specify when providing a `validatorAddress` property.
 * @summary Get yield validators
 */
declare const yieldV2FindYieldValidators: (yieldId: string, params?: YieldV2FindYieldValidatorsParams, signal?: AbortSignal) => Promise<ValidatorSearchResultDto[]>;
declare const getYieldV2FindYieldValidatorsQueryKey: (yieldId: string, params?: YieldV2FindYieldValidatorsParams) => readonly [`/v2/yields/${string}/validators`, ...YieldV2FindYieldValidatorsParams[]];
declare const getYieldV2FindYieldValidatorsQueryOptions: <TData = ValidatorSearchResultDto[], TError = StakeKitErrorDto>(yieldId: string, params?: YieldV2FindYieldValidatorsParams, options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof yieldV2FindYieldValidators>>, TError, TData>>;
}) => UseQueryOptions<ValidatorSearchResultDto[], TError, TData, QueryKey> & {
    queryKey: QueryKey;
};
type YieldV2FindYieldValidatorsQueryResult = NonNullable<Awaited<ReturnType<typeof yieldV2FindYieldValidators>>>;
type YieldV2FindYieldValidatorsQueryError = StakeKitErrorDto;
/**
 * @summary Get yield validators
 */
declare const useYieldV2FindYieldValidators: <TData = ValidatorSearchResultDto[], TError = StakeKitErrorDto>(yieldId: string, params?: YieldV2FindYieldValidatorsParams, options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof yieldV2FindYieldValidators>>, TError, TData>>;
}) => UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
};
/**
 * Returns a list of available validators to specify when providing a `validatorAddress` property.
 * @summary Get validators
 */
declare const yieldV2FindValidators: (params?: YieldV2FindValidatorsParams, signal?: AbortSignal) => Promise<ValidatorSearchResultDto[]>;
declare const getYieldV2FindValidatorsQueryKey: (params?: YieldV2FindValidatorsParams) => readonly ["/v2/yields/validators", ...YieldV2FindValidatorsParams[]];
declare const getYieldV2FindValidatorsQueryOptions: <TData = ValidatorSearchResultDto[], TError = StakeKitErrorDto>(params?: YieldV2FindValidatorsParams, options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof yieldV2FindValidators>>, TError, TData>>;
}) => UseQueryOptions<ValidatorSearchResultDto[], TError, TData, QueryKey> & {
    queryKey: QueryKey;
};
type YieldV2FindValidatorsQueryResult = NonNullable<Awaited<ReturnType<typeof yieldV2FindValidators>>>;
type YieldV2FindValidatorsQueryError = StakeKitErrorDto;
/**
 * @summary Get validators
 */
declare const useYieldV2FindValidators: <TData = ValidatorSearchResultDto[], TError = StakeKitErrorDto>(params?: YieldV2FindValidatorsParams, options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof yieldV2FindValidators>>, TError, TData>>;
}) => UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
};

type CustomFetch = <T>(input: RequestInfo | URL, init?: RequestInit) => Promise<T>;
declare class StakeKitApiClient {
    private static config;
    static configure({ apiKey, baseURL, customFetch, }: {
        apiKey: string;
        baseURL?: string;
        customFetch?: CustomFetch;
    }): void;
    static getConfig(): {
        apiKey: string;
        baseURL: string;
        customFetch?: CustomFetch | undefined;
    };
}

export { type ActionArgumentsDto, ActionDto, type ActionEnterGasEstimationQueryError, type ActionEnterGasEstimationQueryResult, type ActionEnterMutationBody, type ActionEnterMutationError, type ActionEnterMutationResult, type ActionExitGasEstimateQueryError, type ActionExitGasEstimateQueryResult, type ActionExitMutationBody, type ActionExitMutationError, type ActionExitMutationResult, type ActionGasEstimateRequestDto, type ActionGasEstimateRequestDtoGasArgs, type ActionGetActionQueryError, type ActionGetActionQueryResult, type ActionGetGasEstimateQueryError, type ActionGetGasEstimateQueryResult, ActionList200, ActionList200AllOf, type ActionListParams, type ActionListQueryError, type ActionListQueryResult, ActionListSort, ActionListStatus, ActionListType, type ActionPendingGasEstimateQueryError, type ActionPendingGasEstimateQueryResult, type ActionPendingMutationBody, type ActionPendingMutationError, type ActionPendingMutationResult, type ActionRequestDto, ActionStatus, ActionTypes, type ActionWithLivePriceDto, type AddressWithTokenDto, type AddressWithTokenDtoAdditionalAddresses, AddressesDto, type ApeNativeArgumentsDto, type AuthConfirmEmailDto, type AuthEmailLoginDto, type AuthEmailLoginResponseDto, type AuthForgotPasswordDto, type AuthResetPasswordDto, type AuthUpdateDto, AvalancheCAdditionalAddressesDto, BalanceResponseDto, type BalancesRequestDto, type BannedRegionDto, BinanceAdditionalAddressesDto, type ConfirmUserMeDto, type ConstructTransactionRequestDto, type ConstructTransactionRequestDtoGasArgs, CosmosAdditionalAddressesDto, CosmosGasArgsDto, type CreateBannedRegionDto, type CreateCustomUriDto, type CreateEnabledYieldDto, type CreateFeeConfigurationDto, type CreateKeyDto, type CreateMasterBannedRegionDto, type CreatePayoutAddressDto, type CreateProjectDto, type CreateTeamDto, type CreateTeamDtoContactDetails, type CreateTeamDtoUser, type CreateUserDto, type CreateWebhookSubscriptionDto, type CreateWebhookSubscriptionDtoEvent, type CustomUri, type CustomValidatorAddresses, type DailyCumulativeStakeDto, DailyCumulativeStakeDtoStatus, DailyCumulativeStakeDtoType, type DeleteBannedRegionsDto, type DeleteEnabledYieldsDto, type DeleteMasterBannedRegionsDto, type EnabledYieldDto, EvmEIP1559GasArgsDto, EvmLegacyGasArgsDto, EvmNetworks, FeeConfigurationDto, GasEstimateDto, GasForNetworkResponseDto, type GeolocationError, type GeolocationErrorDetails, type GeolocationErrorRegionCode, GeolocationErrorTagsItem, GeolocationErrorType, type HealthHealthV2QueryError, type HealthHealthV2QueryResult, HealthStatusDto, InfinityPaginatedDto, type Key, KeyCategory, type MasterBannedRegionDto, MasterBannedRegionDtoTagsItem, type MasterBannedYieldDto, MasterBannedYieldDtoTagsItem, Networks, type PayoutAddressDto, type PendingActionArgumentsDto, type PendingActionGasEstimateRequestDto, type PendingActionGasEstimateRequestDtoGasArgs, type PendingActionRequestDto, type PositionDto, type PriceRequestDto, PriceResponseDto, type Project, type ReferralDto, type ReportEntryDto, Role, type SignatureVerificationArgumentsDto, SolanaAdditionalAddressesDto, StakeKitApiClient, type StakeKitErrorDto, type StakeKitErrorDtoDetails, type SubmitHashRequestDto, type SubmitRequestDto, SubmitResponseDto, type Team, TeamCategory, type TeamContactDetails, type TeamDto, type TeamDtoContactDetails, TeamType, TezosAdditionalAddressesDto, type TokenBalanceScanDto, TokenBalanceScanResponseDto, TokenDto, type TokenGetTokenBalancesQueryError, type TokenGetTokenBalancesQueryResult, type TokenGetTokenPricesQueryError, type TokenGetTokenPricesQueryResult, type TokenGetTokensParams, type TokenGetTokensQueryError, type TokenGetTokensQueryResult, type TokenTokenBalancesScanQueryError, type TokenTokenBalancesScanQueryResult, TokenWithAvailableYieldsDto, type TransactionConstructMutationBody, type TransactionConstructMutationError, type TransactionConstructMutationResult, TransactionDto, type TransactionGetGasForNetworkQueryError, type TransactionGetGasForNetworkQueryResult, type TransactionGetTransactionQueryError, type TransactionGetTransactionQueryResult, type TransactionGetTransactionStatusByNetworkAndHashQueryError, type TransactionGetTransactionStatusByNetworkAndHashQueryResult, type TransactionGetTransactionStatusFromIdQueryError, type TransactionGetTransactionStatusFromIdQueryResult, type TransactionGetTransactionVerificationMessageForNetworkMutationBody, type TransactionGetTransactionVerificationMessageForNetworkMutationError, type TransactionGetTransactionVerificationMessageForNetworkMutationResult, TransactionStatusResponseDto, type TransactionSubmitHashMutationBody, type TransactionSubmitHashMutationError, type TransactionSubmitHashMutationResult, type TransactionSubmitMutationBody, type TransactionSubmitMutationError, type TransactionSubmitMutationResult, TransactionVerificationMessageDto, type TransactionVerificationMessageRequestDto, TronResourceType, type UpdateCustomUriDto, type UpdateFeeConfigurationDto, type UpdateKeyDto, type UpdatePayoutAddressDto, type UpdateProjectDto, type UpdateTeamDto, type UpdateUserDto, type UpdateUserMeDto, type UpdateWebhookSubscriptionDto, type UpdateWebhookSubscriptionDtoEvent, type UserDto, type ValidatorAddressesDto, ValidatorDto, ValidatorSearchResultDto, type WebhookSubscriptionDto, type WebhookSubscriptionEventDto, WebhookSubscriptionEventDtoEvent, YieldBalanceDto, type YieldBalanceRequestDto, type YieldBalanceScanEvmRequestDto, type YieldBalanceScanRequestDto, type YieldBalanceWithIntegrationIdRequestDto, YieldBalancesWithIntegrationIdDto, YieldDto, type YieldFindValidatorsParams, type YieldFindValidatorsQueryError, type YieldFindValidatorsQueryResult, type YieldGetFeeConfigurationQueryError, type YieldGetFeeConfigurationQueryResult, type YieldGetMultipleYieldBalancesQueryError, type YieldGetMultipleYieldBalancesQueryResult, type YieldGetMyNetworksQueryError, type YieldGetMyNetworksQueryResult, YieldGetMyYields200, YieldGetMyYields200AllOf, type YieldGetMyYieldsParams, type YieldGetMyYieldsQueryError, type YieldGetMyYieldsQueryResult, YieldGetMyYieldsSortBy, YieldGetMyYieldsType, type YieldGetSingleYieldBalancesParams, type YieldGetSingleYieldBalancesQueryError, type YieldGetSingleYieldBalancesQueryResult, type YieldGetSingleYieldRewardsSummaryMutationBody, type YieldGetSingleYieldRewardsSummaryMutationError, type YieldGetSingleYieldRewardsSummaryMutationResult, type YieldGetValidatorsParams, type YieldGetValidatorsQueryError, type YieldGetValidatorsQueryResult, YieldMetadataDto, type YieldRewardsSummaryRequestDto, YieldRewardsSummaryResponseDto, type YieldV2FindValidatorsParams, type YieldV2FindValidatorsQueryError, type YieldV2FindValidatorsQueryResult, type YieldV2FindYieldValidatorsParams, type YieldV2FindYieldValidatorsQueryError, type YieldV2FindYieldValidatorsQueryResult, type YieldV2GetYieldByIdQueryError, type YieldV2GetYieldByIdQueryResult, YieldV2Yields200, YieldV2Yields200AllOf, YieldV2YieldsNetwork, type YieldV2YieldsParams, type YieldV2YieldsQueryError, type YieldV2YieldsQueryResult, YieldV2YieldsRevenueOption, YieldV2YieldsSortBy, YieldV2YieldsType, type YieldYieldBalancesScanEvmMutationBody, type YieldYieldBalancesScanEvmMutationError, type YieldYieldBalancesScanEvmMutationResult, type YieldYieldBalancesScanQueryError, type YieldYieldBalancesScanQueryResult, type YieldYieldOpportunityParams, type YieldYieldOpportunityQueryError, type YieldYieldOpportunityQueryResult, YieldYields200, YieldYields200AllOf, type YieldYieldsParams, type YieldYieldsQueryError, type YieldYieldsQueryResult, YieldYieldsRevenueOption, YieldYieldsSortBy, YieldYieldsType, actionEnter, actionEnterGasEstimation, actionExit, actionExitGasEstimate, actionGetAction, actionGetGasEstimate, actionList, actionPending, actionPendingGasEstimate, getActionEnterGasEstimationQueryKey, getActionEnterGasEstimationQueryOptions, getActionEnterMutationOptions, getActionExitGasEstimateQueryKey, getActionExitGasEstimateQueryOptions, getActionExitMutationOptions, getActionGetActionQueryKey, getActionGetActionQueryOptions, getActionGetGasEstimateQueryKey, getActionGetGasEstimateQueryOptions, getActionListQueryKey, getActionListQueryOptions, getActionPendingGasEstimateQueryKey, getActionPendingGasEstimateQueryOptions, getActionPendingMutationOptions, getHealthHealthV2QueryKey, getHealthHealthV2QueryOptions, getTokenGetTokenBalancesQueryKey, getTokenGetTokenBalancesQueryOptions, getTokenGetTokenPricesQueryKey, getTokenGetTokenPricesQueryOptions, getTokenGetTokensQueryKey, getTokenGetTokensQueryOptions, getTokenTokenBalancesScanQueryKey, getTokenTokenBalancesScanQueryOptions, getTransactionConstructMutationOptions, getTransactionGetGasForNetworkQueryKey, getTransactionGetGasForNetworkQueryOptions, getTransactionGetTransactionQueryKey, getTransactionGetTransactionQueryOptions, getTransactionGetTransactionStatusByNetworkAndHashQueryKey, getTransactionGetTransactionStatusByNetworkAndHashQueryOptions, getTransactionGetTransactionStatusFromIdQueryKey, getTransactionGetTransactionStatusFromIdQueryOptions, getTransactionGetTransactionVerificationMessageForNetworkMutationOptions, getTransactionSubmitHashMutationOptions, getTransactionSubmitMutationOptions, getYieldFindValidatorsQueryKey, getYieldFindValidatorsQueryOptions, getYieldGetFeeConfigurationQueryKey, getYieldGetFeeConfigurationQueryOptions, getYieldGetMultipleYieldBalancesQueryKey, getYieldGetMultipleYieldBalancesQueryOptions, getYieldGetMyNetworksQueryKey, getYieldGetMyNetworksQueryOptions, getYieldGetMyYieldsQueryKey, getYieldGetMyYieldsQueryOptions, getYieldGetSingleYieldBalancesQueryKey, getYieldGetSingleYieldBalancesQueryOptions, getYieldGetSingleYieldRewardsSummaryMutationOptions, getYieldGetValidatorsQueryKey, getYieldGetValidatorsQueryOptions, getYieldV2FindValidatorsQueryKey, getYieldV2FindValidatorsQueryOptions, getYieldV2FindYieldValidatorsQueryKey, getYieldV2FindYieldValidatorsQueryOptions, getYieldV2GetYieldByIdQueryKey, getYieldV2GetYieldByIdQueryOptions, getYieldV2YieldsQueryKey, getYieldV2YieldsQueryOptions, getYieldYieldBalancesScanEvmMutationOptions, getYieldYieldBalancesScanQueryKey, getYieldYieldBalancesScanQueryOptions, getYieldYieldOpportunityQueryKey, getYieldYieldOpportunityQueryOptions, getYieldYieldsQueryKey, getYieldYieldsQueryOptions, healthHealthV2, tokenGetTokenBalances, tokenGetTokenPrices, tokenGetTokens, tokenTokenBalancesScan, transactionConstruct, transactionGetGasForNetwork, transactionGetTransaction, transactionGetTransactionStatusByNetworkAndHash, transactionGetTransactionStatusFromId, transactionGetTransactionVerificationMessageForNetwork, transactionSubmit, transactionSubmitHash, useActionEnter, useActionEnterGasEstimation, useActionExit, useActionExitGasEstimate, useActionGetAction, useActionGetGasEstimate, useActionList, useActionPending, useActionPendingGasEstimate, useHealthHealthV2, useTokenGetTokenBalances, useTokenGetTokenPrices, useTokenGetTokens, useTokenTokenBalancesScan, useTransactionConstruct, useTransactionGetGasForNetwork, useTransactionGetTransaction, useTransactionGetTransactionStatusByNetworkAndHash, useTransactionGetTransactionStatusFromId, useTransactionGetTransactionVerificationMessageForNetwork, useTransactionSubmit, useTransactionSubmitHash, useYieldFindValidators, useYieldGetFeeConfiguration, useYieldGetMultipleYieldBalances, useYieldGetMyNetworks, useYieldGetMyYields, useYieldGetSingleYieldBalances, useYieldGetSingleYieldRewardsSummary, useYieldGetValidators, useYieldV2FindValidators, useYieldV2FindYieldValidators, useYieldV2GetYieldById, useYieldV2Yields, useYieldYieldBalancesScan, useYieldYieldBalancesScanEvm, useYieldYieldOpportunity, useYieldYields, yieldFindValidators, yieldGetFeeConfiguration, yieldGetMultipleYieldBalances, yieldGetMyNetworks, yieldGetMyYields, yieldGetSingleYieldBalances, yieldGetSingleYieldRewardsSummary, yieldGetValidators, yieldV2FindValidators, yieldV2FindYieldValidators, yieldV2GetYieldById, yieldV2Yields, yieldYieldBalancesScan, yieldYieldBalancesScanEvm, yieldYieldOpportunity, yieldYields };
